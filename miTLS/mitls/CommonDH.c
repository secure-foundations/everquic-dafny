/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "CommonDH.h"

static FStar_Bytes_bytes TLS_Curve25519_pubshare(K___FStar_Bytes_bytes_FStar_Bytes_bytes k1)
{
  return FStar_Pervasives_Native_fst__FStar_Bytes_bytes_FStar_Bytes_bytes(k1);
}

static FStar_Bytes_bytes
TLS_Curve25519_scalarmult(FStar_Bytes_bytes secret1, FStar_Bytes_bytes point)
{
  uint32_t lp = FStar_Bytes_len(point);
  uint32_t ls = FStar_Bytes_len(secret1);
  KRML_CHECK_SIZE(sizeof (uint8_t), lp);
  uint8_t pb[lp];
  memset(pb, 0U, lp * sizeof pb[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), ls);
  uint8_t sb[ls];
  memset(sb, 0U, ls * sizeof sb[0U]);
  uint8_t out[32U] = { 0U };
  FStar_Bytes_store_bytes(point, pb);
  FStar_Bytes_store_bytes(secret1, sb);
  bool uu____0 = EverCrypt_Curve25519_ecdh((void **)out, (void **)sb, (void **)pb);
  return FStar_Bytes_of_buffer((uint32_t)32U, (uint8_t *)out);
}

static K___FStar_Bytes_bytes_FStar_Bytes_bytes TLS_Curve25519_keygen()
{
  FStar_Bytes_bytes s = Random_sample32((uint32_t)32U);
  FStar_Bytes_bytes
  base_point =
    FStar_Bytes_append(FStar_Bytes_create((uint32_t)1U, (uint8_t)9U),
      FStar_Bytes_create((uint32_t)31U, (uint8_t)0U));
  return
    (
      (K___FStar_Bytes_bytes_FStar_Bytes_bytes){
        .fst = TLS_Curve25519_scalarmult(s, base_point),
        .snd = s
      }
    );
}

static FStar_Bytes_bytes TLS_Curve25519_mul(FStar_Bytes_bytes k1, FStar_Bytes_bytes p1)
{
  return TLS_Curve25519_scalarmult(k1, p1);
}

static Prims_int ECGroup_bytelen(EverCrypt_ec_curve g1)
{
  switch (g1)
  {
    case EverCrypt_ECC_P256:
      {
        return (krml_checked_int_t)32;
      }
    case EverCrypt_ECC_P384:
      {
        return (krml_checked_int_t)48;
      }
    case EverCrypt_ECC_P521:
      {
        return (krml_checked_int_t)66;
      }
    case EverCrypt_ECC_X25519:
      {
        return (krml_checked_int_t)32;
      }
    case EverCrypt_ECC_X448:
      {
        return (krml_checked_int_t)56;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static ECGroup_pre_share ECGroup_pubshare(EverCrypt_ec_curve g1, ECGroup_pre_keyshare k1)
{
  if (k1.tag == ECGroup_KS_CC)
  {
    ECGroup_point p1 = k1.val.case_KS_CC._0;
    return ((ECGroup_pre_share){ .tag = ECGroup_S_CC, .val = { .case_S_CC = p1 } });
  }
  else if (k1.tag == ECGroup_KS_X25519)
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes k2 = k1.val.case_KS_X25519;
    return
      (
        (ECGroup_pre_share){
          .tag = ECGroup_S_X25519,
          .val = { .case_S_X25519 = TLS_Curve25519_pubshare(k2) }
        }
      );
  }
  else if (k1.tag == ECGroup_KS_X448)
  {
    FStar_Bytes_bytes p1 = k1.val.case_KS_X448.pub;
    return ((ECGroup_pre_share){ .tag = ECGroup_S_X448, .val = { .case_S_X448 = p1 } });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static ECGroup_pre_keyshare ECGroup_keygen(EverCrypt_ec_curve g1)
{
  switch (g1)
  {
    case EverCrypt_ECC_X25519:
      {
        return
          (
            (ECGroup_pre_keyshare){
              .tag = ECGroup_KS_X25519,
              .val = { .case_KS_X25519 = TLS_Curve25519_keygen() }
            }
          );
      }
    case EverCrypt_ECC_X448:
      {
        FStar_Bytes_bytes s = Random_sample32((uint32_t)56U);
        FStar_Bytes_bytes p1 = Random_sample32((uint32_t)56U);
        return
          (
            (ECGroup_pre_keyshare){
              .tag = ECGroup_KS_X448,
              .val = { .case_KS_X448 = { .pub = p1, .priv = s } }
            }
          );
      }
    default:
      {
        uint32_t l = FStar_UInt32_uint_to_t(ECGroup_bytelen(g1));
        KRML_CHECK_SIZE(sizeof (uint8_t), l);
        uint8_t xb[l];
        memset(xb, 0U, l * sizeof xb[0U]);
        KRML_CHECK_SIZE(sizeof (uint8_t), l);
        uint8_t yb[l];
        memset(yb, 0U, l * sizeof yb[0U]);
        EverCrypt__ecdh_state *st = EverCrypt_ecdh_load_curve(g1);
        EverCrypt_ecdh_keygen(st, xb, yb);
        FStar_Bytes_bytes uu____0 = FStar_Bytes_of_buffer(l, (uint8_t *)xb);
        ECGroup_point p1 = { .ecx = uu____0, .ecy = FStar_Bytes_of_buffer(l, (uint8_t *)yb) };
        return
          (
            (ECGroup_pre_keyshare){
              .tag = ECGroup_KS_CC,
              .val = { .case_KS_CC = { ._0 = p1, ._1 = st } }
            }
          );
      }
  }
}

static FStar_Bytes_bytes
ECGroup_dh_initiator(EverCrypt_ec_curve g1, ECGroup_pre_keyshare gx, ECGroup_pre_share gy)
{
  switch (g1)
  {
    case EverCrypt_ECC_X25519:
      {
        if (gx.tag == ECGroup_KS_X25519)
        {
          FStar_Bytes_bytes s = gx.val.case_KS_X25519.snd;
          if (gy.tag == ECGroup_S_X25519)
          {
            FStar_Bytes_bytes gy1 = gy.val.case_S_X25519;
            return TLS_Curve25519_mul(s, gy1);
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
        break;
      }
    case EverCrypt_ECC_X448:
      {
        if (gx.tag == ECGroup_KS_X448)
          return gx.val.case_KS_X448.priv;
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
        break;
      }
    default:
      {
        if (gx.tag == ECGroup_KS_CC)
        {
          EverCrypt__ecdh_state *st = gx.val.case_KS_CC._1;
          if (gy.tag == ECGroup_S_CC)
          {
            ECGroup_point gy1 = gy.val.case_S_CC;
            uint32_t l = FStar_UInt32_uint_to_t(ECGroup_bytelen(g1));
            KRML_CHECK_SIZE(sizeof (uint8_t), l);
            uint8_t xb[l];
            memset(xb, 0U, l * sizeof xb[0U]);
            KRML_CHECK_SIZE(sizeof (uint8_t), l);
            uint8_t yb[l];
            memset(yb, 0U, l * sizeof yb[0U]);
            KRML_CHECK_SIZE(sizeof (uint8_t), l);
            uint8_t rb[l];
            memset(rb, 0U, l * sizeof rb[0U]);
            FStar_Bytes_store_bytes(gy1.ecx, xb);
            FStar_Bytes_store_bytes(gy1.ecy, yb);
            uint32_t ol = EverCrypt_ecdh_compute(st, xb, yb, rb);
            FStar_Bytes_bytes r = FStar_Bytes_of_buffer(ol, (uint8_t *)rb);
            EverCrypt_ecdh_free_curve(st);
            return r;
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
  }
}

typedef struct FStar_Pervasives_Native_option__EverCrypt_ec_curve_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  EverCrypt_ec_curve v;
}
FStar_Pervasives_Native_option__EverCrypt_ec_curve;

static FStar_Pervasives_Native_option__EverCrypt_ec_curve
ECGroup_parse_curve(FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)1))
    return
      ((FStar_Pervasives_Native_option__EverCrypt_ec_curve){ .tag = FStar_Pervasives_Native_None });
  else
  {
    FStar_Pervasives_Native_option__K___Parsers_ECCurveType_eCCurveType_uint32_t
    scrut = Parsers_ECCurveType_eCCurveType_parser32(b);
    if
    (scrut.tag == FStar_Pervasives_Native_Some && scrut.v.fst == Parsers_ECCurveType_Named_curve)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = FStar_Bytes_split(b, (uint32_t)1U);
      FStar_Bytes_bytes id1 = scrut.snd;
      FStar_Pervasives_Native_option__K___Parsers_NamedGroup_namedGroup_uint32_t
      scrut0 = Parsers_NamedGroup_namedGroup_parser32(id1);
      if
      (
        scrut0.tag
        == FStar_Pervasives_Native_Some
        && scrut0.v.fst.tag == Parsers_NamedGroup_Secp256r1
      )
        return
          (
            (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
              .tag = FStar_Pervasives_Native_Some,
              .v = EverCrypt_ECC_P256
            }
          );
      else if
      (
        scrut0.tag
        == FStar_Pervasives_Native_Some
        && scrut0.v.fst.tag == Parsers_NamedGroup_Secp384r1
      )
        return
          (
            (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
              .tag = FStar_Pervasives_Native_Some,
              .v = EverCrypt_ECC_P384
            }
          );
      else if
      (
        scrut0.tag
        == FStar_Pervasives_Native_Some
        && scrut0.v.fst.tag == Parsers_NamedGroup_Secp521r1
      )
        return
          (
            (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
              .tag = FStar_Pervasives_Native_Some,
              .v = EverCrypt_ECC_P521
            }
          );
      else if
      (scrut0.tag == FStar_Pervasives_Native_Some && scrut0.v.fst.tag == Parsers_NamedGroup_X25519)
        return
          (
            (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
              .tag = FStar_Pervasives_Native_Some,
              .v = EverCrypt_ECC_X25519
            }
          );
      else if
      (scrut0.tag == FStar_Pervasives_Native_Some && scrut0.v.fst.tag == Parsers_NamedGroup_X448)
        return
          (
            (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
              .tag = FStar_Pervasives_Native_Some,
              .v = EverCrypt_ECC_X448
            }
          );
      else
        return
          (
            (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
    else
      return
        (
          (FStar_Pervasives_Native_option__EverCrypt_ec_curve){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
}

typedef struct FStar_Pervasives_Native_option__ECGroup_pre_share_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  ECGroup_pre_share v;
}
FStar_Pervasives_Native_option__ECGroup_pre_share;

static FStar_Pervasives_Native_option__ECGroup_pre_share
ECGroup_parse_point(EverCrypt_ec_curve g1, FStar_Bytes_bytes b)
{
  switch (g1)
  {
    case EverCrypt_ECC_X448:
      {
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
        if (FStar_Bytes_len(b) < (uint32_t)56U)
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else
        {
          FStar_Bytes_bytes s_ = FStar_Bytes_slice(b, (uint32_t)0U, (uint32_t)56U);
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = s_, .snd = (uint32_t)56U }
              }
            );
        }
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          FStar_Bytes_bytes bs = scrut.v.fst;
          return
            (
              (FStar_Pervasives_Native_option__ECGroup_pre_share){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .tag = ECGroup_S_X448, .val = { .case_S_X448 = bs } }
              }
            );
        }
        else
          return
            (
              (FStar_Pervasives_Native_option__ECGroup_pre_share){
                .tag = FStar_Pervasives_Native_None
              }
            );
        break;
      }
    case EverCrypt_ECC_X25519:
      {
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
        if (FStar_Bytes_len(b) < (uint32_t)32U)
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else
        {
          FStar_Bytes_bytes s_ = FStar_Bytes_slice(b, (uint32_t)0U, (uint32_t)32U);
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = s_, .snd = (uint32_t)32U }
              }
            );
        }
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          FStar_Bytes_bytes bs = scrut.v.fst;
          return
            (
              (FStar_Pervasives_Native_option__ECGroup_pre_share){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .tag = ECGroup_S_X25519, .val = { .case_S_X25519 = bs } }
              }
            );
        }
        else
          return
            (
              (FStar_Pervasives_Native_option__ECGroup_pre_share){
                .tag = FStar_Pervasives_Native_None
              }
            );
        break;
      }
    default:
      {
        uint32_t cl = FStar_UInt32_uint_to_t(ECGroup_bytelen(g1));
        FStar_Pervasives_Native_option__K___Format_UncompressedPointRepresentation_uncompressedPointRepresentation_uint32_t
        scrut =
          Format_UncompressedPointRepresentation_uncompressedPointRepresentation_parser32(cl,
            b);
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          Format_UncompressedPointRepresentation_uncompressedPointRepresentation ucpr = scrut.v.fst;
          ECGroup_point e = { .ecx = ucpr.x, .ecy = ucpr.y };
          return
            (
              (FStar_Pervasives_Native_option__ECGroup_pre_share){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .tag = ECGroup_S_CC, .val = { .case_S_CC = e } }
              }
            );
        }
        else
          return
            (
              (FStar_Pervasives_Native_option__ECGroup_pre_share){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__EverCrypt_ec_curve_ECGroup_pre_share_FStar_Bytes_bytes
TLSError_fatal__Prims_dtuple2_EverCrypt_ec_curve_ECGroup_pre_share___FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__EverCrypt_ec_curve_ECGroup_pre_share_FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__EverCrypt_ec_curve_ECGroup_pre_share_FStar_Bytes_bytes
ECGroup_parse_partial(FStar_Bytes_bytes payload)
{
  if
  (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(payload)), (krml_checked_int_t)7))
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(payload, (uint32_t)3U);
    FStar_Bytes_bytes curve = scrut0.fst;
    FStar_Bytes_bytes point = scrut0.snd;
    FStar_Pervasives_Native_option__EverCrypt_ec_curve scrut1 = ECGroup_parse_curve(curve);
    if (scrut1.tag == FStar_Pervasives_Native_None)
      return
        TLSError_fatal__Prims_dtuple2_EverCrypt_ec_curve_ECGroup_pre_share___FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("ECGroup.fst", (krml_checked_int_t)129, "Unsupported curve"));
    else if (scrut1.tag == FStar_Pervasives_Native_Some)
    {
      EverCrypt_ec_curve ecp = scrut1.v;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut0 = Parse_vlsplit((krml_checked_int_t)1, point);
      if (scrut0.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__EverCrypt_ec_curve_ECGroup_pre_share_FStar_Bytes_bytes){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut0.tag == FStar_Error_Correct)
      {
        K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut0.val.case_Correct;
        FStar_Bytes_bytes rawpoint = x.fst;
        FStar_Bytes_bytes rem1 = x.snd;
        FStar_Pervasives_Native_option__ECGroup_pre_share
        scrut = ECGroup_parse_point(ecp, rawpoint);
        if (scrut.tag == FStar_Pervasives_Native_None)
          return
            TLSError_fatal__Prims_dtuple2_EverCrypt_ec_curve_ECGroup_pre_share___FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("ECGroup.fst",
                (krml_checked_int_t)136,
                Prims_strcat("Invalid EC point received:", FStar_Bytes_print_bytes(rawpoint))));
        else if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          ECGroup_pre_share p1 = scrut.v;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__EverCrypt_ec_curve_ECGroup_pre_share_FStar_Bytes_bytes){
                .tag = FStar_Error_Correct,
                .val = { .case_Correct = { .fst = { .fst = ecp, .snd = p1 }, .snd = rem1 } }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return
      TLSError_fatal__Prims_dtuple2_EverCrypt_ec_curve_ECGroup_pre_share___FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("ECGroup.fst", (krml_checked_int_t)138, ""));
}

static FStar_Bytes_bytes ECGroup_serialize_point(EverCrypt_ec_curve g1, ECGroup_pre_share s)
{
  switch (g1)
  {
    case EverCrypt_ECC_X25519:
      {
        if (s.tag == ECGroup_S_X25519)
          return s.val.case_S_X25519;
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
        break;
      }
    case EverCrypt_ECC_X448:
      {
        if (s.tag == ECGroup_S_X448)
          return s.val.case_S_X448;
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
        break;
      }
    default:
      {
        if (s.tag == ECGroup_S_CC)
        {
          ECGroup_point e = s.val.case_S_CC;
          Prims_int l = FStar_UInt32_v(FStar_Bytes_len(e.ecx));
          uint32_t l32 = FStar_UInt32_uint_to_t(l);
          Format_UncompressedPointRepresentation_uncompressedPointRepresentation
          ucp = { .legacy_form = (uint8_t)4U, .x = e.ecx, .y = e.ecy };
          FStar_Bytes_bytes
          x =
            Format_UncompressedPointRepresentation_uncompressedPointRepresentation_serializer32(l32,
              ucp);
          return x;
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
  }
}

static FStar_Bytes_bytes ECGroup_curve_id(EverCrypt_ec_curve g1)
{
  Parsers_NamedGroup_namedGroup sw;
  switch (g1)
  {
    case EverCrypt_ECC_P256:
      {
        sw = ((Parsers_NamedGroup_namedGroup){ .tag = Parsers_NamedGroup_Secp256r1 });
        break;
      }
    case EverCrypt_ECC_P384:
      {
        sw = ((Parsers_NamedGroup_namedGroup){ .tag = Parsers_NamedGroup_Secp384r1 });
        break;
      }
    case EverCrypt_ECC_P521:
      {
        sw = ((Parsers_NamedGroup_namedGroup){ .tag = Parsers_NamedGroup_Secp521r1 });
        break;
      }
    case EverCrypt_ECC_X25519:
      {
        sw = ((Parsers_NamedGroup_namedGroup){ .tag = Parsers_NamedGroup_X25519 });
        break;
      }
    case EverCrypt_ECC_X448:
      {
        sw = ((Parsers_NamedGroup_namedGroup){ .tag = Parsers_NamedGroup_X448 });
        break;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  FStar_Bytes_bytes r = Parsers_NamedGroup_namedGroup_serializer32(sw);
  return r;
}

static FStar_Bytes_bytes ECGroup_serialize(EverCrypt_ec_curve g1, ECGroup_pre_share ecdh_Y)
{
  FStar_Bytes_bytes ty = FStar_Bytes_abyte((uint8_t)3U);
  FStar_Bytes_bytes id1 = ECGroup_curve_id(g1);
  FStar_Bytes_bytes e = ECGroup_serialize_point(g1, ecdh_Y);
  FStar_Bytes_bytes ve = Parse_vlbytes((krml_checked_int_t)1, e);
  return FStar_Bytes_append(ty, FStar_Bytes_append(id1, ve));
}

DHGroup_params DHGroup_make_ffdhe(Prims_string p1, Prims_string q)
{
  return
    (
      (DHGroup_params){
        .dh_p = FStar_Bytes_bytes_of_hex(p1),
        .dh_g = FStar_Bytes_abyte((uint8_t)2U),
        .dh_q = { .tag = FStar_Pervasives_Native_Some, .v = FStar_Bytes_bytes_of_hex(q) },
        .safe_prime = true
      }
    );
}

DHGroup_params DHGroup_ffdhe2048;

DHGroup_params DHGroup_ffdhe3072;

DHGroup_params DHGroup_ffdhe4096;

DHGroup_params DHGroup_ffdhe6144;

DHGroup_params DHGroup_ffdhe8192;

static DHGroup_params DHGroup_params_of_group(DHGroup_group uu___0_313)
{
  if (uu___0_313.tag == DHGroup_Named && uu___0_313.val.case_Named == DHGroup_FFDHE2048)
    return DHGroup_ffdhe2048;
  else if (uu___0_313.tag == DHGroup_Named && uu___0_313.val.case_Named == DHGroup_FFDHE3072)
    return DHGroup_ffdhe3072;
  else if (uu___0_313.tag == DHGroup_Named && uu___0_313.val.case_Named == DHGroup_FFDHE4096)
    return DHGroup_ffdhe4096;
  else if (uu___0_313.tag == DHGroup_Named && uu___0_313.val.case_Named == DHGroup_FFDHE6144)
    return DHGroup_ffdhe6144;
  else if (uu___0_313.tag == DHGroup_Named && uu___0_313.val.case_Named == DHGroup_FFDHE8192)
    return DHGroup_ffdhe8192;
  else if (uu___0_313.tag == DHGroup_Explicit)
    return uu___0_313.val.case_Explicit;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes
FStar_Pervasives_Native_fst__FStar_Bytes_bytes__EverCrypt__dh_state_(
  K___FStar_Bytes_bytes__EverCrypt__dh_state_ x
)
{
  return x.fst;
}

static FStar_Bytes_bytes
DHGroup_pubshare(DHGroup_group g1, K___FStar_Bytes_bytes__EverCrypt__dh_state_ k1)
{
  return FStar_Pervasives_Native_fst__FStar_Bytes_bytes__EverCrypt__dh_state_(k1);
}

static K___FStar_Bytes_bytes__EverCrypt__dh_state_ DHGroup_keygen(DHGroup_group g1)
{
  DHGroup_params p1 = DHGroup_params_of_group(g1);
  FStar_Bytes_bytes q;
  if (p1.dh_q.tag == FStar_Pervasives_Native_Some)
    q = p1.dh_q.v;
  else if (p1.dh_q.tag == FStar_Pervasives_Native_None)
    q = FStar_Bytes_empty_bytes;
  else
    q = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  uint32_t lp = FStar_Bytes_len(p1.dh_p);
  KRML_CHECK_SIZE(sizeof (uint8_t), lp);
  uint8_t pb[lp];
  memset(pb, 0U, lp * sizeof pb[0U]);
  uint32_t lq = FStar_Bytes_len(q);
  KRML_CHECK_SIZE(sizeof (uint8_t), lq);
  uint8_t qb[lq];
  memset(qb, 0U, lq * sizeof qb[0U]);
  uint32_t lg = FStar_Bytes_len(p1.dh_g);
  KRML_CHECK_SIZE(sizeof (uint8_t), lg);
  uint8_t gb[lg];
  memset(gb, 0U, lg * sizeof gb[0U]);
  FStar_Bytes_store_bytes(p1.dh_p, pb);
  FStar_Bytes_store_bytes(q, qb);
  FStar_Bytes_store_bytes(p1.dh_g, gb);
  EverCrypt__dh_state *st = EverCrypt_dh_load_group(pb, lp, gb, lg, qb, lq);
  KRML_CHECK_SIZE(sizeof (uint8_t), lp);
  uint8_t pub[lp];
  memset(pub, 0U, lp * sizeof pub[0U]);
  uint32_t lpub = EverCrypt_dh_keygen(st, pub);
  FStar_Bytes_bytes s = FStar_Bytes_of_buffer(lpub, (uint8_t *)pub);
  return ((K___FStar_Bytes_bytes__EverCrypt__dh_state_){ .fst = s, .snd = st });
}

static FStar_Bytes_bytes
DHGroup_dh_initiator(
  DHGroup_group g1,
  K___FStar_Bytes_bytes__EverCrypt__dh_state_ x,
  FStar_Bytes_bytes gy
)
{
  EverCrypt__dh_state *st = x.snd;
  DHGroup_params p1 = DHGroup_params_of_group(g1);
  KRML_CHECK_SIZE(sizeof (uint8_t), FStar_Bytes_len(p1.dh_p));
  uint8_t rb[FStar_Bytes_len(p1.dh_p)];
  memset(rb, 0U, FStar_Bytes_len(p1.dh_p) * sizeof rb[0U]);
  uint32_t ly = FStar_Bytes_len(gy);
  KRML_CHECK_SIZE(sizeof (uint8_t), ly);
  uint8_t yb[ly];
  memset(yb, 0U, ly * sizeof yb[0U]);
  FStar_Bytes_store_bytes(gy, yb);
  uint32_t lr = EverCrypt_dh_compute(st, yb, ly, rb);
  return FStar_Bytes_of_buffer(lr, (uint8_t *)rb);
}

typedef struct K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_s
{
  FStar_Bytes_bytes fst;
  K___FStar_Bytes_bytes_FStar_Bytes_bytes snd;
}
K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes;

typedef struct
K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_s
{
  FStar_Bytes_bytes fst;
  K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes snd;
}
K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes;

static FStar_Bytes_bytes DHGroup_serialize(DHGroup_group g1, FStar_Bytes_bytes dh_Y)
{
  DHGroup_params x = DHGroup_params_of_group(g1);
  FStar_Bytes_bytes a = x.dh_p;
  FStar_Bytes_bytes b = x.dh_g;
  FStar_Bytes_bytes c = dh_Y;
  FStar_Bytes_bytes d = FStar_Bytes_empty_bytes;
  K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes
  x10 = { .fst = a, .snd = { .fst = b, .snd = { .fst = c, .snd = d } } };
  FStar_Bytes_bytes fs = x10.fst;
  K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes sn = x10.snd;
  FStar_Bytes_bytes x11 = fs;
  FStar_Bytes_bytes x12 = x11;
  FStar_Bytes_bytes pl = x12;
  uint32_t len10 = FStar_Bytes_len(pl);
  FStar_Bytes_bytes slen = LowParse_SLow_BoundedInt_serialize32_bounded_integer_2(len10);
  FStar_Bytes_bytes res = FStar_Bytes_append(slen, pl);
  FStar_Bytes_bytes output1 = res;
  FStar_Bytes_bytes fs1 = sn.fst;
  K___FStar_Bytes_bytes_FStar_Bytes_bytes sn1 = sn.snd;
  FStar_Bytes_bytes x13 = fs1;
  FStar_Bytes_bytes x14 = x13;
  FStar_Bytes_bytes pl0 = x14;
  uint32_t len11 = FStar_Bytes_len(pl0);
  FStar_Bytes_bytes slen0 = LowParse_SLow_BoundedInt_serialize32_bounded_integer_2(len11);
  FStar_Bytes_bytes res0 = FStar_Bytes_append(slen0, pl0);
  FStar_Bytes_bytes output11 = res0;
  FStar_Bytes_bytes fs2 = sn1.fst;
  FStar_Bytes_bytes sn2 = sn1.snd;
  FStar_Bytes_bytes x15 = fs2;
  FStar_Bytes_bytes x16 = x15;
  FStar_Bytes_bytes pl1 = x16;
  uint32_t len12 = FStar_Bytes_len(pl1);
  FStar_Bytes_bytes slen1 = LowParse_SLow_BoundedInt_serialize32_bounded_integer_2(len12);
  FStar_Bytes_bytes res1 = FStar_Bytes_append(slen1, pl1);
  FStar_Bytes_bytes output12 = res1;
  FStar_Bytes_bytes x1 = sn2;
  FStar_Bytes_bytes x17 = x1;
  FStar_Bytes_bytes pl2 = x17;
  uint32_t len1 = FStar_Bytes_len(pl2);
  FStar_Bytes_bytes slen2 = LowParse_SLow_BoundedInt_serialize32_bounded_integer_2(len1);
  FStar_Bytes_bytes res2 = FStar_Bytes_append(slen2, pl2);
  FStar_Bytes_bytes output2 = res2;
  FStar_Bytes_bytes output20 = FStar_Bytes_append(output12, output2);
  FStar_Bytes_bytes output21 = FStar_Bytes_append(output11, output20);
  FStar_Bytes_bytes r = FStar_Bytes_append(output1, output21);
  return r;
}

static FStar_Bytes_bytes
DHGroup_serialize_public(DHGroup_group g1, FStar_Bytes_bytes s, Prims_int l)
{
  Prims_int pad_len = Prims_op_Subtraction(l, FStar_UInt32_v(FStar_Bytes_len(s)));
  FStar_Bytes_bytes pad1 = FStar_Bytes_create(FStar_UInt32_uint_to_t(pad_len), (uint8_t)0U);
  return FStar_Bytes_append(pad1, s);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__DHGroup_group_FStar_Bytes_bytes_FStar_Bytes_bytes
TLSError_fatal__Prims_dtuple2_DHGroup_group_FStar_Bytes_bytes___FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__DHGroup_group_FStar_Bytes_bytes_FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

typedef struct
K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t_s
{
  K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes fst;
  uint32_t snd;
}
K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t;

typedef struct
FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t v;
}
FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t;

typedef struct
K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t_s
{
  K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes fst;
  uint32_t snd;
}
K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t;

typedef struct
FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t
  v;
}
FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t;

typedef struct K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t_s
{
  K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes fst;
  uint32_t snd;
}
K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t;

typedef struct
FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t v;
}
FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t;

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__DHGroup_group_FStar_Bytes_bytes_FStar_Bytes_bytes
DHGroup_parse_partial(FStar_Bytes_bytes bs)
{
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t
  scrut0 = LowParse_SLow_BoundedInt_parse32_bounded_integer_2(bs);
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut1;
  if (scrut0.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut0.v.snd;
    uint32_t v1 = scrut0.v.fst;
    if (!(v1 < (uint32_t)0U || (uint32_t)65535U < v1))
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v1, .snd = consumed }
          }
        );
    else
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
    scrut1 =
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut2;
  if (scrut1.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t l = scrut1.v.snd;
    uint32_t v1 = scrut1.v.fst;
    FStar_Bytes_bytes input_ = FStar_Bytes_slice(bs, l, FStar_Bytes_len(bs));
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
    if (FStar_Bytes_len(input_) < v1)
      scrut =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
    {
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t
      res =
        {
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .fst = FStar_Bytes_slice(input_, (uint32_t)0U, v1),
            .snd = FStar_Bytes_len(FStar_Bytes_slice(input_, (uint32_t)0U, v1))
          }
        };
      if (res.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = res.v.snd;
        FStar_Bytes_bytes v2 = res.v.fst;
        if (consumed == v1)
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v2, .snd = consumed }
              }
            );
        else
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
      else if (res.tag == FStar_Pervasives_Native_None)
        scrut =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else
        scrut =
          KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
    }
    if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t l_ = scrut.v.snd;
      FStar_Bytes_bytes v_ = scrut.v.fst;
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v_, .snd = l + l_ }
          }
        );
    }
    else
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
    scrut2 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t res0;
  if (scrut2.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut2.v.snd;
    FStar_Bytes_bytes x = scrut2.v.fst;
    res0 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = x, .snd = consumed }
        }
      );
  }
  else
    res0 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut3;
  if (res0.tag == FStar_Pervasives_Native_None)
    scrut3 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (res0.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = res0.v.snd;
    FStar_Bytes_bytes x = res0.v.fst;
    FStar_Bytes_bytes x1 = x;
    scrut3 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = x1, .snd = consumed }
        }
      );
  }
  else
    scrut3 =
      KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
        "unreachable (pattern matches are exhaustive in F*)");
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut4;
  if (scrut3.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut3.v.snd;
    FStar_Bytes_bytes v1 = scrut3.v.fst;
    scrut4 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = v1, .snd = consumed }
        }
      );
  }
  else
    scrut4 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut5;
  if (scrut4.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut4.v.snd;
    FStar_Bytes_bytes v1 = scrut4.v.fst;
    scrut5 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = v1, .snd = consumed }
        }
      );
  }
  else
    scrut5 =
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t
  scrut6;
  if (scrut5.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t l0 = scrut5.v.snd;
    FStar_Bytes_bytes v10 = scrut5.v.fst;
    FStar_Bytes_bytes input_ = FStar_Bytes_slice(bs, l0, FStar_Bytes_len(bs));
    FStar_Pervasives_Native_option__K___uint32_t_uint32_t
    scrut0 = LowParse_SLow_BoundedInt_parse32_bounded_integer_2(input_);
    FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut1;
    if (scrut0.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed = scrut0.v.snd;
      uint32_t v1 = scrut0.v.fst;
      if (!(v1 < (uint32_t)0U || (uint32_t)65535U < v1))
        scrut1 =
          (
            (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = v1, .snd = consumed }
            }
          );
      else
        scrut1 =
          (
            (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
    else
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut2;
    if (scrut1.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t l = scrut1.v.snd;
      uint32_t v1 = scrut1.v.fst;
      FStar_Bytes_bytes input_0 = FStar_Bytes_slice(input_, l, FStar_Bytes_len(input_));
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
      if (FStar_Bytes_len(input_0) < v1)
        scrut =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else
      {
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t
        res =
          {
            .tag = FStar_Pervasives_Native_Some,
            .v = {
              .fst = FStar_Bytes_slice(input_0, (uint32_t)0U, v1),
              .snd = FStar_Bytes_len(FStar_Bytes_slice(input_0, (uint32_t)0U, v1))
            }
          };
        if (res.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed = res.v.snd;
          FStar_Bytes_bytes v2 = res.v.fst;
          if (consumed == v1)
            scrut =
              (
                (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = v2, .snd = consumed }
                }
              );
          else
            scrut =
              (
                (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
        }
        else if (res.tag == FStar_Pervasives_Native_None)
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else
          scrut =
            KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
              "unreachable (pattern matches are exhaustive in F*)");
      }
      if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t l_ = scrut.v.snd;
        FStar_Bytes_bytes v_ = scrut.v.fst;
        scrut2 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = v_, .snd = l + l_ }
            }
          );
      }
      else
        scrut2 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
    else
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t res0;
    if (scrut2.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed = scrut2.v.snd;
      FStar_Bytes_bytes x = scrut2.v.fst;
      res0 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = x, .snd = consumed }
          }
        );
    }
    else
      res0 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut3;
    if (res0.tag == FStar_Pervasives_Native_None)
      scrut3 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (res0.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed = res0.v.snd;
      FStar_Bytes_bytes x = res0.v.fst;
      FStar_Bytes_bytes x1 = x;
      scrut3 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = x1, .snd = consumed }
          }
        );
    }
    else
      scrut3 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
          "unreachable (pattern matches are exhaustive in F*)");
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut4;
    if (scrut3.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed = scrut3.v.snd;
      FStar_Bytes_bytes v1 = scrut3.v.fst;
      scrut4 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v1, .snd = consumed }
          }
        );
    }
    else
      scrut4 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut5;
    if (scrut4.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t consumed = scrut4.v.snd;
      FStar_Bytes_bytes v1 = scrut4.v.fst;
      scrut5 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v1, .snd = consumed }
          }
        );
    }
    else
      scrut5 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t
    scrut7;
    if (scrut5.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t l1 = scrut5.v.snd;
      FStar_Bytes_bytes v20 = scrut5.v.fst;
      FStar_Bytes_bytes input_1 = FStar_Bytes_slice(input_, l1, FStar_Bytes_len(input_));
      FStar_Pervasives_Native_option__K___uint32_t_uint32_t
      scrut0 = LowParse_SLow_BoundedInt_parse32_bounded_integer_2(input_1);
      FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut1;
      if (scrut0.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = scrut0.v.snd;
        uint32_t v1 = scrut0.v.fst;
        if (!(v1 < (uint32_t)0U || (uint32_t)65535U < v1))
          scrut1 =
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v1, .snd = consumed }
              }
            );
        else
          scrut1 =
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
      else
        scrut1 =
          (
            (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut2;
      if (scrut1.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t l = scrut1.v.snd;
        uint32_t v1 = scrut1.v.fst;
        FStar_Bytes_bytes input_ = FStar_Bytes_slice(input_1, l, FStar_Bytes_len(input_1));
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
        if (FStar_Bytes_len(input_) < v1)
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else
        {
          FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t
          res =
            {
              .tag = FStar_Pervasives_Native_Some,
              .v = {
                .fst = FStar_Bytes_slice(input_, (uint32_t)0U, v1),
                .snd = FStar_Bytes_len(FStar_Bytes_slice(input_, (uint32_t)0U, v1))
              }
            };
          if (res.tag == FStar_Pervasives_Native_Some)
          {
            uint32_t consumed = res.v.snd;
            FStar_Bytes_bytes v2 = res.v.fst;
            if (consumed == v1)
              scrut =
                (
                  (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                    .tag = FStar_Pervasives_Native_Some,
                    .v = { .fst = v2, .snd = consumed }
                  }
                );
            else
              scrut =
                (
                  (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                    .tag = FStar_Pervasives_Native_None
                  }
                );
          }
          else if (res.tag == FStar_Pervasives_Native_None)
            scrut =
              (
                (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
          else
            scrut =
              KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
                "unreachable (pattern matches are exhaustive in F*)");
        }
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t l_ = scrut.v.snd;
          FStar_Bytes_bytes v_ = scrut.v.fst;
          scrut2 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v_, .snd = l + l_ }
              }
            );
        }
        else
          scrut2 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
      else
        scrut2 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t res0;
      if (scrut2.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = scrut2.v.snd;
        FStar_Bytes_bytes x = scrut2.v.fst;
        res0 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = x, .snd = consumed }
            }
          );
      }
      else
        res0 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut3;
      if (res0.tag == FStar_Pervasives_Native_None)
        scrut3 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (res0.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = res0.v.snd;
        FStar_Bytes_bytes x = res0.v.fst;
        FStar_Bytes_bytes x1 = x;
        scrut3 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = x1, .snd = consumed }
            }
          );
      }
      else
        scrut3 =
          KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut4;
      if (scrut3.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = scrut3.v.snd;
        FStar_Bytes_bytes v1 = scrut3.v.fst;
        scrut4 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = v1, .snd = consumed }
            }
          );
      }
      else
        scrut4 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut5;
      if (scrut4.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = scrut4.v.snd;
        FStar_Bytes_bytes v1 = scrut4.v.fst;
        scrut5 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = v1, .snd = consumed }
            }
          );
      }
      else
        scrut5 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t scrut6;
      if (scrut5.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t l2 = scrut5.v.snd;
        FStar_Bytes_bytes v3 = scrut5.v.fst;
        FStar_Bytes_bytes input_2 = FStar_Bytes_slice(input_1, l2, FStar_Bytes_len(input_1));
        FStar_Pervasives_Native_option__K___uint32_t_uint32_t
        scrut0 = LowParse_SLow_BoundedInt_parse32_bounded_integer_2(input_2);
        FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut1;
        if (scrut0.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed = scrut0.v.snd;
          uint32_t v1 = scrut0.v.fst;
          if (!(v1 < (uint32_t)0U || (uint32_t)65535U < v1))
            scrut1 =
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = v1, .snd = consumed }
                }
              );
          else
            scrut1 =
              (
                (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
        }
        else
          scrut1 =
            (
              (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut2;
        if (scrut1.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t l = scrut1.v.snd;
          uint32_t v1 = scrut1.v.fst;
          FStar_Bytes_bytes input_ = FStar_Bytes_slice(input_2, l, FStar_Bytes_len(input_2));
          FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
          if (FStar_Bytes_len(input_) < v1)
            scrut =
              (
                (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
          else
          {
            FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t
            res =
              {
                .tag = FStar_Pervasives_Native_Some,
                .v = {
                  .fst = FStar_Bytes_slice(input_, (uint32_t)0U, v1),
                  .snd = FStar_Bytes_len(FStar_Bytes_slice(input_, (uint32_t)0U, v1))
                }
              };
            if (res.tag == FStar_Pervasives_Native_Some)
            {
              uint32_t consumed = res.v.snd;
              FStar_Bytes_bytes v2 = res.v.fst;
              if (consumed == v1)
                scrut =
                  (
                    (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                      .tag = FStar_Pervasives_Native_Some,
                      .v = { .fst = v2, .snd = consumed }
                    }
                  );
              else
                scrut =
                  (
                    (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                      .tag = FStar_Pervasives_Native_None
                    }
                  );
            }
            else if (res.tag == FStar_Pervasives_Native_None)
              scrut =
                (
                  (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                    .tag = FStar_Pervasives_Native_None
                  }
                );
            else
              scrut =
                KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
                  "unreachable (pattern matches are exhaustive in F*)");
          }
          if (scrut.tag == FStar_Pervasives_Native_Some)
          {
            uint32_t l_ = scrut.v.snd;
            FStar_Bytes_bytes v_ = scrut.v.fst;
            scrut2 =
              (
                (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = v_, .snd = l + l_ }
                }
              );
          }
          else
            scrut2 =
              (
                (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Pervasives_Native_None
                }
              );
        }
        else
          scrut2 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t res;
        if (scrut2.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed = scrut2.v.snd;
          FStar_Bytes_bytes x = scrut2.v.fst;
          res =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = x, .snd = consumed }
              }
            );
        }
        else
          res =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut3;
        if (res.tag == FStar_Pervasives_Native_None)
          scrut3 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        else if (res.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed = res.v.snd;
          FStar_Bytes_bytes x = res.v.fst;
          FStar_Bytes_bytes x1 = x;
          scrut3 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = x1, .snd = consumed }
              }
            );
        }
        else
          scrut3 =
            KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t,
              "unreachable (pattern matches are exhaustive in F*)");
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut4;
        if (scrut3.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed = scrut3.v.snd;
          FStar_Bytes_bytes v1 = scrut3.v.fst;
          scrut4 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v1, .snd = consumed }
              }
            );
        }
        else
          scrut4 =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t scrut;
        if (scrut4.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t consumed = scrut4.v.snd;
          FStar_Bytes_bytes v1 = scrut4.v.fst;
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v1, .snd = consumed }
              }
            );
        }
        else
          scrut =
            (
              (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          uint32_t l_ = scrut.v.snd;
          FStar_Bytes_bytes v_ = scrut.v.fst;
          scrut6 =
            (
              (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = { .fst = v3, .snd = v_ }, .snd = l2 + l_ }
              }
            );
        }
        else
          scrut6 =
            (
              (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
      else
        scrut6 =
          (
            (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      if (scrut6.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t l_ = scrut6.v.snd;
        K___FStar_Bytes_bytes_FStar_Bytes_bytes v_ = scrut6.v.fst;
        scrut7 =
          (
            (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = { .fst = v20, .snd = v_ }, .snd = l1 + l_ }
            }
          );
      }
      else
        scrut7 =
          (
            (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
    else
      scrut7 =
        (
          (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    if (scrut7.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t l_ = scrut7.v.snd;
      K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes v_ = scrut7.v.fst;
      scrut6 =
        (
          (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = { .fst = v10, .snd = v_ }, .snd = l0 + l_ }
          }
        );
    }
    else
      scrut6 =
        (
          (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
    scrut6 =
      (
        (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t
  scrut;
  if (scrut6.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut6.v.snd;
    K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    v1 = scrut6.v.fst;
    FStar_Bytes_bytes d = v1.snd.snd.snd;
    FStar_Bytes_bytes c = v1.snd.snd.fst;
    FStar_Bytes_bytes b = v1.snd.fst;
    FStar_Bytes_bytes a = v1.fst;
    scrut =
      (
        (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = { .fst = a, .snd = b, .thd = c, .f3 = d }, .snd = consumed }
        }
      );
  }
  else
    scrut =
      (
        (FStar_Pervasives_Native_option__K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes rem1 = scrut.v.fst.f3;
    FStar_Bytes_bytes gy = scrut.v.fst.thd;
    FStar_Bytes_bytes g1 = scrut.v.fst.snd;
    FStar_Bytes_bytes p1 = scrut.v.fst.fst;
    if
    (
      Prims_op_LessThan((krml_checked_int_t)0,
        FStar_UInt32_v(FStar_Bytes_len(gy)))
      &&
        Prims_op_LessThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(gy)),
          FStar_UInt32_v(FStar_Bytes_len(p1)))
    )
    {
      DHGroup_params
      dhp =
        {
          .dh_p = p1,
          .dh_g = g1,
          .dh_q = { .tag = FStar_Pervasives_Native_None },
          .safe_prime = false
        };
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__DHGroup_group_FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .fst = {
                  .fst = { .tag = DHGroup_Explicit, .val = { .case_Explicit = dhp } },
                  .snd = gy
                },
                .snd = rem1
              }
            }
          }
        );
    }
    else
      return
        TLSError_fatal__Prims_dtuple2_DHGroup_group_FStar_Bytes_bytes___FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("DHGroup.fst", (krml_checked_int_t)241, ""));
  }
  else
    return
      TLSError_fatal__Prims_dtuple2_DHGroup_group_FStar_Bytes_bytes___FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("DHGroup.fst", (krml_checked_int_t)242, ""));
}

FStar_Bytes_bytes CommonDH_namedGroupBytes(Parsers_NamedGroup_namedGroup x)
{
  return Parsers_NamedGroup_namedGroup_serializer32(x);
}

FStar_Pervasives_Native_option__K___Parsers_NamedGroup_namedGroup_uint32_t
CommonDH_parseNamedGroup(FStar_Bytes_bytes x)
{
  return Parsers_NamedGroup_namedGroup_parser32(x);
}

FStar_Bytes_bytes CommonDH_namedGroupsBytes(Prims_list__Parsers_NamedGroup_namedGroup *x)
{
  return Parsers_NamedGroupList_namedGroupList_serializer32(x);
}

FStar_Pervasives_Native_option__K___Prims_list__Parsers_NamedGroup_namedGroup_uint32_t
CommonDH_parseNamedGroups(FStar_Bytes_bytes x)
{
  return Parsers_NamedGroupList_namedGroupList_parser32(x);
}

bool
FStar_List_Tot_Base_mem__Parsers_NamedGroup_namedGroup(
  Parsers_NamedGroup_namedGroup x,
  Prims_list__Parsers_NamedGroup_namedGroup *uu___7_953
)
{
  if (uu___7_953->tag == Prims_Nil)
    return false;
  else if (uu___7_953->tag == Prims_Cons)
  {
    Prims_list__Parsers_NamedGroup_namedGroup *tl1 = uu___7_953->tl;
    Parsers_NamedGroup_namedGroup hd1 = uu___7_953->hd;
    if (__eq__Parsers_NamedGroup_namedGroup(hd1, x))
      return true;
    else
      return FStar_List_Tot_Base_mem__Parsers_NamedGroup_namedGroup(x, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_is_supported_group(Parsers_NamedGroup_namedGroup x)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf[0U] = ((Prims_list__Parsers_NamedGroup_namedGroup){ .tag = Prims_Nil });
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf0[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe8192 },
        .tl = buf
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf1[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe6144 },
        .tl = buf0
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf2 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf2[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe4096 },
        .tl = buf1
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf3 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf3[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe3072 },
        .tl = buf2
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf4 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf4[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe2048 },
        .tl = buf3
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf5 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf5[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_X448 },
        .tl = buf4
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf6 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf6[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_X25519 },
        .tl = buf5
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf7 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf7[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Secp521r1 },
        .tl = buf6
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf8 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf8[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Secp384r1 },
        .tl = buf7
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf9 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf9[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Secp256r1 },
        .tl = buf8
      }
    );
  return FStar_List_Tot_Base_mem__Parsers_NamedGroup_namedGroup(x, buf9);
}

Prims_list__Parsers_NamedGroup_namedGroup
*CommonDH_as_supportedNamedGroups(Prims_list__Parsers_NamedGroup_namedGroup *xs)
{
  return xs;
}

static void CommonDH_discard(bool b)
{
  
}

static void CommonDH_print(Prims_string s)
{
  CommonDH_discard(FStar_IO_debug_print_string(Prims_strcat("CDH| ", Prims_strcat(s, "\n"))));
}

bool CommonDH_uu___is_FFDH(CommonDH_group_ projectee)
{
  if (projectee.tag == CommonDH_FFDH)
    return true;
  else
    return false;
}

DHGroup_group CommonDH___proj__FFDH__item___0(CommonDH_group_ projectee)
{
  if (projectee.tag == CommonDH_FFDH)
    return projectee.val.case_FFDH;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_uu___is_ECDH(CommonDH_group_ projectee)
{
  if (projectee.tag == CommonDH_ECDH)
    return true;
  else
    return false;
}

EverCrypt_ec_curve CommonDH___proj__ECDH__item___0(CommonDH_group_ projectee)
{
  if (projectee.tag == CommonDH_ECDH)
    return projectee.val.case_ECDH;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_is_ec(CommonDH_group_ g1)
{
  return CommonDH_uu___is_ECDH(g1);
}

Prims_string CommonDH_string_of_group(CommonDH_group_ uu___0_183)
{
  if (uu___0_183.tag == CommonDH_FFDH)
  {
    DHGroup_group g1 = uu___0_183.val.case_FFDH;
    if (g1.tag == DHGroup_Named && g1.val.case_Named == DHGroup_FFDHE2048)
      return "FFDHE2048";
    else if (g1.tag == DHGroup_Named && g1.val.case_Named == DHGroup_FFDHE3072)
      return "FFDHE3072";
    else if (g1.tag == DHGroup_Named && g1.val.case_Named == DHGroup_FFDHE4096)
      return "FFDHE4096";
    else if (g1.tag == DHGroup_Named && g1.val.case_Named == DHGroup_FFDHE6144)
      return "FFDHE6144";
    else if (g1.tag == DHGroup_Named && g1.val.case_Named == DHGroup_FFDHE8192)
      return "FFDHE8192";
    else if (g1.tag == DHGroup_Explicit)
      return "Explicit group";
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (uu___0_183.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve g1 = uu___0_183.val.case_ECDH;
    switch (g1)
    {
      case EverCrypt_ECC_P256:
        {
          return "P256";
        }
      case EverCrypt_ECC_P384:
        {
          return "P384";
        }
      case EverCrypt_ECC_P521:
        {
          return "P521";
        }
      case EverCrypt_ECC_X25519:
        {
          return "X255519";
        }
      case EverCrypt_ECC_X448:
        {
          return "X448";
        }
      default:
        {
          KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CommonDH_pre_share_ CommonDH_pre_pubshare(CommonDH_group_ g1, CommonDH_pre_keyshare_ ks)
{
  if (g1.tag == CommonDH_FFDH)
  {
    DHGroup_group dhg = g1.val.case_FFDH;
    if (ks.tag == CommonDH_KS_FF)
    {
      K___FStar_Bytes_bytes__EverCrypt__dh_state_ ks1 = ks.val.case_KS_FF._1;
      return
        (
          (CommonDH_pre_share_){
            .tag = CommonDH_S_FF,
            .val = { .case_S_FF = { .g = dhg, ._1 = DHGroup_pubshare(dhg, ks1) } }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (g1.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve ecg = g1.val.case_ECDH;
    if (ks.tag == CommonDH_KS_EC)
    {
      ECGroup_pre_keyshare ks1 = ks.val.case_KS_EC._1;
      return
        (
          (CommonDH_pre_share_){
            .tag = CommonDH_S_EC,
            .val = { .case_S_EC = { .g = ecg, ._1 = ECGroup_pubshare(ecg, ks1) } }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup
CommonDH_namedGroup_of_group(CommonDH_group_ g1)
{
  if (g1.tag == CommonDH_ECDH && g1.val.case_ECDH == EverCrypt_ECC_P256)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Secp256r1 }
        }
      );
  else if (g1.tag == CommonDH_ECDH && g1.val.case_ECDH == EverCrypt_ECC_P384)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Secp384r1 }
        }
      );
  else if (g1.tag == CommonDH_ECDH && g1.val.case_ECDH == EverCrypt_ECC_P521)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Secp521r1 }
        }
      );
  else if (g1.tag == CommonDH_ECDH && g1.val.case_ECDH == EverCrypt_ECC_X25519)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_X25519 }
        }
      );
  else if (g1.tag == CommonDH_ECDH && g1.val.case_ECDH == EverCrypt_ECC_X448)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_X448 }
        }
      );
  else if
  (
    g1.tag
    == CommonDH_FFDH
    &&
      g1.val.case_FFDH.tag
      == DHGroup_Named
      && g1.val.case_FFDH.val.case_Named == DHGroup_FFDHE2048
  )
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Ffdhe2048 }
        }
      );
  else if
  (
    g1.tag
    == CommonDH_FFDH
    &&
      g1.val.case_FFDH.tag
      == DHGroup_Named
      && g1.val.case_FFDH.val.case_Named == DHGroup_FFDHE3072
  )
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Ffdhe3072 }
        }
      );
  else if
  (
    g1.tag
    == CommonDH_FFDH
    &&
      g1.val.case_FFDH.tag
      == DHGroup_Named
      && g1.val.case_FFDH.val.case_Named == DHGroup_FFDHE4096
  )
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Ffdhe4096 }
        }
      );
  else if
  (
    g1.tag
    == CommonDH_FFDH
    &&
      g1.val.case_FFDH.tag
      == DHGroup_Named
      && g1.val.case_FFDH.val.case_Named == DHGroup_FFDHE6144
  )
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Ffdhe6144 }
        }
      );
  else if
  (
    g1.tag
    == CommonDH_FFDH
    &&
      g1.val.case_FFDH.tag
      == DHGroup_Named
      && g1.val.case_FFDH.val.case_Named == DHGroup_FFDHE8192
  )
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = Parsers_NamedGroup_Ffdhe8192 }
        }
      );
  else
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_None
        }
      );
}

FStar_Pervasives_Native_option__CommonDH_group_
CommonDH_group_of_namedGroup(Parsers_NamedGroup_namedGroup ng)
{
  if (ng.tag == Parsers_NamedGroup_Secp256r1)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = CommonDH_ECDH, .val = { .case_ECDH = EverCrypt_ECC_P256 } }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Secp384r1)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = CommonDH_ECDH, .val = { .case_ECDH = EverCrypt_ECC_P384 } }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Secp521r1)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = CommonDH_ECDH, .val = { .case_ECDH = EverCrypt_ECC_P521 } }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_X25519)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = CommonDH_ECDH, .val = { .case_ECDH = EverCrypt_ECC_X25519 } }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_X448)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .tag = CommonDH_ECDH, .val = { .case_ECDH = EverCrypt_ECC_X448 } }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Ffdhe2048)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .tag = CommonDH_FFDH,
            .val = {
              .case_FFDH = { .tag = DHGroup_Named, .val = { .case_Named = DHGroup_FFDHE2048 } }
            }
          }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Ffdhe3072)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .tag = CommonDH_FFDH,
            .val = {
              .case_FFDH = { .tag = DHGroup_Named, .val = { .case_Named = DHGroup_FFDHE3072 } }
            }
          }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Ffdhe4096)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .tag = CommonDH_FFDH,
            .val = {
              .case_FFDH = { .tag = DHGroup_Named, .val = { .case_Named = DHGroup_FFDHE4096 } }
            }
          }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Ffdhe6144)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .tag = CommonDH_FFDH,
            .val = {
              .case_FFDH = { .tag = DHGroup_Named, .val = { .case_Named = DHGroup_FFDHE6144 } }
            }
          }
        }
      );
  else if (ng.tag == Parsers_NamedGroup_Ffdhe8192)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_group_){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .tag = CommonDH_FFDH,
            .val = {
              .case_FFDH = { .tag = DHGroup_Named, .val = { .case_Named = DHGroup_FFDHE8192 } }
            }
          }
        }
      );
  else
    return
      ((FStar_Pervasives_Native_option__CommonDH_group_){ .tag = FStar_Pervasives_Native_None });
}

static bool CommonDH_is_ecdhe(Parsers_NamedGroup_namedGroup ng)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf[0U] = ((Prims_list__Parsers_NamedGroup_namedGroup){ .tag = Prims_Nil });
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf0[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_X448 },
        .tl = buf
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf1[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_X25519 },
        .tl = buf0
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf2 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf2[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Secp521r1 },
        .tl = buf1
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf3 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf3[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Secp384r1 },
        .tl = buf2
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf4 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf4[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Secp256r1 },
        .tl = buf3
      }
    );
  return FStar_List_Tot_Base_mem__Parsers_NamedGroup_namedGroup(ng, buf4);
}

static bool CommonDH_is_ffdhe(Parsers_NamedGroup_namedGroup ng)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf[0U] = ((Prims_list__Parsers_NamedGroup_namedGroup){ .tag = Prims_Nil });
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf0[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe8192 },
        .tl = buf
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf1[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe6144 },
        .tl = buf0
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf2 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf2[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe4096 },
        .tl = buf1
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf3 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf3[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe3072 },
        .tl = buf2
      }
    );
  KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
  Prims_list__Parsers_NamedGroup_namedGroup
  *buf4 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
  buf4[0U]
  =
    (
      (Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = Prims_Cons,
        .hd = { .tag = Parsers_NamedGroup_Ffdhe2048 },
        .tl = buf3
      }
    );
  return FStar_List_Tot_Base_mem__Parsers_NamedGroup_namedGroup(ng, buf4);
}

CommonDH_group_
CommonDH_default_group = { .tag = CommonDH_ECDH, .val = { .case_ECDH = EverCrypt_ECC_X25519 } };

bool
CommonDH_uu___is_Honest(
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ i1,
  CommonDH_ilog_entry projectee
)
{
  if (projectee.tag == CommonDH_Honest)
    return true;
  else
    return false;
}

Prims_list__Prims_dtuple2__CommonDH_pre_share__bool
**CommonDH___proj__Honest__item___0(
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ i1,
  CommonDH_ilog_entry projectee
)
{
  if (projectee.tag == CommonDH_Honest)
    return projectee._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
CommonDH_uu___is_Corrupt(
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ i1,
  CommonDH_ilog_entry projectee
)
{
  if (projectee.tag == CommonDH_Corrupt)
    return true;
  else
    return false;
}

bool CommonDH_is_honest_dhi(Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ i1)
{
  return false;
}

CommonDH_pre_share_ CommonDH_ipubshare(CommonDH_group_ g1, CommonDH_pre_keyshare_ gx)
{
  return CommonDH_pre_pubshare(g1, gx);
}

bool
CommonDH_is_honest_dhr(
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ i1,
  CommonDH_pre_share_ j1
)
{
  return false;
}

static CommonDH_pre_keyshare_ CommonDH_raw_keygen(CommonDH_group_ g1)
{
  if (g1.tag == CommonDH_FFDH)
  {
    DHGroup_group g2 = g1.val.case_FFDH;
    return
      (
        (CommonDH_pre_keyshare_){
          .tag = CommonDH_KS_FF,
          .val = { .case_KS_FF = { .g = g2, ._1 = DHGroup_keygen(g2) } }
        }
      );
  }
  else if (g1.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve g2 = g1.val.case_ECDH;
    return
      (
        (CommonDH_pre_keyshare_){
          .tag = CommonDH_KS_EC,
          .val = { .case_KS_EC = { .g = g2, ._1 = ECGroup_keygen(g2) } }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CommonDH_pre_keyshare_ CommonDH_keygen(CommonDH_group_ g1)
{
  CommonDH_print(Prims_strcat("Keygen (initiator) on ", CommonDH_string_of_group(g1)));
  CommonDH_pre_keyshare_ x = CommonDH_raw_keygen(g1);
  return x;
}

static FStar_Bytes_bytes
CommonDH_raw_dh_initiator(CommonDH_group_ g1, CommonDH_pre_keyshare_ x, CommonDH_pre_share_ gy)
{
  CommonDH_print(Prims_strcat("DH initiator on ", CommonDH_string_of_group(g1)));
  if (g1.tag == CommonDH_FFDH)
  {
    DHGroup_group g2 = g1.val.case_FFDH;
    if (x.tag == CommonDH_KS_FF)
    {
      K___FStar_Bytes_bytes__EverCrypt__dh_state_ x1 = x.val.case_KS_FF._1;
      if (gy.tag == CommonDH_S_FF)
      {
        FStar_Bytes_bytes gy1 = gy.val.case_S_FF._1;
        return DHGroup_dh_initiator(g2, x1, gy1);
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (g1.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve g2 = g1.val.case_ECDH;
    if (x.tag == CommonDH_KS_EC)
    {
      ECGroup_pre_keyshare x1 = x.val.case_KS_EC._1;
      if (gy.tag == CommonDH_S_EC)
      {
        ECGroup_pre_share gy1 = gy.val.case_S_EC._1;
        return ECGroup_dh_initiator(g2, x1, gy1);
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes
CommonDH_dh_initiator(CommonDH_group_ g1, CommonDH_pre_keyshare_ x, CommonDH_pre_share_ gy)
{
  return CommonDH_raw_dh_initiator(g1, x, gy);
}

K___CommonDH_pre_share__FStar_Bytes_bytes
CommonDH_dh_responder(CommonDH_group_ g1, CommonDH_pre_share_ gx)
{
  CommonDH_print(Prims_strcat("Keygen (responder) on ", CommonDH_string_of_group(g1)));
  CommonDH_pre_keyshare_ y = CommonDH_raw_keygen(g1);
  CommonDH_pre_share_ gy = CommonDH_pre_pubshare(g1, y);
  return
    (
      (K___CommonDH_pre_share__FStar_Bytes_bytes){
        .fst = gy,
        .snd = CommonDH_raw_dh_initiator(g1, y, gx)
      }
    );
}

CommonDH_pre_share_ CommonDH_register_dhi(CommonDH_group_ g1, CommonDH_pre_share_ gx)
{
  return gx;
}

CommonDH_pre_share_
CommonDH_register_dhr(CommonDH_group_ g1, CommonDH_pre_share_ gx, CommonDH_pre_share_ gy)
{
  return gy;
}

FStar_Pervasives_Native_option__CommonDH_pre_share_
CommonDH_parse(CommonDH_group_ g1, FStar_Bytes_bytes x)
{
  if (FStar_Bytes_len(x) == (uint32_t)0U)
    return
      ((FStar_Pervasives_Native_option__CommonDH_pre_share_){ .tag = FStar_Pervasives_Native_None });
  else if (g1.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve g2 = g1.val.case_ECDH;
    FStar_Pervasives_Native_option__ECGroup_pre_share scrut = ECGroup_parse_point(g2, x);
    if (scrut.tag == FStar_Pervasives_Native_None)
      return
        (
          (FStar_Pervasives_Native_option__CommonDH_pre_share_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      ECGroup_pre_share gx = scrut.v;
      return
        (
          (FStar_Pervasives_Native_option__CommonDH_pre_share_){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .tag = CommonDH_S_EC, .val = { .case_S_EC = { .g = g2, ._1 = gx } } }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (g1.tag == CommonDH_FFDH)
  {
    DHGroup_group g2 = g1.val.case_FFDH;
    DHGroup_params dhp = DHGroup_params_of_group(g2);
    if (FStar_UInt32_v(FStar_Bytes_len(x)) == FStar_UInt32_v(FStar_Bytes_len(dhp.dh_p)))
      return
        (
          (FStar_Pervasives_Native_option__CommonDH_pre_share_){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .tag = CommonDH_S_FF, .val = { .case_S_FF = { .g = g2, ._1 = x } } }
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__CommonDH_pre_share_){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes
CommonDH_parse_partial(bool ec, FStar_Bytes_bytes p1)
{
  if (ec)
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__EverCrypt_ec_curve_ECGroup_pre_share_FStar_Bytes_bytes
    scrut = ECGroup_parse_partial(p1);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes rem1 = scrut.val.case_Correct.snd;
      ECGroup_pre_share s = scrut.val.case_Correct.fst.snd;
      EverCrypt_ec_curve g1 = scrut.val.case_Correct.fst.fst;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .fst = {
                  .fst = { .tag = CommonDH_ECDH, .val = { .case_ECDH = g1 } },
                  .snd = { .tag = CommonDH_S_EC, .val = { .case_S_EC = { .g = g1, ._1 = s } } }
                },
                .snd = rem1
              }
            }
          }
        );
    }
    else if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__DHGroup_group_FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut = DHGroup_parse_partial(p1);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes rem1 = scrut.val.case_Correct.snd;
      FStar_Bytes_bytes s = scrut.val.case_Correct.fst.snd;
      DHGroup_group g1 = scrut.val.case_Correct.fst.fst;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .fst = {
                  .fst = { .tag = CommonDH_FFDH, .val = { .case_FFDH = g1 } },
                  .snd = { .tag = CommonDH_S_FF, .val = { .case_S_FF = { .g = g1, ._1 = s } } }
                },
                .snd = rem1
              }
            }
          }
        );
    }
    else if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Bytes_bytes CommonDH_serialize(CommonDH_group_ g1, CommonDH_pre_share_ s)
{
  if (g1.tag == CommonDH_FFDH)
  {
    DHGroup_group g2 = g1.val.case_FFDH;
    if (s.tag == CommonDH_S_FF)
    {
      FStar_Bytes_bytes s1 = s.val.case_S_FF._1;
      return DHGroup_serialize(g2, s1);
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (g1.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve g2 = g1.val.case_ECDH;
    if (s.tag == CommonDH_S_EC)
    {
      ECGroup_pre_share s1 = s.val.case_S_EC._1;
      return ECGroup_serialize(g2, s1);
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes CommonDH_serialize_raw(CommonDH_group_ g1, CommonDH_pre_share_ s)
{
  if (g1.tag == CommonDH_FFDH)
  {
    DHGroup_group g2 = g1.val.case_FFDH;
    if (s.tag == CommonDH_S_FF)
    {
      FStar_Bytes_bytes s1 = s.val.case_S_FF._1;
      DHGroup_params dhp = DHGroup_params_of_group(g2);
      return DHGroup_serialize_public(g2, s1, FStar_UInt32_v(FStar_Bytes_len(dhp.dh_p)));
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (g1.tag == CommonDH_ECDH)
  {
    EverCrypt_ec_curve g2 = g1.val.case_ECDH;
    if (s.tag == CommonDH_S_EC)
    {
      ECGroup_pre_share s1 = s.val.case_S_EC._1;
      return ECGroup_serialize_point(g2, s1);
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_uu___is_Share(CommonDH_keyShareEntry projectee)
{
  if (projectee.tag == CommonDH_Share)
    return true;
  else
    return false;
}

CommonDH_group_ CommonDH___proj__Share__item__g(CommonDH_keyShareEntry projectee)
{
  if (projectee.tag == CommonDH_Share)
    return projectee.val.case_Share.g;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CommonDH_pre_share_ CommonDH___proj__Share__item___1(CommonDH_keyShareEntry projectee)
{
  if (projectee.tag == CommonDH_Share)
    return projectee.val.case_Share._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_uu___is_UnknownShare(CommonDH_keyShareEntry projectee)
{
  if (projectee.tag == CommonDH_UnknownShare)
    return true;
  else
    return false;
}

Parsers_NamedGroup_namedGroup
CommonDH___proj__UnknownShare__item__ng(CommonDH_keyShareEntry projectee)
{
  if (projectee.tag == CommonDH_UnknownShare)
    return projectee.val.case_UnknownShare.ng;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes CommonDH___proj__UnknownShare__item__b(CommonDH_keyShareEntry projectee)
{
  if (projectee.tag == CommonDH_UnknownShare)
    return projectee.val.case_UnknownShare.b;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_uu___is_ClientKeyShare(CommonDH_keyShare projectee)
{
  if (projectee.tag == CommonDH_ClientKeyShare)
    return true;
  else
    return false;
}

Prims_list__CommonDH_keyShareEntry
*CommonDH___proj__ClientKeyShare__item___0(CommonDH_keyShare projectee)
{
  if (projectee.tag == CommonDH_ClientKeyShare)
    return projectee.val.case_ClientKeyShare;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_uu___is_ServerKeyShare(CommonDH_keyShare projectee)
{
  if (projectee.tag == CommonDH_ServerKeyShare)
    return true;
  else
    return false;
}

CommonDH_keyShareEntry CommonDH___proj__ServerKeyShare__item___0(CommonDH_keyShare projectee)
{
  if (projectee.tag == CommonDH_ServerKeyShare)
    return projectee.val.case_ServerKeyShare;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool CommonDH_uu___is_HRRKeyShare(CommonDH_keyShare projectee)
{
  if (projectee.tag == CommonDH_HRRKeyShare)
    return true;
  else
    return false;
}

Parsers_NamedGroup_namedGroup
CommonDH___proj__HRRKeyShare__item___0(CommonDH_keyShare projectee)
{
  if (projectee.tag == CommonDH_HRRKeyShare)
    return projectee.val.case_HRRKeyShare;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes CommonDH_keyShareEntryBytes(CommonDH_keyShareEntry k1)
{
  if (k1.tag == CommonDH_Share)
  {
    CommonDH_pre_share_ s = k1.val.case_Share._1;
    CommonDH_group_ g1 = k1.val.case_Share.g;
    FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup
    x0 = CommonDH_namedGroup_of_group(g1);
    Parsers_NamedGroup_namedGroup nng;
    if (x0.tag == FStar_Pervasives_Native_Some)
      nng = x0.v;
    else
      nng =
        KRML_EABORT(Parsers_NamedGroup_namedGroup,
          "unreachable (pattern matches are exhaustive in F*)");
    FStar_Bytes_bytes kex;
    if (s.tag == CommonDH_S_FF)
      kex = s.val.case_S_FF._1;
    else if (s.tag == CommonDH_S_EC)
    {
      ECGroup_pre_share x = s.val.case_S_EC._1;
      EverCrypt_ec_curve g2 = s.val.case_S_EC.g;
      kex = ECGroup_serialize_point(g2, x);
    }
    else
      kex = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
    Format_KeyShareEntry_keyShareEntry kse = { .group = nng, .key_exchange = kex };
    FStar_Bytes_bytes r = Format_KeyShareEntry_keyShareEntry_serializer32(kse);
    return r;
  }
  else if (k1.tag == CommonDH_UnknownShare)
  {
    FStar_Bytes_bytes b = k1.val.case_UnknownShare.b;
    Parsers_NamedGroup_namedGroup ng = k1.val.case_UnknownShare.ng;
    Format_KeyShareEntry_keyShareEntry kse = { .group = ng, .key_exchange = b };
    FStar_Bytes_bytes r = Format_KeyShareEntry_keyShareEntry_serializer32(kse);
    return r;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry
TLSError_fatal__CommonDH_keyShareEntry(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry
CommonDH_parseKeyShareEntry(FStar_Bytes_bytes b)
{
  FStar_Pervasives_Native_option__K___Format_KeyShareEntry_keyShareEntry_uint32_t
  (*prsr)(FStar_Bytes_bytes x0) = Format_KeyShareEntry_keyShareEntry_parser32;
  FStar_Pervasives_Native_option__K___Format_KeyShareEntry_keyShareEntry_uint32_t
  scrut0 = prsr(b);
  if (scrut0.tag == FStar_Pervasives_Native_Some)
  {
    Format_KeyShareEntry_keyShareEntry x = scrut0.v.fst;
    FStar_Pervasives_Native_option__CommonDH_group_ scrut0 = CommonDH_group_of_namedGroup(x.group);
    if (scrut0.tag == FStar_Pervasives_Native_Some)
    {
      CommonDH_group_ og = scrut0.v;
      if (CommonDH_is_ffdhe(x.group))
        if (og.tag == CommonDH_FFDH)
        {
          DHGroup_group dhg = og.val.case_FFDH;
          DHGroup_params dhp = DHGroup_params_of_group(dhg);
          if
          (
            FStar_UInt32_v(FStar_Bytes_len(x.key_exchange))
            != FStar_UInt32_v(FStar_Bytes_len(dhp.dh_p))
          )
            return
              TLSError_fatal__CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
                FStar_Error_perror("CommonDH.fst",
                  (krml_checked_int_t)689,
                  "Invalid key share entry"));
          else
          {
            FStar_Bytes_bytes q = x.key_exchange;
            CommonDH_pre_share_
            ps = { .tag = CommonDH_S_FF, .val = { .case_S_FF = { .g = dhg, ._1 = q } } };
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .tag = CommonDH_Share,
                      .val = { .case_Share = { .g = og, ._1 = ps } }
                    }
                  }
                }
              );
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      else if (CommonDH_is_ecdhe(x.group))
        if (og.tag == CommonDH_ECDH)
        {
          EverCrypt_ec_curve ecg = og.val.case_ECDH;
          FStar_Pervasives_Native_option__ECGroup_pre_share
          scrut = ECGroup_parse_point(ecg, x.key_exchange);
          if (scrut.tag == FStar_Pervasives_Native_Some)
          {
            ECGroup_pre_share q = scrut.v;
            ECGroup_pre_share q1 = q;
            CommonDH_pre_share_
            ps = { .tag = CommonDH_S_EC, .val = { .case_S_EC = { .g = ecg, ._1 = q1 } } };
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .tag = CommonDH_Share,
                      .val = { .case_Share = { .g = og, ._1 = ps } }
                    }
                  }
                }
              );
          }
          else
            return
              TLSError_fatal__CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
                FStar_Error_perror("CommonDH.fst",
                  (krml_checked_int_t)700,
                  "Failed to parse key share entry"));
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      else
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = CommonDH_UnknownShare,
                  .val = { .case_UnknownShare = { .ng = x.group, .b = x.key_exchange } }
                }
              }
            }
          );
    }
    else
      return
        TLSError_fatal__CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("CommonDH.fst",
            (krml_checked_int_t)703,
            "Failed to parse key share entry"));
  }
  else
    return
      TLSError_fatal__CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("CommonDH.fst",
          (krml_checked_int_t)704,
          "Failed to parse key share entry"));
}

/*
 Serializing function for a list of KeyShareEntry 
*/
static FStar_Bytes_bytes
CommonDH_keyShareEntriesBytes_aux(FStar_Bytes_bytes b, Prims_list__CommonDH_keyShareEntry *kes)
{
  if (kes->tag == Prims_Nil)
    return b;
  else if (kes->tag == Prims_Cons)
  {
    Prims_list__CommonDH_keyShareEntry *kes1 = kes->tl;
    CommonDH_keyShareEntry ke = kes->hd;
    FStar_Bytes_bytes kseb = CommonDH_keyShareEntryBytes(ke);
    if
    (
      Prims_op_LessThan(Prims_op_Addition(FStar_UInt32_v(FStar_Bytes_len(b)),
          FStar_UInt32_v(FStar_Bytes_len(kseb))),
        (krml_checked_int_t)65536)
    )
    {
      FStar_Bytes_bytes b_ = FStar_Bytes_append(b, kseb);
      return CommonDH_keyShareEntriesBytes_aux(b_, kes1);
    }
    else
      return b;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes CommonDH_keyShareEntriesBytes(Prims_list__CommonDH_keyShareEntry *es)
{
  FStar_Bytes_bytes b = CommonDH_keyShareEntriesBytes_aux(FStar_Bytes_empty_bytes, es);
  return Parse_vlbytes((krml_checked_int_t)2, b);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry
TLSError_fatal__Prims_list_CommonDH_keyShareEntry(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static Prims_list__CommonDH_keyShareEntry
*FStar_List_Tot_Base_append__CommonDH_keyShareEntry(
  Prims_list__CommonDH_keyShareEntry *x,
  Prims_list__CommonDH_keyShareEntry *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__CommonDH_keyShareEntry *tl1 = x->tl;
    CommonDH_keyShareEntry a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__CommonDH_keyShareEntry), (uint32_t)1U);
    Prims_list__CommonDH_keyShareEntry
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CommonDH_keyShareEntry));
    buf[0U]
    =
      (
        (Prims_list__CommonDH_keyShareEntry){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__CommonDH_keyShareEntry(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

/*
 Parsing function for a list KeyShareEntry 
*/
static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry
CommonDH_parseKeyShareEntries_aux(
  FStar_Bytes_bytes b,
  Prims_list__CommonDH_keyShareEntry *entries
)
{
  if (Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)0))
    if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)4))
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = FStar_Bytes_split(b, (uint32_t)2U);
      FStar_Bytes_bytes ng = scrut.fst;
      FStar_Bytes_bytes data = scrut.snd;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut0 = Parse_vlsplit((krml_checked_int_t)2, data);
      if (scrut0.tag == FStar_Error_Error)
        return
          TLSError_fatal__Prims_list_CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("CommonDH.fst",
              (krml_checked_int_t)733,
              "Failed to parse key share entry"));
      else if (scrut0.tag == FStar_Error_Correct)
      {
        FStar_Bytes_bytes bytes = scrut0.val.case_Correct.snd;
        FStar_Bytes_bytes kex = scrut0.val.case_Correct.fst;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry
        scrut =
          CommonDH_parseKeyShareEntry(FStar_Bytes_append(ng,
              Parse_vlbytes((krml_checked_int_t)2, kex)));
        if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else if (scrut.tag == FStar_Error_Correct)
        {
          CommonDH_keyShareEntry entry = scrut.val.case_Correct;
          KRML_CHECK_SIZE(sizeof (Prims_list__CommonDH_keyShareEntry), (uint32_t)1U);
          Prims_list__CommonDH_keyShareEntry
          *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CommonDH_keyShareEntry));
          buf[0U] = ((Prims_list__CommonDH_keyShareEntry){ .tag = Prims_Nil });
          KRML_CHECK_SIZE(sizeof (Prims_list__CommonDH_keyShareEntry), (uint32_t)1U);
          Prims_list__CommonDH_keyShareEntry
          *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__CommonDH_keyShareEntry));
          buf0[0U]
          = ((Prims_list__CommonDH_keyShareEntry){ .tag = Prims_Cons, .hd = entry, .tl = buf });
          return
            CommonDH_parseKeyShareEntries_aux(bytes,
              FStar_List_Tot_Base_append__CommonDH_keyShareEntry(entries, buf0));
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
      return
        TLSError_fatal__Prims_list_CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("CommonDH.fst",
            (krml_checked_int_t)738,
            "Too few bytes to parse key share entries"));
  else
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = entries }
        }
      );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry
CommonDH_parseKeyShareEntries(FStar_Bytes_bytes b)
{
  if (Prims_op_LessThanOrEqual((krml_checked_int_t)2, FStar_UInt32_v(FStar_Bytes_len(b))))
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)2, b);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes b1 = scrut.val.case_Correct;
      KRML_CHECK_SIZE(sizeof (Prims_list__CommonDH_keyShareEntry), (uint32_t)1U);
      Prims_list__CommonDH_keyShareEntry
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CommonDH_keyShareEntry));
      buf[0U] = ((Prims_list__CommonDH_keyShareEntry){ .tag = Prims_Nil });
      return CommonDH_parseKeyShareEntries_aux(b1, buf);
    }
    else if (scrut.tag == FStar_Error_Error)
      return
        TLSError_fatal__Prims_list_CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("CommonDH.fst",
            (krml_checked_int_t)745,
            "Failed to parse key share entries"));
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return
      TLSError_fatal__Prims_list_CommonDH_keyShareEntry(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("CommonDH.fst",
          (krml_checked_int_t)747,
          "Failed to parse key share entries"));
}

/*
 Serializing function for a ClientKeyShare 
*/
FStar_Bytes_bytes CommonDH_clientKeyShareBytes(Prims_list__CommonDH_keyShareEntry *cks)
{
  return CommonDH_keyShareEntriesBytes(cks);
}

static Prims_int
FStar_List_Tot_Base_length__CommonDH_keyShareEntry(
  Prims_list__CommonDH_keyShareEntry *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__CommonDH_keyShareEntry *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__CommonDH_keyShareEntry(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
TLSError_fatal__CommonDH_keyShare(Parsers_AlertDescription_alertDescription a, Prims_string s)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

/*
 Parsing function for a ClientKeyShare 
*/
FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
CommonDH_parseClientKeyShare(FStar_Bytes_bytes b)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__CommonDH_keyShareEntry
  scrut = CommonDH_parseKeyShareEntries(b);
  if (scrut.tag == FStar_Error_Correct)
  {
    Prims_list__CommonDH_keyShareEntry *kes = scrut.val.case_Correct;
    if
    (
      Prims_op_LessThan(FStar_List_Tot_Base_length__CommonDH_keyShareEntry(kes),
        (krml_checked_int_t)16384)
    )
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .tag = CommonDH_ClientKeyShare,
                .val = { .case_ClientKeyShare = kes }
              }
            }
          }
        );
    else
      return
        TLSError_fatal__CommonDH_keyShare(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("CommonDH.fst",
            (krml_checked_int_t)758,
            "Failed to parse client key share entries"));
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

/*
 Serializing function for a ServerKeyShare 
*/
FStar_Bytes_bytes CommonDH_serverKeyShareBytes(CommonDH_keyShareEntry sks)
{
  return CommonDH_keyShareEntryBytes(sks);
}

/*
 Parsing function for a ServerKeyShare 
*/
FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
CommonDH_parseServerKeyShare(FStar_Bytes_bytes b)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShareEntry
  scrut = CommonDH_parseKeyShareEntry(b);
  if (scrut.tag == FStar_Error_Correct)
  {
    CommonDH_keyShareEntry ks = scrut.val.case_Correct;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = CommonDH_ServerKeyShare, .val = { .case_ServerKeyShare = ks } }
          }
        }
      );
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes CommonDH_helloRetryKeyShareBytes(CommonDH_keyShare k1)
{
  if (k1.tag == CommonDH_HRRKeyShare)
  {
    Parsers_NamedGroup_namedGroup ng = k1.val.case_HRRKeyShare;
    return Parsers_NamedGroup_namedGroup_serializer32(ng);
  }
  else
    return FStar_Bytes_empty_bytes;
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
CommonDH_parseHelloRetryKeyShare(FStar_Bytes_bytes bs)
{
  FStar_Pervasives_Native_option__K___Parsers_NamedGroup_namedGroup_uint32_t
  scrut = Parsers_NamedGroup_namedGroup_parser32(bs);
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    Parsers_NamedGroup_namedGroup ng = scrut.v.fst;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = CommonDH_HRRKeyShare, .val = { .case_HRRKeyShare = ng } }
          }
        }
      );
  }
  else
    return
      TLSError_fatal__CommonDH_keyShare(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("CommonDH.fst",
          (krml_checked_int_t)778,
          "Failed to parse hello retry group"));
}

/*
 Serializing function for a KeyShare 
*/
FStar_Bytes_bytes CommonDH_keyShareBytes(CommonDH_keyShare uu___1_5240)
{
  if (uu___1_5240.tag == CommonDH_ClientKeyShare)
  {
    Prims_list__CommonDH_keyShareEntry *cks = uu___1_5240.val.case_ClientKeyShare;
    return CommonDH_clientKeyShareBytes(cks);
  }
  else if (uu___1_5240.tag == CommonDH_ServerKeyShare)
  {
    CommonDH_keyShareEntry sks = uu___1_5240.val.case_ServerKeyShare;
    return CommonDH_serverKeyShareBytes(sks);
  }
  else if (uu___1_5240.tag == CommonDH_HRRKeyShare)
  {
    Parsers_NamedGroup_namedGroup ng = uu___1_5240.val.case_HRRKeyShare;
    return CommonDH_namedGroupBytes(ng);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

