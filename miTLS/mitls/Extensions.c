/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "Extensions.h"

bool Extensions_uu___is_EM_ClientHello(Extensions_ext_msg projectee)
{
  switch (projectee)
  {
    case Extensions_EM_ClientHello:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Extensions_uu___is_EM_ServerHello(Extensions_ext_msg projectee)
{
  switch (projectee)
  {
    case Extensions_EM_ServerHello:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Extensions_uu___is_EM_EncryptedExtensions(Extensions_ext_msg projectee)
{
  switch (projectee)
  {
    case Extensions_EM_EncryptedExtensions:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Extensions_uu___is_EM_Certificate(Extensions_ext_msg projectee)
{
  switch (projectee)
  {
    case Extensions_EM_Certificate:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Extensions_uu___is_EM_NewSessionTicket(Extensions_ext_msg projectee)
{
  switch (projectee)
  {
    case Extensions_EM_NewSessionTicket:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Extensions_uu___is_EM_HelloRetryRequest(Extensions_ext_msg projectee)
{
  switch (projectee)
  {
    case Extensions_EM_HelloRetryRequest:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static FStar_Bytes_bytes Extensions_pskiBytes(K___FStar_Bytes_bytes_uint32_t uu____282)
{
  FStar_Bytes_bytes i1 = uu____282.fst;
  uint32_t ot = uu____282.snd;
  return FStar_Bytes_append(Parse_vlbytes2(i1), FStar_Bytes_bytes_of_int32(ot));
}

static FStar_Bytes_bytes
Extensions_pskiListBytes_aux(FStar_Bytes_bytes acc, K___FStar_Bytes_bytes_uint32_t pski)
{
  FStar_Bytes_bytes pb = Extensions_pskiBytes(pski);
  return FStar_Bytes_append(acc, pb);
}

static FStar_Bytes_bytes
FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_FStar_Bytes_bytes___uint32_t(
  FStar_Bytes_bytes (*f)(FStar_Bytes_bytes x0, K___FStar_Bytes_bytes_uint32_t x1),
  FStar_Bytes_bytes x,
  Prims_list__K___FStar_Bytes_bytes_uint32_t *l
)
{
  if (l->tag == Prims_Nil)
    return x;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_uint32_t *tl1 = l->tl;
    K___FStar_Bytes_bytes_uint32_t hd1 = l->hd;
    return
      FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_FStar_Bytes_bytes___uint32_t(f,
        f(x, hd1),
        tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes Extensions_pskiListBytes(Prims_list__K___FStar_Bytes_bytes_uint32_t *ids)
{
  return
    FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_FStar_Bytes_bytes___uint32_t(Extensions_pskiListBytes_aux,
      FStar_Bytes_empty_bytes,
      ids);
}

bool Extensions_uu___is_ClientPSK(Extensions_psk projectee)
{
  if (projectee.tag == Extensions_ClientPSK)
    return true;
  else
    return false;
}

Prims_list__K___FStar_Bytes_bytes_uint32_t
*Extensions___proj__ClientPSK__item__identities(Extensions_psk projectee)
{
  if (projectee.tag == Extensions_ClientPSK)
    return projectee.val.case_ClientPSK.identities;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_int Extensions___proj__ClientPSK__item__binders_len(Extensions_psk projectee)
{
  if (projectee.tag == Extensions_ClientPSK)
    return projectee.val.case_ClientPSK.binders_len;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Extensions_uu___is_ServerPSK(Extensions_psk projectee)
{
  if (projectee.tag == Extensions_ServerPSK)
    return true;
  else
    return false;
}

uint16_t Extensions___proj__ServerPSK__item___0(Extensions_psk projectee)
{
  if (projectee.tag == Extensions_ServerPSK)
    return projectee.val.case_ServerPSK;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes Extensions_binderListBytes_aux(Prims_list__FStar_Bytes_bytes *bl)
{
  if (bl->tag == Prims_Nil)
    return FStar_Bytes_empty_bytes;
  else if (bl->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *t = bl->tl;
    FStar_Bytes_bytes b = bl->hd;
    FStar_Bytes_bytes bt = Extensions_binderListBytes_aux(t);
    FStar_Bytes_bytes b0 = Parse_vlbytes1(b);
    FStar_Bytes_bytes bt1 = Extensions_binderListBytes_aux(t);
    return FStar_Bytes_append(b0, bt1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes Extensions_binderListBytes(Prims_list__FStar_Bytes_bytes *bs)
{
  if (bs->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *t = bs->tl;
    FStar_Bytes_bytes h1 = bs->hd;
    FStar_Bytes_bytes b = Extensions_binderListBytes_aux(t);
    FStar_Bytes_bytes b0 = Parse_vlbytes1(h1);
    return FStar_Bytes_append(b0, b);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes Extensions_bindersBytes(Prims_list__FStar_Bytes_bytes *bs)
{
  FStar_Bytes_bytes b = Extensions_binderListBytes(bs);
  return Parse_vlbytes2(b);
}

bool Extensions_uu___is_PSK_KE(Extensions_psk_kex projectee)
{
  switch (projectee)
  {
    case Extensions_PSK_KE:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Extensions_uu___is_PSK_DHE_KE(Extensions_psk_kex projectee)
{
  switch (projectee)
  {
    case Extensions_PSK_DHE_KE:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
TLSError_fatal__Prims_list_FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
Extensions_error__Prims_list_FStar_Bytes_bytes(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

Prims_list__FStar_Bytes_bytes
*FStar_List_Tot_Base_append__FStar_Bytes_bytes(
  Prims_list__FStar_Bytes_bytes *x,
  Prims_list__FStar_Bytes_bytes *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *tl1 = x->tl;
    FStar_Bytes_bytes a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf[0U]
    =
      (
        (Prims_list__FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__FStar_Bytes_bytes(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
Extensions_parseBinderList_aux(FStar_Bytes_bytes b, Prims_list__FStar_Bytes_bytes *binders)
{
  if (Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)0))
    if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)5))
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut = Parse_vlsplit((krml_checked_int_t)1, b);
      if (scrut.tag == FStar_Error_Error)
        return
          Extensions_error__Prims_list_FStar_Bytes_bytes("parseBinderList failed to parse a binder");
      else if (scrut.tag == FStar_Error_Correct)
      {
        K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut.val.case_Correct;
        FStar_Bytes_bytes binder = x.fst;
        FStar_Bytes_bytes bytes = x.snd;
        if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(binder)), (krml_checked_int_t)32))
          return
            Extensions_error__Prims_list_FStar_Bytes_bytes("parseBinderList: binder too short");
        else
        {
          KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
          Prims_list__FStar_Bytes_bytes
          *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
          buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
          KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
          Prims_list__FStar_Bytes_bytes
          *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
          buf0[0U]
          = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Cons, .hd = binder, .tl = buf });
          return
            Extensions_parseBinderList_aux(bytes,
              FStar_List_Tot_Base_append__FStar_Bytes_bytes(binders, buf0));
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
      return Extensions_error__Prims_list_FStar_Bytes_bytes("parseBinderList: too few bytes");
  else
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = binders }
        }
      );
}

Prims_int
FStar_List_Tot_Base_length__FStar_Bytes_bytes(Prims_list__FStar_Bytes_bytes *uu___4_154)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__FStar_Bytes_bytes(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
Extensions_parseBinderList(FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)2))
    return
      Extensions_error__Prims_list_FStar_Bytes_bytes("pskBinderList not enough bytes to read length header");
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)2, b);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes b1 = scrut.val.case_Correct;
      KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
      Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
      buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
      scrut = Extensions_parseBinderList_aux(b1, buf);
      if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__FStar_Bytes_bytes *bs = scrut.val.case_Correct;
        Prims_int len1 = FStar_List_Tot_Base_length__FStar_Bytes_bytes(bs);
        if
        (
          Prims_op_LessThan((krml_checked_int_t)0,
            len1)
          && Prims_op_LessThan(len1, (krml_checked_int_t)255)
        )
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Correct,
                .val = { .case_Correct = bs }
              }
            );
        else
          return Extensions_error__Prims_list_FStar_Bytes_bytes("none or too many binders");
      }
      else if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (scrut.tag == FStar_Error_Error)
      return Extensions_error__Prims_list_FStar_Bytes_bytes("parseBinderList");
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static FStar_Bytes_bytes Extensions_pskBytes(Extensions_psk uu___0_666)
{
  if (uu___0_666.tag == Extensions_ClientPSK)
  {
    Prims_list__K___FStar_Bytes_bytes_uint32_t *ids = uu___0_666.val.case_ClientPSK.identities;
    return Parse_vlbytes2(Extensions_pskiListBytes(ids));
  }
  else if (uu___0_666.tag == Extensions_ServerPSK)
  {
    uint16_t sid = uu___0_666.val.case_ServerPSK;
    return FStar_Bytes_bytes_of_int((krml_checked_int_t)2, FStar_UInt16_v(sid));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_uint32_t
TLSError_fatal__FStar_Bytes_bytes___uint32_t(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_uint32_t){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_uint32_t
Extensions_error__FStar_Bytes_bytes___uint32_t(Prims_string s)
{
  return
    TLSError_fatal__FStar_Bytes_bytes___uint32_t(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_uint32_t
Extensions_parsePskIdentity(FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)2))
    return
      Extensions_error__FStar_Bytes_bytes___uint32_t("not enough bytes to parse the length of the identity field of PskIdentity");
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut = Parse_vlsplit((krml_checked_int_t)2, b);
    if (scrut.tag == FStar_Error_Error)
      return Extensions_error__FStar_Bytes_bytes___uint32_t("malformed PskIdentity");
    else if (scrut.tag == FStar_Error_Correct)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut.val.case_Correct;
      FStar_Bytes_bytes id1 = x.fst;
      FStar_Bytes_bytes ota = x.snd;
      if (FStar_UInt32_v(FStar_Bytes_len(ota)) == (krml_checked_int_t)4)
      {
        uint32_t ota1 = Parse_uint32_of_bytes(ota);
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_uint32_t){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = { .fst = id1, .snd = ota1 } }
            }
          );
      }
      else
        return Extensions_error__FStar_Bytes_bytes___uint32_t("malformed PskIdentity");
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t
TLSError_fatal__Prims_list_FStar_Bytes_bytes___uint32_t(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t
Extensions_error__Prims_list_FStar_Bytes_bytes___uint32_t(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_FStar_Bytes_bytes___uint32_t(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static Prims_list__K___FStar_Bytes_bytes_uint32_t
*FStar_List_Tot_Base_append__FStar_Bytes_bytes___uint32_t(
  Prims_list__K___FStar_Bytes_bytes_uint32_t *x,
  Prims_list__K___FStar_Bytes_bytes_uint32_t *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_uint32_t *tl1 = x->tl;
    K___FStar_Bytes_bytes_uint32_t a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t), (uint32_t)1U);
    Prims_list__K___FStar_Bytes_bytes_uint32_t
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t));
    buf[0U]
    =
      (
        (Prims_list__K___FStar_Bytes_bytes_uint32_t){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__FStar_Bytes_bytes___uint32_t(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t
Extensions_parsePskIdentities_aux(
  FStar_Bytes_bytes b,
  Prims_list__K___FStar_Bytes_bytes_uint32_t *psks
)
{
  if (Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)0))
    if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)2))
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut0 = Parse_vlsplit((krml_checked_int_t)2, b);
      if (scrut0.tag == FStar_Error_Error)
        return
          Extensions_error__Prims_list_FStar_Bytes_bytes___uint32_t("parsePskIdentities failed to parse id");
      else if (scrut0.tag == FStar_Error_Correct)
      {
        K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut0.val.case_Correct;
        FStar_Bytes_bytes id1 = x.fst;
        FStar_Bytes_bytes bytes = x.snd;
        if
        (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(bytes)), (krml_checked_int_t)4))
        {
          K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(bytes, (uint32_t)4U);
          FStar_Bytes_bytes ot = scrut0.fst;
          FStar_Bytes_bytes bytes1 = scrut0.snd;
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_uint32_t
          scrut = Extensions_parsePskIdentity(FStar_Bytes_append(Parse_vlbytes2(id1), ot));
          if (scrut.tag == FStar_Error_Correct)
          {
            K___FStar_Bytes_bytes_uint32_t pski = scrut.val.case_Correct;
            KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t), (uint32_t)1U);
            Prims_list__K___FStar_Bytes_bytes_uint32_t
            *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t));
            buf[0U] = ((Prims_list__K___FStar_Bytes_bytes_uint32_t){ .tag = Prims_Nil });
            KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t), (uint32_t)1U);
            Prims_list__K___FStar_Bytes_bytes_uint32_t
            *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t));
            buf0[0U]
            =
              (
                (Prims_list__K___FStar_Bytes_bytes_uint32_t){
                  .tag = Prims_Cons,
                  .hd = pski,
                  .tl = buf
                }
              );
            return
              Extensions_parsePskIdentities_aux(bytes1,
                FStar_List_Tot_Base_append__FStar_Bytes_bytes___uint32_t(psks, buf0));
          }
          else if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
          return
            Extensions_error__Prims_list_FStar_Bytes_bytes___uint32_t("parsePSKIdentities too few bytes");
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
      return
        Extensions_error__Prims_list_FStar_Bytes_bytes___uint32_t("parsePSKIdentities too few bytes");
  else
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = psks }
        }
      );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t
Extensions_parsePskIdentities(FStar_Bytes_bytes b)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
  scrut = Parse_vlparse((krml_checked_int_t)2, b);
  if (scrut.tag == FStar_Error_Correct)
  {
    FStar_Bytes_bytes b1 = scrut.val.case_Correct;
    if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b1)), (krml_checked_int_t)7))
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t), (uint32_t)1U);
      Prims_list__K___FStar_Bytes_bytes_uint32_t
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t));
      buf[0U] = ((Prims_list__K___FStar_Bytes_bytes_uint32_t){ .tag = Prims_Nil });
      return Extensions_parsePskIdentities_aux(b1, buf);
    }
    else
      return
        Extensions_error__Prims_list_FStar_Bytes_bytes___uint32_t("parsePskIdentities: too short");
  }
  else if (scrut.tag == FStar_Error_Error)
    return
      Extensions_error__Prims_list_FStar_Bytes_bytes___uint32_t("parsePskIdentities: failed to parse");
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSError_fatal__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_error__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Prims_string s
)
{
  return
    TLSError_fatal__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_client_psk_parse(FStar_Bytes_bytes b)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
  scrut0 = Parse_vlsplit((krml_checked_int_t)2, b);
  if (scrut0.tag == FStar_Error_Error)
    return
      Extensions_error__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("client_psk_parse failed to parse");
  else if (scrut0.tag == FStar_Error_Correct)
  {
    FStar_Bytes_bytes binders_bytes = scrut0.val.case_Correct.snd;
    FStar_Bytes_bytes ids = scrut0.val.case_Correct.fst;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_uint32_t
    scrut0 = Extensions_parsePskIdentities(Parse_vlbytes2(ids));
    if (scrut0.tag == FStar_Error_Correct)
    {
      Prims_list__K___FStar_Bytes_bytes_uint32_t *ids1 = scrut0.val.case_Correct;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
      scrut = Extensions_parseBinderList(binders_bytes);
      if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__FStar_Bytes_bytes *bl = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .fst = {
                    .tag = Extensions_ClientPSK,
                    .val = {
                      .case_ClientPSK = {
                        .identities = ids1,
                        .binders_len = FStar_UInt32_v(FStar_Bytes_len(binders_bytes))
                      }
                    }
                  },
                  .snd = { .tag = FStar_Pervasives_Native_Some, .v = bl }
                }
              }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Error)
        return
          Extensions_error__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("client_psk_parse_binders");
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (scrut0.tag == FStar_Error_Error)
      return
        Extensions_error__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("client_psk_parse_ids");
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Extensions_psk Extensions_server_psk_parse(FStar_Bytes_bytes b)
{
  return
    (
      (Extensions_psk){
        .tag = Extensions_ServerPSK,
        .val = { .case_ServerPSK = FStar_UInt16_uint_to_t(FStar_Bytes_int_of_bytes(b)) }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_parse_psk(Extensions_ext_msg mt, FStar_Bytes_bytes b)
{
  switch (mt)
  {
    case Extensions_EM_ClientHello:
      {
        return Extensions_client_psk_parse(b);
      }
    case Extensions_EM_ServerHello:
      {
        if (FStar_UInt32_v(FStar_Bytes_len(b)) == (krml_checked_int_t)2)
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .fst = Extensions_server_psk_parse(b),
                    .snd = { .tag = FStar_Pervasives_Native_None }
                  }
                }
              }
            );
        else
          return
            Extensions_error__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("Invalid format of server PSK");
        break;
      }
    default:
      {
        return
          Extensions_error__Extensions_psk___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("PSK extension cannot appear in this message type");
      }
  }
}

static FStar_Bytes_bytes Extensions_psk_kex_bytes(Extensions_psk_kex uu___1_1043)
{
  switch (uu___1_1043)
  {
    case Extensions_PSK_KE:
      {
        return FStar_Bytes_abyte((uint8_t)0U);
      }
    case Extensions_PSK_DHE_KE:
      {
        return FStar_Bytes_abyte((uint8_t)1U);
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static FStar_Bytes_bytes
Extensions_client_psk_kexes_bytes(Prims_list__Extensions_psk_kex *ckxs)
{
  FStar_Bytes_bytes content;
  if (ckxs->tag == Prims_Cons && ckxs->tl->tag == Prims_Nil)
  {
    Extensions_psk_kex x = ckxs->hd;
    content = Extensions_psk_kex_bytes(x);
  }
  else if
  (ckxs->tag == Prims_Cons && ckxs->tl->tag == Prims_Cons && ckxs->tl->tl->tag == Prims_Nil)
  {
    Extensions_psk_kex y = ckxs->tl->hd;
    Extensions_psk_kex x = ckxs->hd;
    content = FStar_Bytes_append(Extensions_psk_kex_bytes(x), Extensions_psk_kex_bytes(y));
  }
  else
    content = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  return Parse_vlbytes((krml_checked_int_t)1, content);
}

bool Extensions_uu___is_ECP_UNCOMPRESSED(Extensions_point_format projectee)
{
  if (projectee.tag == Extensions_ECP_UNCOMPRESSED)
    return true;
  else
    return false;
}

bool Extensions_uu___is_ECP_UNKNOWN(Extensions_point_format projectee)
{
  if (projectee.tag == Extensions_ECP_UNKNOWN)
    return true;
  else
    return false;
}

Prims_int Extensions___proj__ECP_UNKNOWN__item___0(Extensions_point_format projectee)
{
  if (projectee.tag == Extensions_ECP_UNKNOWN)
    return projectee._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex
TLSError_fatal__Prims_list_Extensions_psk_kex(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex
Extensions_error__Prims_list_Extensions_psk_kex(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_Extensions_psk_kex(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex
Extensions_parse_client_psk_kexes(FStar_Bytes_bytes b)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
  Prims_list__Extensions_psk_kex
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
  buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
  KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
  Prims_list__Extensions_psk_kex
  *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
  buf0[0U]
  = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Cons, .hd = Extensions_PSK_KE, .tl = buf });
  if (__eq__FStar_Bytes_bytes(b, Extensions_client_psk_kexes_bytes(buf0)))
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
    Prims_list__Extensions_psk_kex
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
    buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
    Prims_list__Extensions_psk_kex
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
    buf0[0U]
    = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Cons, .hd = Extensions_PSK_KE, .tl = buf });
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = buf0 }
        }
      );
  }
  else
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
    Prims_list__Extensions_psk_kex
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
    buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
    Prims_list__Extensions_psk_kex
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
    buf0[0U]
    =
      (
        (Prims_list__Extensions_psk_kex){
          .tag = Prims_Cons,
          .hd = Extensions_PSK_DHE_KE,
          .tl = buf
        }
      );
    if (__eq__FStar_Bytes_bytes(b, Extensions_client_psk_kexes_bytes(buf0)))
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf0[0U]
      =
        (
          (Prims_list__Extensions_psk_kex){
            .tag = Prims_Cons,
            .hd = Extensions_PSK_DHE_KE,
            .tl = buf
          }
        );
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = buf0 }
          }
        );
    }
    else
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf0[0U]
      =
        (
          (Prims_list__Extensions_psk_kex){
            .tag = Prims_Cons,
            .hd = Extensions_PSK_DHE_KE,
            .tl = buf
          }
        );
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf1[0U]
      = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Cons, .hd = Extensions_PSK_KE, .tl = buf0 });
      if (__eq__FStar_Bytes_bytes(b, Extensions_client_psk_kexes_bytes(buf1)))
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf0[0U]
        =
          (
            (Prims_list__Extensions_psk_kex){
              .tag = Prims_Cons,
              .hd = Extensions_PSK_DHE_KE,
              .tl = buf
            }
          );
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf1[0U]
        =
          (
            (Prims_list__Extensions_psk_kex){
              .tag = Prims_Cons,
              .hd = Extensions_PSK_KE,
              .tl = buf0
            }
          );
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = buf1 }
            }
          );
      }
      else
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf0[0U]
        =
          (
            (Prims_list__Extensions_psk_kex){
              .tag = Prims_Cons,
              .hd = Extensions_PSK_KE,
              .tl = buf
            }
          );
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf1[0U]
        =
          (
            (Prims_list__Extensions_psk_kex){
              .tag = Prims_Cons,
              .hd = Extensions_PSK_DHE_KE,
              .tl = buf0
            }
          );
        if (__eq__FStar_Bytes_bytes(b, Extensions_client_psk_kexes_bytes(buf1)))
        {
          KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
          Prims_list__Extensions_psk_kex
          *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
          buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
          KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
          Prims_list__Extensions_psk_kex
          *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
          buf0[0U]
          =
            (
              (Prims_list__Extensions_psk_kex){
                .tag = Prims_Cons,
                .hd = Extensions_PSK_KE,
                .tl = buf
              }
            );
          KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
          Prims_list__Extensions_psk_kex
          *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
          buf1[0U]
          =
            (
              (Prims_list__Extensions_psk_kex){
                .tag = Prims_Cons,
                .hd = Extensions_PSK_DHE_KE,
                .tl = buf0
              }
            );
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex){
                .tag = FStar_Error_Correct,
                .val = { .case_Correct = buf1 }
              }
            );
        }
        else
          return Extensions_error__Prims_list_Extensions_psk_kex("PSK KEX payload");
      }
    }
  }
}

static FStar_Bytes_bytes
Extensions_earlyDataIndicationBytes(FStar_Pervasives_Native_option__uint32_t uu___2_1173)
{
  if (uu___2_1173.tag == FStar_Pervasives_Native_None)
    return FStar_Bytes_empty_bytes;
  else if (uu___2_1173.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t max_early_data_size = uu___2_1173.v;
    return FStar_Bytes_bytes_of_int32(max_early_data_size);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t
TLSError_fatal__FStar_Pervasives_Native_option_uint32_t(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t
Extensions_error__FStar_Pervasives_Native_option_uint32_t(Prims_string s)
{
  return
    TLSError_fatal__FStar_Pervasives_Native_option_uint32_t(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t
Extensions_parseEarlyDataIndication(FStar_Bytes_bytes data)
{
  Prims_int scrut = FStar_UInt32_v(FStar_Bytes_len(data));
  if (scrut == (krml_checked_int_t)0)
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = FStar_Pervasives_Native_None } }
        }
      );
  else if (scrut == (krml_checked_int_t)4)
  {
    Prims_int n1 = FStar_Bytes_int_of_bytes(data);
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = FStar_Pervasives_Native_Some, .v = FStar_UInt32_uint_to_t(n1) }
          }
        }
      );
  }
  else
    return Extensions_error__FStar_Pervasives_Native_option_uint32_t("early data indication");
}

static FStar_Bytes_bytes
Extensions_ecpfListBytes_aux(Prims_list__Extensions_point_format *uu___3_1217)
{
  if (uu___3_1217->tag == Prims_Nil)
    return FStar_Bytes_empty_bytes;
  else if (uu___3_1217->tag == Prims_Cons && uu___3_1217->hd.tag == Extensions_ECP_UNCOMPRESSED)
  {
    Prims_list__Extensions_point_format *r = uu___3_1217->tl;
    FStar_Bytes_bytes a = FStar_Bytes_abyte((uint8_t)0U);
    FStar_Bytes_bytes b = Extensions_ecpfListBytes_aux(r);
    return FStar_Bytes_append(a, b);
  }
  else if (uu___3_1217->tag == Prims_Cons && uu___3_1217->hd.tag == Extensions_ECP_UNKNOWN)
  {
    Prims_list__Extensions_point_format *r = uu___3_1217->tl;
    Prims_int t = uu___3_1217->hd._0;
    FStar_Bytes_bytes a = FStar_Bytes_bytes_of_int((krml_checked_int_t)1, t);
    FStar_Bytes_bytes b = Extensions_ecpfListBytes_aux(r);
    return FStar_Bytes_append(a, b);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes Extensions_ecpfListBytes(Prims_list__Extensions_point_format *l)
{
  FStar_Bytes_bytes al = Extensions_ecpfListBytes_aux(l);
  FStar_Bytes_bytes bl = Parse_vlbytes((krml_checked_int_t)1, al);
  return bl;
}

static FStar_Bytes_bytes Extensions_alpnBytes_aux(Prims_list__FStar_Bytes_bytes *uu___4_1271)
{
  if (uu___4_1271->tag == Prims_Nil)
    return FStar_Bytes_empty_bytes;
  else if (uu___4_1271->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *r = uu___4_1271->tl;
    FStar_Bytes_bytes protocol = uu___4_1271->hd;
    return
      FStar_Bytes_append(Parse_vlbytes((krml_checked_int_t)1, protocol),
        Extensions_alpnBytes_aux(r));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes Extensions_alpnBytes(Prims_list__FStar_Bytes_bytes *a)
{
  FStar_Bytes_bytes r = Extensions_alpnBytes_aux(a);
  return Parse_vlbytes((krml_checked_int_t)2, r);
}

bool Extensions_uu___is_ServerPV(Extensions_protocol_versions projectee)
{
  if (projectee.tag == Extensions_ServerPV)
    return true;
  else
    return false;
}

Parsers_ProtocolVersion_protocolVersion
Extensions___proj__ServerPV__item___0(Extensions_protocol_versions projectee)
{
  if (projectee.tag == Extensions_ServerPV)
    return projectee.val.case_ServerPV;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Extensions_uu___is_ClientPV(Extensions_protocol_versions projectee)
{
  if (projectee.tag == Extensions_ClientPV)
    return true;
  else
    return false;
}

Prims_list__Parsers_ProtocolVersion_protocolVersion
*Extensions___proj__ClientPV__item___0(Extensions_protocol_versions projectee)
{
  if (projectee.tag == Extensions_ClientPV)
    return projectee.val.case_ClientPV;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
Extensions_parseAlpn_aux(Prims_list__FStar_Bytes_bytes *al, FStar_Bytes_bytes b)
{
  if (FStar_UInt32_v(FStar_Bytes_len(b)) == (krml_checked_int_t)0)
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = al }
        }
      );
  else if
  (Prims_op_LessThan(FStar_List_Tot_Base_length__FStar_Bytes_bytes(al), (krml_checked_int_t)255))
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut = Parse_vlsplit((krml_checked_int_t)1, b);
    if (scrut.tag == FStar_Error_Correct)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut.val.case_Correct;
      FStar_Bytes_bytes cur = x.fst;
      FStar_Bytes_bytes r = x.snd;
      if (Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(cur)), (krml_checked_int_t)0))
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
        Prims_list__FStar_Bytes_bytes
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
        buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
        KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
        Prims_list__FStar_Bytes_bytes
        *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
        buf0[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Cons, .hd = cur, .tl = buf });
        return Extensions_parseAlpn_aux(FStar_List_Tot_Base_append__FStar_Bytes_bytes(al, buf0), r);
      }
      else
        return
          Extensions_error__Prims_list_FStar_Bytes_bytes("illegal empty protocol name in ALPN extension");
    }
    else if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return
      Extensions_error__Prims_list_FStar_Bytes_bytes("too many entries in protocol_name_list in ALPN extension");
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
Extensions_parseAlpn(FStar_Bytes_bytes b)
{
  if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)2))
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)2, b);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes l = scrut.val.case_Correct;
      KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
      Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
      buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
      return Extensions_parseAlpn_aux(buf, l);
    }
    else if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return Extensions_error__Prims_list_FStar_Bytes_bytes("parseAlpn: extension is too short");
}

static FStar_Bytes_bytes
Extensions_protocol_versions_bytes_aux(
  FStar_Bytes_bytes acc,
  Parsers_ProtocolVersion_protocolVersion v1
)
{
  return FStar_Bytes_append(acc, TLSConstants_versionBytes(v1));
}

static FStar_Bytes_bytes
FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_Parsers_ProtocolVersion_protocolVersion(
  FStar_Bytes_bytes (*f)(FStar_Bytes_bytes x0, Parsers_ProtocolVersion_protocolVersion x1),
  FStar_Bytes_bytes x,
  Prims_list__Parsers_ProtocolVersion_protocolVersion *l
)
{
  if (l->tag == Prims_Nil)
    return x;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Parsers_ProtocolVersion_protocolVersion *tl1 = l->tl;
    Parsers_ProtocolVersion_protocolVersion hd1 = l->hd;
    return
      FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_Parsers_ProtocolVersion_protocolVersion(f,
        f(x, hd1),
        tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes
Extensions_protocol_versions_bytes(Extensions_protocol_versions uu___5_3057)
{
  if (uu___5_3057.tag == Extensions_ServerPV)
  {
    Parsers_ProtocolVersion_protocolVersion pv = uu___5_3057.val.case_ServerPV;
    return TLSConstants_versionBytes(pv);
  }
  else if (uu___5_3057.tag == Extensions_ClientPV)
  {
    Prims_list__Parsers_ProtocolVersion_protocolVersion *vs = uu___5_3057.val.case_ClientPV;
    return
      Parse_vlbytes((krml_checked_int_t)1,
        FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_Parsers_ProtocolVersion_protocolVersion(Extensions_protocol_versions_bytes_aux,
          FStar_Bytes_empty_bytes,
          vs));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion
TLSError_fatal__Prims_list_Parsers_ProtocolVersion_protocolVersion(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion
Extensions_error__Prims_list_Parsers_ProtocolVersion_protocolVersion(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion
Extensions_parseVersions(FStar_Bytes_bytes b)
{
  Prims_int scrut0 = FStar_UInt32_v(FStar_Bytes_len(b));
  if (scrut0 == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
    Prims_list__Parsers_ProtocolVersion_protocolVersion
    *r = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
    r[0U] = ((Prims_list__Parsers_ProtocolVersion_protocolVersion){ .tag = Prims_Nil });
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = r }
        }
      );
  }
  else if (scrut0 == (krml_checked_int_t)1)
    return
      Extensions_error__Prims_list_Parsers_ProtocolVersion_protocolVersion("malformed version list");
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(b, (uint32_t)2U);
    FStar_Bytes_bytes b2 = scrut0.fst;
    FStar_Bytes_bytes b_ = scrut0.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
    scrut1 = TLSConstants_parseVersion(b2);
    if (scrut1.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut1.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut1.tag == FStar_Error_Correct)
    {
      Parsers_ProtocolVersion_protocolVersion v1 = scrut1.val.case_Correct;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion
      scrut = Extensions_parseVersions(b_);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__Parsers_ProtocolVersion_protocolVersion *vs = scrut.val.case_Correct;
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
        Prims_list__Parsers_ProtocolVersion_protocolVersion
        *r = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
        r[0U]
        =
          (
            (Prims_list__Parsers_ProtocolVersion_protocolVersion){
              .tag = Prims_Cons,
              .hd = v1,
              .tl = vs
            }
          );
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = r }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions
TLSError_fatal__Extensions_protocol_versions(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions
Extensions_error__Extensions_protocol_versions(Prims_string s)
{
  return
    TLSError_fatal__Extensions_protocol_versions(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static Prims_int
FStar_List_Tot_Base_length__Parsers_ProtocolVersion_protocolVersion(
  Prims_list__Parsers_ProtocolVersion_protocolVersion *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Parsers_ProtocolVersion_protocolVersion *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__Parsers_ProtocolVersion_protocolVersion(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions
Extensions_parseSupportedVersions(FStar_Bytes_bytes b)
{
  if (FStar_UInt32_v(FStar_Bytes_len(b)) == (krml_checked_int_t)2)
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
    scrut = TLSConstants_parseVersion(b);
    if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if
    (
      scrut.tag
      == FStar_Error_Correct
      && scrut.val.case_Correct.tag == Parsers_ProtocolVersion_Unknown_protocolVersion
    )
      return
        TLSError_fatal__Extensions_protocol_versions(Parsers_AlertDescription_Illegal_parameter,
          "server selected a version we don\'t support");
    else if (scrut.tag == FStar_Error_Correct)
    {
      Parsers_ProtocolVersion_protocolVersion pv = scrut.val.case_Correct;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = { .tag = Extensions_ServerPV, .val = { .case_ServerPV = pv } }
            }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)1, b);
    if (scrut.tag == FStar_Error_Error)
      return Extensions_error__Extensions_protocol_versions("protocol versions");
    else if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes b1 = scrut.val.case_Correct;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_ProtocolVersion_protocolVersion
      scrut = Extensions_parseVersions(b1);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__Parsers_ProtocolVersion_protocolVersion *vs = scrut.val.case_Correct;
        Prims_int n1 = FStar_List_Tot_Base_length__Parsers_ProtocolVersion_protocolVersion(vs);
        if
        (
          Prims_op_LessThanOrEqual((krml_checked_int_t)1,
            n1)
          && Prims_op_LessThanOrEqual(n1, (krml_checked_int_t)127)
        )
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = { .tag = Extensions_ClientPV, .val = { .case_ClientPV = vs } }
                }
              }
            );
        else
          return
            Extensions_error__Extensions_protocol_versions("too many or too few protocol versions");
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static FStar_Bytes_bytes
Extensions_serverNameBytes(Prims_list__TLSConstants_serverName *uu___6_3201)
{
  if (uu___6_3201->tag == Prims_Nil)
    return FStar_Bytes_empty_bytes;
  else if (uu___6_3201->tag == Prims_Cons && uu___6_3201->hd.tag == TLSConstants_SNI_DNS)
  {
    Prims_list__TLSConstants_serverName *r = uu___6_3201->tl;
    FStar_Bytes_bytes x = uu___6_3201->hd.val.case_SNI_DNS;
    return
      FStar_Bytes_append(FStar_Bytes_abyte((uint8_t)0U),
        FStar_Bytes_append(FStar_Bytes_bytes_of_int((krml_checked_int_t)2,
            FStar_UInt32_v(FStar_Bytes_len(x))),
          FStar_Bytes_append(x, Extensions_serverNameBytes(r))));
  }
  else if (uu___6_3201->tag == Prims_Cons && uu___6_3201->hd.tag == TLSConstants_SNI_UNKNOWN)
  {
    Prims_list__TLSConstants_serverName *r = uu___6_3201->tl;
    FStar_Bytes_bytes x = uu___6_3201->hd.val.case_SNI_UNKNOWN.snd;
    Prims_int t = uu___6_3201->hd.val.case_SNI_UNKNOWN.fst;
    return
      FStar_Bytes_append(FStar_Bytes_bytes_of_int((krml_checked_int_t)1, t),
        FStar_Bytes_append(FStar_Bytes_bytes_of_int((krml_checked_int_t)2,
            FStar_UInt32_v(FStar_Bytes_len(x))),
          FStar_Bytes_append(x, Extensions_serverNameBytes(r))));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct K___TLSConstants_serverName_TLSConstants_serverName_s
{
  TLSConstants_serverName fst;
  TLSConstants_serverName snd;
}
K___TLSConstants_serverName_TLSConstants_serverName;

static bool Extensions_snidup(TLSConstants_serverName cur, TLSConstants_serverName x)
{
  K___TLSConstants_serverName_TLSConstants_serverName scrut = { .fst = x, .snd = cur };
  if (scrut.fst.tag == TLSConstants_SNI_DNS && scrut.snd.tag == TLSConstants_SNI_DNS)
    return true;
  else if
  (scrut.fst.tag == TLSConstants_SNI_UNKNOWN && scrut.snd.tag == TLSConstants_SNI_UNKNOWN)
  {
    Prims_int b = scrut.snd.val.case_SNI_UNKNOWN.fst;
    Prims_int a = scrut.fst.val.case_SNI_UNKNOWN.fst;
    return a == b;
  }
  else
    return false;
}

static bool
Extensions_existsb2__TLSConstants_serverName_TLSConstants_serverName(
  bool (*f)(TLSConstants_serverName x0, TLSConstants_serverName x1),
  TLSConstants_serverName x,
  Prims_list__TLSConstants_serverName *y
)
{
  if (y->tag == Prims_Nil)
    return false;
  else if (y->tag == Prims_Cons)
  {
    Prims_list__TLSConstants_serverName *tl1 = y->tl;
    TLSConstants_serverName hd1 = y->hd;
    return
      f(x,
        hd1)
      || Extensions_existsb2__TLSConstants_serverName_TLSConstants_serverName(f, x, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

#define Extensions_ExFail 0
#define Extensions_ExOK 1

typedef uint8_t Extensions_canFail__TLSConstants_serverName_tags;

typedef struct Extensions_canFail__TLSConstants_serverName_s
{
  Extensions_canFail__TLSConstants_serverName_tags tag;
  union {
    K___Parsers_Alert_alert_Prims_string case_ExFail;
    Prims_list__TLSConstants_serverName *case_ExOK;
  }
  val;
}
Extensions_canFail__TLSConstants_serverName;

static Extensions_canFail__TLSConstants_serverName
Extensions_parseServerName_aux(FStar_Bytes_bytes b)
{
  if (__eq__FStar_Bytes_bytes(b, FStar_Bytes_empty_bytes))
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
    Prims_list__TLSConstants_serverName
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
    buf[0U] = ((Prims_list__TLSConstants_serverName){ .tag = Prims_Nil });
    return
      (
        (Extensions_canFail__TLSConstants_serverName){
          .tag = Extensions_ExOK,
          .val = { .case_ExOK = buf }
        }
      );
  }
  else if
  (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)3))
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(b, (uint32_t)1U);
    FStar_Bytes_bytes ty = scrut0.fst;
    FStar_Bytes_bytes v1 = scrut0.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut1 = Parse_vlsplit((krml_checked_int_t)2, v1);
    if (scrut1.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string q = scrut1.val.case_Error;
      Parsers_Alert_alert x = q.fst;
      return
        (
          (Extensions_canFail__TLSConstants_serverName){
            .tag = Extensions_ExFail,
            .val = {
              .case_ExFail = {
                .fst = x,
                .snd = Prims_strcat("Failed to parse SNI length: ", FStar_Bytes_print_bytes(b))
              }
            }
          }
        );
    }
    else if (scrut1.tag == FStar_Error_Correct)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut1.val.case_Correct;
      FStar_Bytes_bytes cur = x.fst;
      FStar_Bytes_bytes next = x.snd;
      Extensions_canFail__TLSConstants_serverName scrut0 = Extensions_parseServerName_aux(next);
      if (scrut0.tag == Extensions_ExFail)
      {
        Prims_string y = scrut0.val.case_ExFail.snd;
        Parsers_Alert_alert x1 = scrut0.val.case_ExFail.fst;
        return
          (
            (Extensions_canFail__TLSConstants_serverName){
              .tag = Extensions_ExFail,
              .val = { .case_ExFail = { .fst = x1, .snd = y } }
            }
          );
      }
      else if (scrut0.tag == Extensions_ExOK)
      {
        Prims_list__TLSConstants_serverName *l = scrut0.val.case_ExOK;
        uint8_t scrut = FStar_Bytes_get(ty, (uint32_t)0U);
        TLSConstants_serverName cur1;
        if (scrut == (uint8_t)0U)
          cur1 =
            (
              (TLSConstants_serverName){
                .tag = TLSConstants_SNI_DNS,
                .val = { .case_SNI_DNS = cur }
              }
            );
        else
          cur1 =
            (
              (TLSConstants_serverName){
                .tag = TLSConstants_SNI_UNKNOWN,
                .val = { .case_SNI_UNKNOWN = { .fst = FStar_Bytes_int_of_bytes(ty), .snd = cur } }
              }
            );
        if
        (
          Extensions_existsb2__TLSConstants_serverName_TLSConstants_serverName(Extensions_snidup,
            cur1,
            l)
        )
          return
            (
              (Extensions_canFail__TLSConstants_serverName){
                .tag = Extensions_ExFail,
                .val = {
                  .case_ExFail = {
                    .fst = TLSError_fatalAlert(Parsers_AlertDescription_Unrecognized_name),
                    .snd = FStar_Error_perror("Extensions.fst",
                      (krml_checked_int_t)426,
                      "Duplicate SNI type")
                  }
                }
              }
            );
        else
        {
          KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
          Prims_list__TLSConstants_serverName
          *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
          buf[0U]
          = ((Prims_list__TLSConstants_serverName){ .tag = Prims_Cons, .hd = cur1, .tl = l });
          return
            (
              (Extensions_canFail__TLSConstants_serverName){
                .tag = Extensions_ExOK,
                .val = { .case_ExOK = buf }
              }
            );
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return
      (
        (Extensions_canFail__TLSConstants_serverName){
          .tag = Extensions_ExFail,
          .val = {
            .case_ExFail = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = "Failed to parse SNI (list header)"
            }
          }
        }
      );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName
FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_TLSConstants_serverName(
  Prims_list__TLSConstants_serverName *x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName
TLSError_fatal__Prims_list_TLSConstants_serverName(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName
Extensions_error__Prims_list_TLSConstants_serverName(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_TLSConstants_serverName(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName
Extensions_parseServerName(Extensions_ext_msg mt, FStar_Bytes_bytes b)
{
  switch (mt)
  {
    case Extensions_EM_EncryptedExtensions:
      {
        if (FStar_UInt32_v(FStar_Bytes_len(b)) == (krml_checked_int_t)0)
        {
          KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
          Prims_list__TLSConstants_serverName
          *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
          buf[0U] = ((Prims_list__TLSConstants_serverName){ .tag = Prims_Nil });
          return
            FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_TLSConstants_serverName(buf);
        }
        else
        {
          Prims_string
          msg =
            Prims_strcat("Failed to parse SNI list: should be empty in ServerHello, has size ",
              Prims_string_of_int(FStar_UInt32_v(FStar_Bytes_len(b))));
          return
            Extensions_error__Prims_list_TLSConstants_serverName(FStar_Error_perror("Extensions.fst",
                (krml_checked_int_t)440,
                msg));
        }
        break;
      }
    case Extensions_EM_ServerHello:
      {
        if (FStar_UInt32_v(FStar_Bytes_len(b)) == (krml_checked_int_t)0)
        {
          KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
          Prims_list__TLSConstants_serverName
          *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
          buf[0U] = ((Prims_list__TLSConstants_serverName){ .tag = Prims_Nil });
          return
            FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_TLSConstants_serverName(buf);
        }
        else
        {
          Prims_string
          msg =
            Prims_strcat("Failed to parse SNI list: should be empty in ServerHello, has size ",
              Prims_string_of_int(FStar_UInt32_v(FStar_Bytes_len(b))));
          return
            Extensions_error__Prims_list_TLSConstants_serverName(FStar_Error_perror("Extensions.fst",
                (krml_checked_int_t)440,
                msg));
        }
        break;
      }
    case Extensions_EM_ClientHello:
      {
        if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)2))
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
          scrut = Parse_vlparse((krml_checked_int_t)2, b);
          if (scrut.tag == FStar_Error_Error)
            return
              Extensions_error__Prims_list_TLSConstants_serverName(FStar_Error_perror("Extensions.fst",
                  (krml_checked_int_t)445,
                  "Failed to parse SNI list"));
          else if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Bytes_bytes b1 = scrut.val.case_Correct;
            Extensions_canFail__TLSConstants_serverName scrut = Extensions_parseServerName_aux(b1);
            if (scrut.tag == Extensions_ExFail)
            {
              Prims_string y = scrut.val.case_ExFail.snd;
              Parsers_Alert_alert x = scrut.val.case_ExFail.fst;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName){
                    .tag = FStar_Error_Error,
                    .val = { .case_Error = { .fst = x, .snd = y } }
                  }
                );
            }
            else if (scrut.tag == Extensions_ExOK && scrut.val.case_ExOK->tag == Prims_Nil)
              return
                TLSError_fatal__Prims_list_TLSConstants_serverName(Parsers_AlertDescription_Unrecognized_name,
                  FStar_Error_perror("Extensions.fst",
                    (krml_checked_int_t)449,
                    "Empty SNI extension"));
            else if (scrut.tag == Extensions_ExOK)
            {
              Prims_list__TLSConstants_serverName *l = scrut.val.case_ExOK;
              return
                FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_TLSConstants_serverName(l);
            }
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
          return
            Extensions_error__Prims_list_TLSConstants_serverName(FStar_Error_perror("Extensions.fst",
                (krml_checked_int_t)453,
                "Failed to parse SNI list"));
        break;
      }
    default:
      {
        return
          Extensions_error__Prims_list_TLSConstants_serverName("SNI extension cannot appear in this message type");
      }
  }
}

bool __neq__FStar_Bytes_bytes(FStar_Bytes_bytes y, FStar_Bytes_bytes x)
{
  return !__eq__FStar_Bytes_bytes(x, y);
}

bool Extensions_is_unknown(FStar_Bytes_bytes x)
{
  return
    __neq__FStar_Bytes_bytes(x,
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x00U })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x0AU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x0DU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)50U })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x1AU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x23U })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)51U })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x29U })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2aU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2bU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2cU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2dU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x17U })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x0BU })))
    &&
      __neq__FStar_Bytes_bytes(x,
        FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x10U })));
}

static Prims_list__Extensions_extension_
*Extensions_ext_of_custom_aux(
  Prims_list__Extensions_extension_ *acc,
  Prims_list__K___uint16_t_FStar_Bytes_bytes *uu___7_4480
)
{
  if (uu___7_4480->tag == Prims_Nil)
    return acc;
  else if (uu___7_4480->tag == Prims_Cons)
  {
    Prims_list__K___uint16_t_FStar_Bytes_bytes *t = uu___7_4480->tl;
    FStar_Bytes_bytes b = uu___7_4480->hd.snd;
    uint16_t h1 = uu___7_4480->hd.fst;
    FStar_Bytes_bytes bh = Parse_bytes_of_uint16(h1);
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = {
            .tag = Extensions_E_unknown_extension,
            .val = { .case_E_unknown_extension = { .x = bh, ._1 = b } }
          },
          .tl = acc
        }
      );
    return Extensions_ext_of_custom_aux(buf, t);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Extensions_extension_
*FStar_List_Tot_Base_rev_acc__Extensions_extension_(
  Prims_list__Extensions_extension_ *l,
  Prims_list__Extensions_extension_ *acc
)
{
  if (l->tag == Prims_Nil)
    return acc;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = l->tl;
    Extensions_extension_ hd1 = l->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Cons, .hd = hd1, .tl = acc });
    return FStar_List_Tot_Base_rev_acc__Extensions_extension_(tl1, buf);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Extensions_extension_
*FStar_List_Tot_Base_rev__Extensions_extension_(Prims_list__Extensions_extension_ *l)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
  Prims_list__Extensions_extension_
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
  buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
  return FStar_List_Tot_Base_rev_acc__Extensions_extension_(l, buf);
}

Prims_list__Extensions_extension_
*Extensions_ext_of_custom(Prims_list__K___uint16_t_FStar_Bytes_bytes *el)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
  Prims_list__Extensions_extension_
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
  buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
  return FStar_List_Tot_Base_rev__Extensions_extension_(Extensions_ext_of_custom_aux(buf, el));
}

static Prims_list__K___uint16_t_FStar_Bytes_bytes
*Extensions_custom_of_ext_aux(
  Prims_list__K___uint16_t_FStar_Bytes_bytes *acc,
  Prims_list__Extensions_extension_ *uu___8_4531
)
{
  if (uu___8_4531->tag == Prims_Nil)
    return acc;
  else if
  (uu___8_4531->tag == Prims_Cons && uu___8_4531->hd.tag == Extensions_E_unknown_extension)
  {
    Prims_list__Extensions_extension_ *t = uu___8_4531->tl;
    FStar_Bytes_bytes b = uu___8_4531->hd.val.case_E_unknown_extension._1;
    FStar_Bytes_bytes hd1 = uu___8_4531->hd.val.case_E_unknown_extension.x;
    KRML_CHECK_SIZE(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__K___uint16_t_FStar_Bytes_bytes
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes));
    buf[0U]
    =
      (
        (Prims_list__K___uint16_t_FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = { .fst = Parse_uint16_of_bytes(hd1), .snd = b },
          .tl = acc
        }
      );
    return Extensions_custom_of_ext_aux(buf, t);
  }
  else if (uu___8_4531->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *t = uu___8_4531->tl;
    return Extensions_custom_of_ext_aux(acc, t);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__K___uint16_t_FStar_Bytes_bytes
*FStar_List_Tot_Base_rev_acc__uint16_t___FStar_Bytes_bytes(
  Prims_list__K___uint16_t_FStar_Bytes_bytes *l,
  Prims_list__K___uint16_t_FStar_Bytes_bytes *acc
)
{
  if (l->tag == Prims_Nil)
    return acc;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___uint16_t_FStar_Bytes_bytes *tl1 = l->tl;
    K___uint16_t_FStar_Bytes_bytes hd1 = l->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__K___uint16_t_FStar_Bytes_bytes
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes));
    buf[0U]
    = ((Prims_list__K___uint16_t_FStar_Bytes_bytes){ .tag = Prims_Cons, .hd = hd1, .tl = acc });
    return FStar_List_Tot_Base_rev_acc__uint16_t___FStar_Bytes_bytes(tl1, buf);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__K___uint16_t_FStar_Bytes_bytes
*FStar_List_Tot_Base_rev__uint16_t___FStar_Bytes_bytes(
  Prims_list__K___uint16_t_FStar_Bytes_bytes *l
)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__K___uint16_t_FStar_Bytes_bytes
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes));
  buf[0U] = ((Prims_list__K___uint16_t_FStar_Bytes_bytes){ .tag = Prims_Nil });
  return FStar_List_Tot_Base_rev_acc__uint16_t___FStar_Bytes_bytes(l, buf);
}

Prims_list__K___uint16_t_FStar_Bytes_bytes
*Extensions_custom_of_ext(Prims_list__Extensions_extension_ *el)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__K___uint16_t_FStar_Bytes_bytes
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes));
  buf[0U] = ((Prims_list__K___uint16_t_FStar_Bytes_bytes){ .tag = Prims_Nil });
  return
    FStar_List_Tot_Base_rev__uint16_t___FStar_Bytes_bytes(Extensions_custom_of_ext_aux(buf, el));
}

static bool Extensions_app_filter(Extensions_extension_ e)
{
  if (e.tag == Extensions_E_server_name)
    return true;
  else if (e.tag == Extensions_E_signature_algorithms)
    return true;
  else if (e.tag == Extensions_E_signature_algorithms_cert)
    return true;
  else if (e.tag == Extensions_E_alpn)
    return true;
  else if (e.tag == Extensions_E_supported_groups)
    return true;
  else if (e.tag == Extensions_E_unknown_extension)
    return true;
  else
    return false;
}

Prims_list__Extensions_extension_
*FStar_List_Tot_Base_filter__Extensions_extension_(
  bool (*f)(Extensions_extension_ x0),
  Prims_list__Extensions_extension_ *uu___8_1135
)
{
  if (uu___8_1135->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
    return buf;
  }
  else if (uu___8_1135->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = uu___8_1135->tl;
    Extensions_extension_ hd1 = uu___8_1135->hd;
    if (f(hd1))
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
      Prims_list__Extensions_extension_
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
      buf[0U]
      =
        (
          (Prims_list__Extensions_extension_){
            .tag = Prims_Cons,
            .hd = hd1,
            .tl = FStar_List_Tot_Base_filter__Extensions_extension_(f, tl1)
          }
        );
      return buf;
    }
    else
      return FStar_List_Tot_Base_filter__Extensions_extension_(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
Extensions_app_ext_filter(
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ uu___9_4671
)
{
  if (uu___9_4671.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (uu___9_4671.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *l = uu___9_4671.v;
    return
      (
        (FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_Some,
          .v = FStar_List_Tot_Base_filter__Extensions_extension_(Extensions_app_filter, l)
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Extensions_encryptedExtension(Extensions_extension_ ext)
{
  if (ext.tag == Extensions_E_server_name)
    return true;
  else if (ext.tag == Extensions_E_supported_groups)
    return true;
  else if (ext.tag == Extensions_E_alpn)
    return true;
  else if (ext.tag == Extensions_E_unknown_extension)
    return true;
  else if (ext.tag == Extensions_E_early_data)
    return true;
  else
    return false;
}

static FStar_Bytes_bytes Extensions_extensionPayloadBytes(Extensions_extension_ uu___10_4814)
{
  if
  (
    uu___10_4814.tag
    == Extensions_E_server_name
    && uu___10_4814.val.case_E_server_name->tag == Prims_Nil
  )
    return Parse_vlbytes((krml_checked_int_t)2, FStar_Bytes_empty_bytes);
  else if (uu___10_4814.tag == Extensions_E_server_name)
  {
    Prims_list__TLSConstants_serverName *l = uu___10_4814.val.case_E_server_name;
    return
      Parse_vlbytes((krml_checked_int_t)2,
        Parse_vlbytes((krml_checked_int_t)2, Extensions_serverNameBytes(l)));
  }
  else if (uu___10_4814.tag == Extensions_E_supported_groups)
  {
    Prims_list__Parsers_NamedGroup_namedGroup *l = uu___10_4814.val.case_E_supported_groups;
    return Parse_vlbytes((krml_checked_int_t)2, CommonDH_namedGroupsBytes(l));
  }
  else if (uu___10_4814.tag == Extensions_E_signature_algorithms)
  {
    Prims_list__Parsers_SignatureScheme_signatureScheme
    *sha = uu___10_4814.val.case_E_signature_algorithms;
    return Parse_vlbytes((krml_checked_int_t)2, TLSConstants_signatureSchemeListBytes(sha));
  }
  else if (uu___10_4814.tag == Extensions_E_signature_algorithms_cert)
  {
    Prims_list__Parsers_SignatureScheme_signatureScheme
    *sha = uu___10_4814.val.case_E_signature_algorithms_cert;
    return Parse_vlbytes((krml_checked_int_t)2, TLSConstants_signatureSchemeListBytes(sha));
  }
  else if (uu___10_4814.tag == Extensions_E_session_ticket)
  {
    FStar_Bytes_bytes b = uu___10_4814.val.case_E_session_ticket;
    return Parse_vlbytes((krml_checked_int_t)2, b);
  }
  else if (uu___10_4814.tag == Extensions_E_key_share)
  {
    CommonDH_keyShare ks = uu___10_4814.val.case_E_key_share;
    return Parse_vlbytes((krml_checked_int_t)2, CommonDH_keyShareBytes(ks));
  }
  else if (uu___10_4814.tag == Extensions_E_pre_shared_key)
  {
    Extensions_psk psk = uu___10_4814.val.case_E_pre_shared_key;
    if (psk.tag == Extensions_ClientPSK)
    {
      Prims_int len1 = psk.val.case_ClientPSK.binders_len;
      return
        Parse_vlbytes_trunc((krml_checked_int_t)2,
          Extensions_pskBytes(psk),
          Prims_op_Addition((krml_checked_int_t)2, len1));
    }
    else
      return Parse_vlbytes((krml_checked_int_t)2, Extensions_pskBytes(psk));
  }
  else if (uu___10_4814.tag == Extensions_E_early_data)
  {
    FStar_Pervasives_Native_option__uint32_t edi = uu___10_4814.val.case_E_early_data;
    return Parse_vlbytes((krml_checked_int_t)2, Extensions_earlyDataIndicationBytes(edi));
  }
  else if (uu___10_4814.tag == Extensions_E_supported_versions)
  {
    Extensions_protocol_versions vs = uu___10_4814.val.case_E_supported_versions;
    return Parse_vlbytes((krml_checked_int_t)2, Extensions_protocol_versions_bytes(vs));
  }
  else if (uu___10_4814.tag == Extensions_E_cookie)
  {
    FStar_Bytes_bytes c = uu___10_4814.val.case_E_cookie;
    return Parse_vlbytes((krml_checked_int_t)2, Parse_vlbytes((krml_checked_int_t)2, c));
  }
  else if (uu___10_4814.tag == Extensions_E_psk_key_exchange_modes)
  {
    Prims_list__Extensions_psk_kex *kex = uu___10_4814.val.case_E_psk_key_exchange_modes;
    return Parse_vlbytes((krml_checked_int_t)2, Extensions_client_psk_kexes_bytes(kex));
  }
  else if (uu___10_4814.tag == Extensions_E_extended_ms)
    return Parse_vlbytes((krml_checked_int_t)2, FStar_Bytes_empty_bytes);
  else if (uu___10_4814.tag == Extensions_E_ec_point_format)
  {
    Prims_list__Extensions_point_format *l = uu___10_4814.val.case_E_ec_point_format;
    return Parse_vlbytes((krml_checked_int_t)2, Extensions_ecpfListBytes(l));
  }
  else if (uu___10_4814.tag == Extensions_E_alpn)
  {
    Prims_list__FStar_Bytes_bytes *l = uu___10_4814.val.case_E_alpn;
    return Parse_vlbytes((krml_checked_int_t)2, Extensions_alpnBytes(l));
  }
  else if (uu___10_4814.tag == Extensions_E_unknown_extension)
  {
    FStar_Bytes_bytes b = uu___10_4814.val.case_E_unknown_extension._1;
    return Parse_vlbytes((krml_checked_int_t)2, b);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes Extensions_extensionHeaderBytes____(Extensions_extension_ ext)
{
  if (ext.tag == Extensions_E_server_name)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x00U }));
  else if (ext.tag == Extensions_E_supported_groups)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x0AU }));
  else if (ext.tag == Extensions_E_signature_algorithms)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x0DU }));
  else if (ext.tag == Extensions_E_signature_algorithms_cert)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)50U }));
  else if (ext.tag == Extensions_E_session_ticket)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x23U }));
  else if (ext.tag == Extensions_E_key_share)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)51U }));
  else if (ext.tag == Extensions_E_pre_shared_key)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x29U }));
  else if (ext.tag == Extensions_E_early_data)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2aU }));
  else if (ext.tag == Extensions_E_supported_versions)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2bU }));
  else if (ext.tag == Extensions_E_cookie)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2cU }));
  else if (ext.tag == Extensions_E_psk_key_exchange_modes)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x2dU }));
  else if (ext.tag == Extensions_E_extended_ms)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x17U }));
  else if (ext.tag == Extensions_E_ec_point_format)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x0BU }));
  else if (ext.tag == Extensions_E_alpn)
    return
      FStar_Bytes_twobytes(((K___uint8_t_uint8_t){ .fst = (uint8_t)0x00U, .snd = (uint8_t)0x10U }));
  else if (ext.tag == Extensions_E_unknown_extension)
    return ext.val.case_E_unknown_extension.x;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes Extensions_extensionBytes(Extensions_extension_ ext)
{
  FStar_Bytes_bytes head1 = Extensions_extensionHeaderBytes____(ext);
  FStar_Bytes_bytes payload = Extensions_extensionPayloadBytes(ext);
  return FStar_Bytes_append(head1, payload);
}

static FStar_Bytes_bytes
Extensions_extensionListBytes_aux(FStar_Bytes_bytes l, Extensions_extension_ s)
{
  FStar_Bytes_bytes es = Extensions_extensionBytes(s);
  return FStar_Bytes_append(l, es);
}

static FStar_Bytes_bytes
FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_Extensions_extension_(
  FStar_Bytes_bytes (*f)(FStar_Bytes_bytes x0, Extensions_extension_ x1),
  FStar_Bytes_bytes x,
  Prims_list__Extensions_extension_ *l
)
{
  if (l->tag == Prims_Nil)
    return x;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = l->tl;
    Extensions_extension_ hd1 = l->hd;
    return
      FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_Extensions_extension_(f,
        f(x, hd1),
        tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes Extensions_extensionListBytes(Prims_list__Extensions_extension_ *exts)
{
  return
    FStar_List_Tot_Base_fold_left__FStar_Bytes_bytes_Extensions_extension_(Extensions_extensionListBytes_aux,
      FStar_Bytes_empty_bytes,
      exts);
}

FStar_Pervasives_Native_option__Extensions_extension_
FStar_List_Tot_Base_find__Extensions_extension_(
  bool (*f)(Extensions_extension_ x0),
  Prims_list__Extensions_extension_ *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Extensions_extension_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = l->tl;
    Extensions_extension_ hd1 = l->hd;
    if (f(hd1))
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return FStar_List_Tot_Base_find__Extensions_extension_(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Extensions_uu___is_E_pre_shared_key____(Extensions_extension_ projectee)
{
  if (projectee.tag == Extensions_E_pre_shared_key)
    return true;
  else
    return false;
}

Prims_int Extensions_bindersLen____(Prims_list__Extensions_extension_ *el)
{
  FStar_Pervasives_Native_option__Extensions_extension_
  scrut =
    FStar_List_Tot_Base_find__Extensions_extension_(Extensions_uu___is_E_pre_shared_key____,
      el);
  if
  (
    scrut.tag
    == FStar_Pervasives_Native_Some
    &&
      scrut.v.tag
      == Extensions_E_pre_shared_key
      && scrut.v.val.case_E_pre_shared_key.tag == Extensions_ClientPSK
  )
  {
    Prims_int len1 = scrut.v.val.case_E_pre_shared_key.val.case_ClientPSK.binders_len;
    return Prims_op_Addition((krml_checked_int_t)2, len1);
  }
  else
    return (krml_checked_int_t)0;
}

FStar_Bytes_bytes Extensions_extensionsBytes(Prims_list__Extensions_extension_ *exts)
{
  FStar_Bytes_bytes b = Extensions_extensionListBytes(exts);
  Prims_int binder_len = Extensions_bindersLen____(exts);
  return Parse_vlbytes_trunc((krml_checked_int_t)2, b, binder_len);
}

static bool
Extensions_existsb2__Extensions_extension__Extensions_extension_(
  bool (*f)(Extensions_extension_ x0, Extensions_extension_ x1),
  Extensions_extension_ x,
  Prims_list__Extensions_extension_ *y
)
{
  if (y->tag == Prims_Nil)
    return false;
  else if (y->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = y->tl;
    Extensions_extension_ hd1 = y->hd;
    return
      f(x,
        hd1)
      || Extensions_existsb2__Extensions_extension__Extensions_extension_(f, x, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct K___Extensions_extension__Extensions_extension__s
{
  Extensions_extension_ fst;
  Extensions_extension_ snd;
}
K___Extensions_extension__Extensions_extension_;

bool Extensions_sameExt____(Extensions_extension_ e1, Extensions_extension_ e2)
{
  K___Extensions_extension__Extensions_extension_ q = { .fst = e1, .snd = e2 };
  if (q.fst.tag == Extensions_E_server_name && q.snd.tag == Extensions_E_server_name)
    return true;
  else if
  (q.fst.tag == Extensions_E_supported_groups && q.snd.tag == Extensions_E_supported_groups)
    return true;
  else if
  (
    q.fst.tag
    == Extensions_E_signature_algorithms
    && q.snd.tag == Extensions_E_signature_algorithms
  )
    return true;
  else if
  (
    q.fst.tag
    == Extensions_E_signature_algorithms_cert
    && q.snd.tag == Extensions_E_signature_algorithms_cert
  )
    return true;
  else if (q.fst.tag == Extensions_E_key_share && q.snd.tag == Extensions_E_key_share)
    return true;
  else if (q.fst.tag == Extensions_E_pre_shared_key && q.snd.tag == Extensions_E_pre_shared_key)
    return true;
  else if (q.fst.tag == Extensions_E_session_ticket && q.snd.tag == Extensions_E_session_ticket)
    return true;
  else if (q.fst.tag == Extensions_E_early_data && q.snd.tag == Extensions_E_early_data)
    return true;
  else if
  (q.fst.tag == Extensions_E_supported_versions && q.snd.tag == Extensions_E_supported_versions)
    return true;
  else if (q.fst.tag == Extensions_E_cookie && q.snd.tag == Extensions_E_cookie)
    return true;
  else if
  (
    q.fst.tag
    == Extensions_E_psk_key_exchange_modes
    && q.snd.tag == Extensions_E_psk_key_exchange_modes
  )
    return true;
  else if (q.fst.tag == Extensions_E_extended_ms && q.snd.tag == Extensions_E_extended_ms)
    return true;
  else if
  (q.fst.tag == Extensions_E_ec_point_format && q.snd.tag == Extensions_E_ec_point_format)
    return true;
  else if (q.fst.tag == Extensions_E_alpn && q.snd.tag == Extensions_E_alpn)
    return true;
  else if
  (q.fst.tag == Extensions_E_unknown_extension && q.snd.tag == Extensions_E_unknown_extension)
  {
    FStar_Bytes_bytes h2 = q.snd.val.case_E_unknown_extension.x;
    FStar_Bytes_bytes h1 = q.fst.val.case_E_unknown_extension.x;
    return __eq__FStar_Bytes_bytes(h1, h2);
  }
  else
    return false;
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
TLSError_fatal__Prims_list_Extensions_extension_(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

Prims_list__Extensions_extension_
*FStar_List_Tot_Base_append__Extensions_extension_(
  Prims_list__Extensions_extension_ *x,
  Prims_list__Extensions_extension_ *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = x->tl;
    Extensions_extension_ a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__Extensions_extension_(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_Extensions_extension_(
  Prims_list__Extensions_extension_ *x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
Extensions_addOnce(Extensions_extension_ ext, Prims_list__Extensions_extension_ *extList)
{
  if
  (
    Extensions_existsb2__Extensions_extension__Extensions_extension_(Extensions_sameExt____,
      ext,
      extList)
  )
    return
      TLSError_fatal__Prims_list_Extensions_extension_(Parsers_AlertDescription_Handshake_failure,
        FStar_Error_perror("Extensions.fst",
          (krml_checked_int_t)898,
          "Same extension received more than once"));
  else
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf0[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Cons, .hd = ext, .tl = buf });
    Prims_list__Extensions_extension_
    *res = FStar_List_Tot_Base_append__Extensions_extension_(extList, buf0);
    return
      FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_Extensions_extension_(res);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
TLSError_fatal__Prims_list_Extensions_point_format(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
Extensions_error__Prims_list_Extensions_point_format(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_Extensions_point_format(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
Extensions_parseEcpfList_aux(FStar_Bytes_bytes b)
{
  if (__eq__FStar_Bytes_bytes(b, FStar_Bytes_empty_bytes))
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_point_format), (uint32_t)1U);
    Prims_list__Extensions_point_format
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_point_format));
    buf[0U] = ((Prims_list__Extensions_point_format){ .tag = Prims_Nil });
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = buf }
        }
      );
  }
  else if (FStar_UInt32_v(FStar_Bytes_len(b)) == (krml_checked_int_t)0)
    return Extensions_error__Prims_list_Extensions_point_format("malformed curve list");
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = FStar_Bytes_split(b, (uint32_t)1U);
    FStar_Bytes_bytes u2 = scrut.fst;
    FStar_Bytes_bytes v1 = scrut.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
    scrut0 = Extensions_parseEcpfList_aux(v1);
    if (scrut0.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut0.tag == FStar_Error_Correct)
    {
      Prims_list__Extensions_point_format *l = scrut0.val.case_Correct;
      Extensions_point_format cur;
      switch (FStar_Bytes_get(u2, (uint32_t)0U))
      {
        case 0U:
          {
            cur = ((Extensions_point_format){ .tag = Extensions_ECP_UNCOMPRESSED });
            break;
          }
        default:
          {
            cur =
              (
                (Extensions_point_format){
                  .tag = Extensions_ECP_UNKNOWN,
                  ._0 = FStar_Bytes_int_of_bytes(u2)
                }
              );
          }
      }
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_point_format), (uint32_t)1U);
      Prims_list__Extensions_point_format
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_point_format));
      buf[0U] = ((Prims_list__Extensions_point_format){ .tag = Prims_Cons, .hd = cur, .tl = l });
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = buf }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

bool __eq__Extensions_point_format(Extensions_point_format y, Extensions_point_format x)
{
  if (x.tag == Extensions_ECP_UNCOMPRESSED)
    if (y.tag == Extensions_ECP_UNCOMPRESSED)
      return true;
    else
      return false;
  else if (x.tag == Extensions_ECP_UNKNOWN)
  {
    Prims_int x__0 = x._0;
    if (y.tag == Extensions_ECP_UNKNOWN)
    {
      Prims_int y__0 = y._0;
      return true && y__0 == x__0;
    }
    else
      return false;
  }
  else
    return false;
}

static bool
FStar_List_Tot_Base_mem__Extensions_point_format(
  Extensions_point_format x,
  Prims_list__Extensions_point_format *uu___7_953
)
{
  if (uu___7_953->tag == Prims_Nil)
    return false;
  else if (uu___7_953->tag == Prims_Cons)
  {
    Prims_list__Extensions_point_format *tl1 = uu___7_953->tl;
    Extensions_point_format hd1 = uu___7_953->hd;
    if (__eq__Extensions_point_format(hd1, x))
      return true;
    else
      return FStar_List_Tot_Base_mem__Extensions_point_format(x, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_Extensions_point_format(
  Prims_list__Extensions_point_format *x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
Extensions_parseEcpfList(FStar_Bytes_bytes b)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
  scrut = Extensions_parseEcpfList_aux(b);
  if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else if (scrut.tag == FStar_Error_Correct)
  {
    Prims_list__Extensions_point_format *l = scrut.val.case_Correct;
    if
    (
      FStar_List_Tot_Base_mem__Extensions_point_format((
          (Extensions_point_format){ .tag = Extensions_ECP_UNCOMPRESSED }
        ),
        l)
    )
      return
        FStar_Error_correct__Parsers_Alert_alert___Prims_string_Prims_list_Extensions_point_format(l);
    else
      return
        Extensions_error__Prims_list_Extensions_point_format("uncompressed point format not supported");
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
Extensions_error__CommonDH_keyShare(Prims_string s)
{
  return
    TLSError_fatal__CommonDH_keyShare(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
Extensions_parseKeyShare(Extensions_ext_msg mt, FStar_Bytes_bytes data)
{
  switch (mt)
  {
    case Extensions_EM_ClientHello:
      {
        return CommonDH_parseClientKeyShare(data);
      }
    case Extensions_EM_ServerHello:
      {
        return CommonDH_parseServerKeyShare(data);
      }
    case Extensions_EM_HelloRetryRequest:
      {
        return CommonDH_parseHelloRetryKeyShare(data);
      }
    default:
      {
        return
          Extensions_error__CommonDH_keyShare("key_share extension cannot appear in this message type");
      }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSError_fatal__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Prims_string s
)
{
  return
    TLSError_fatal__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_NamedGroup_namedGroup
TLSError_fatal__Prims_list_Parsers_NamedGroup_namedGroup(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_NamedGroup_namedGroup){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_NamedGroup_namedGroup
Extensions_error__Prims_list_Parsers_NamedGroup_namedGroup(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_Parsers_NamedGroup_namedGroup(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_parseExtension(Extensions_ext_msg mt, FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)4))
    return
      Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("extension type: not enough bytes");
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(b, (uint32_t)2U);
    FStar_Bytes_bytes head1 = scrut0.fst;
    FStar_Bytes_bytes payload = scrut0.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut1 = Parse_vlparse((krml_checked_int_t)2, payload);
    if (scrut1.tag == FStar_Error_Error)
    {
      Prims_string s = scrut1.val.case_Error.snd;
      return
        Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Prims_strcat("extension: ",
            s));
    }
    else if (scrut1.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes data = scrut1.val.case_Correct;
      K___uint8_t_uint8_t scrut0 = Parse_cbyte2(head1);
      if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x00U)
      {
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__TLSConstants_serverName
        scrut = Extensions_parseServerName(mt, data);
        if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else if (scrut.tag == FStar_Error_Correct)
        {
          Prims_list__TLSConstants_serverName *c = scrut.val.case_Correct;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .fst = { .tag = Extensions_E_server_name, .val = { .case_E_server_name = c } },
                    .snd = { .tag = FStar_Pervasives_Native_None }
                  }
                }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x0AU)
        if
        (
          Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)2)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)65538)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("supported groups");
        else
        {
          FStar_Pervasives_Native_option__K___Prims_list__Parsers_NamedGroup_namedGroup_uint32_t
          scrut0 = CommonDH_parseNamedGroups(data);
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_NamedGroup_namedGroup
          scrut;
          if (scrut0.tag == FStar_Pervasives_Native_Some)
          {
            Prims_list__Parsers_NamedGroup_namedGroup *x = scrut0.v.fst;
            scrut =
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_NamedGroup_namedGroup){
                  .tag = FStar_Error_Correct,
                  .val = { .case_Correct = x }
                }
              );
          }
          else
            scrut =
              Extensions_error__Prims_list_Parsers_NamedGroup_namedGroup("supported_groups parser error");
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Prims_list__Parsers_NamedGroup_namedGroup *c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_supported_groups,
                        .val = { .case_E_supported_groups = c }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)13U)
        if
        (
          Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)2)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)65538)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("supported signature algorithms");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_SignatureScheme_signatureScheme
          scrut = TLSConstants_parseSignatureSchemeList(data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Prims_list__Parsers_SignatureScheme_signatureScheme *c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_signature_algorithms,
                        .val = { .case_E_signature_algorithms = c }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)50U)
        if
        (
          Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)2)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)65538)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("supported signature algorithms (cert)");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_SignatureScheme_signatureScheme
          scrut = TLSConstants_parseSignatureSchemeList(data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Prims_list__Parsers_SignatureScheme_signatureScheme *c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_signature_algorithms_cert,
                        .val = { .case_E_signature_algorithms_cert = c }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x10U)
        if
        (
          Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)2)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)65538)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("application layer protocol negotiation");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
          scrut = Extensions_parseAlpn(data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Prims_list__FStar_Bytes_bytes *c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = { .tag = Extensions_E_alpn, .val = { .case_E_alpn = c } },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x23U)
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .fst = {
                    .tag = Extensions_E_session_ticket,
                    .val = { .case_E_session_ticket = data }
                  },
                  .snd = { .tag = FStar_Pervasives_Native_None }
                }
              }
            }
          );
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)51U)
      {
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_CommonDH_keyShare
        scrut = Extensions_parseKeyShare(mt, data);
        if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else if (scrut.tag == FStar_Error_Correct)
        {
          CommonDH_keyShare c = scrut.val.case_Correct;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .fst = { .tag = Extensions_E_key_share, .val = { .case_E_key_share = c } },
                    .snd = { .tag = FStar_Pervasives_Native_None }
                  }
                }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x29U)
        if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)2))
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("PSK");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_psk_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
          scrut = Extensions_parse_psk(mt, data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if
          (
            scrut.tag
            == FStar_Error_Correct
            && scrut.val.case_Correct.snd.tag == FStar_Pervasives_Native_None
          )
          {
            Extensions_psk psk = scrut.val.case_Correct.fst;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_pre_shared_key,
                        .val = { .case_E_pre_shared_key = psk }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else if
          (
            scrut.tag
            == FStar_Error_Correct
            && scrut.val.case_Correct.snd.tag == FStar_Pervasives_Native_Some
          )
          {
            Prims_list__FStar_Bytes_bytes *binders = scrut.val.case_Correct.snd.v;
            Extensions_psk psk = scrut.val.case_Correct.fst;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_pre_shared_key,
                        .val = { .case_E_pre_shared_key = psk }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_Some, .v = binders }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x2aU)
        if
        (
          FStar_UInt32_v(FStar_Bytes_len(data))
          != (krml_checked_int_t)0
          && FStar_UInt32_v(FStar_Bytes_len(data)) != (krml_checked_int_t)4
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("early data indication");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__uint32_t
          scrut = Extensions_parseEarlyDataIndication(data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Pervasives_Native_option__uint32_t c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = { .tag = Extensions_E_early_data, .val = { .case_E_early_data = c } },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x2bU)
        if
        (
          Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)2)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)256)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("supported versions");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Extensions_protocol_versions
          scrut = Extensions_parseSupportedVersions(data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Extensions_protocol_versions c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_supported_versions,
                        .val = { .case_E_supported_versions = c }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x2cU)
        if
        (
          Prims_op_LessThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)2)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)65538)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("cookie");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
          scrut = Parse_vlparse((krml_checked_int_t)2, data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Bytes_bytes data1 = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = { .tag = Extensions_E_cookie, .val = { .case_E_cookie = data1 } },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x2dU)
        if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)2))
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("psk_key_exchange_modes");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_psk_kex
          scrut = Extensions_parse_client_psk_kexes(data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Prims_list__Extensions_psk_kex *c = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .fst = {
                        .tag = Extensions_E_psk_key_exchange_modes,
                        .val = { .case_E_psk_key_exchange_modes = c }
                      },
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x17U)
        if (Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)0))
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("extended master secret");
        else
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .fst = { .tag = Extensions_E_extended_ms },
                    .snd = { .tag = FStar_Pervasives_Native_None }
                  }
                }
              }
            );
      else if (scrut0.fst == (uint8_t)0x00U && scrut0.snd == (uint8_t)0x0BU)
        if
        (
          Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)),
            (krml_checked_int_t)1)
          ||
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)),
              (krml_checked_int_t)256)
        )
          return
            Extensions_error__Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("ec point format");
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
          scrut = Parse_vlparse((krml_checked_int_t)1, data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Bytes_bytes ecpfs = scrut.val.case_Correct;
            FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_point_format
            scrut = Extensions_parseEcpfList(ecpfs);
            if (scrut.tag == FStar_Error_Error)
            {
              K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                    .tag = FStar_Error_Error,
                    .val = { .case_Error = z }
                  }
                );
            }
            else if (scrut.tag == FStar_Error_Correct)
            {
              Prims_list__Extensions_point_format *c = scrut.val.case_Correct;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                    .tag = FStar_Error_Correct,
                    .val = {
                      .case_Correct = {
                        .fst = {
                          .tag = Extensions_E_ec_point_format,
                          .val = { .case_E_ec_point_format = c }
                        },
                        .snd = { .tag = FStar_Pervasives_Native_None }
                      }
                    }
                  }
                );
            }
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      else
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .fst = {
                    .tag = Extensions_E_unknown_extension,
                    .val = { .case_E_unknown_extension = { .x = head1, ._1 = data } }
                  },
                  .snd = { .tag = FStar_Pervasives_Native_None }
                }
              }
            }
          );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSError_fatal__Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_error__Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Prims_string s
)
{
  return
    TLSError_fatal__Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Extensions parsing: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_parseExtensions_aux(
  Extensions_ext_msg mt,
  FStar_Bytes_bytes b,
  K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
  uu____6317
)
{
  Prims_list__Extensions_extension_ *exts = uu____6317.fst;
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes obinders = uu____6317.snd;
  if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)4))
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = FStar_Bytes_split(b, (uint32_t)2U);
    FStar_Bytes_bytes ht = scrut.fst;
    FStar_Bytes_bytes b1 = scrut.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut0 = Parse_vlsplit((krml_checked_int_t)2, b1);
    if (scrut0.tag == FStar_Error_Error)
      return
        Extensions_error__Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("extension length");
    else if (scrut0.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes bytes = scrut0.val.case_Correct.snd;
      FStar_Bytes_bytes ext = scrut0.val.case_Correct.fst;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
      scrut =
        Extensions_parseExtension(mt,
          FStar_Bytes_append(ht, Parse_vlbytes((krml_checked_int_t)2, ext)));
      if
      (
        scrut.tag
        == FStar_Error_Correct
        && scrut.val.case_Correct.snd.tag == FStar_Pervasives_Native_Some
      )
      {
        Prims_list__FStar_Bytes_bytes *binders = scrut.val.case_Correct.snd.v;
        Extensions_extension_ ext1 = scrut.val.case_Correct.fst;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
        scrut = Extensions_addOnce(ext1, exts);
        if (scrut.tag == FStar_Error_Correct)
        {
          Prims_list__Extensions_extension_ *exts1 = scrut.val.case_Correct;
          return
            Extensions_parseExtensions_aux(mt,
              bytes,
              (
                (K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .fst = exts1,
                  .snd = { .tag = FStar_Pervasives_Native_Some, .v = binders }
                }
              ));
        }
        else if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else if
      (
        scrut.tag
        == FStar_Error_Correct
        && scrut.val.case_Correct.snd.tag == FStar_Pervasives_Native_None
      )
      {
        Extensions_extension_ ext1 = scrut.val.case_Correct.fst;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
        scrut = Extensions_addOnce(ext1, exts);
        if (scrut.tag == FStar_Error_Correct)
        {
          Prims_list__Extensions_extension_ *exts1 = scrut.val.case_Correct;
          return
            Extensions_parseExtensions_aux(mt,
              bytes,
              (
                (K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                  .fst = exts1,
                  .snd = obinders
                }
              ));
        }
        else if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .fst = exts, .snd = obinders } }
        }
      );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_parseExtensions(Extensions_ext_msg mt, FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)2))
    return
      Extensions_error__Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("extensions");
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)2, b);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes b1 = scrut.val.case_Correct;
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
      Prims_list__Extensions_extension_
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
      buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
      return
        Extensions_parseExtensions_aux(mt,
          b1,
          (
            (K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .fst = buf,
              .snd = { .tag = FStar_Pervasives_Native_None }
            }
          ));
    }
    else if (scrut.tag == FStar_Error_Error)
      return
        Extensions_error__Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("extensions");
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
Extensions_parseOptExtensions(Extensions_ext_msg mt, FStar_Bytes_bytes data)
{
  if (FStar_UInt32_v(FStar_Bytes_len(data)) == (krml_checked_int_t)0)
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = {
              .fst = { .tag = FStar_Pervasives_Native_None },
              .snd = { .tag = FStar_Pervasives_Native_None }
            }
          }
        }
      );
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
    scrut = Extensions_parseExtensions(mt, data);
    if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
      obinders = scrut.val.case_Correct.snd;
      Prims_list__Extensions_extension_ *ee = scrut.val.case_Correct.fst;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .fst = { .tag = FStar_Pervasives_Native_Some, .v = ee },
                .snd = obinders
              }
            }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static Prims_list__CipherSuite_cipherSuite_
*Extensions_list_valid_cs_is_list_cs(Prims_list__CipherSuite_cipherSuite_ *l)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__CipherSuite_cipherSuite_), (uint32_t)1U);
    Prims_list__CipherSuite_cipherSuite_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CipherSuite_cipherSuite_));
    buf[0U] = ((Prims_list__CipherSuite_cipherSuite_){ .tag = Prims_Nil });
    return buf;
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__CipherSuite_cipherSuite_ *tl1 = l->tl;
    CipherSuite_cipherSuite_ hd1 = l->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__CipherSuite_cipherSuite_), (uint32_t)1U);
    Prims_list__CipherSuite_cipherSuite_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CipherSuite_cipherSuite_));
    buf[0U]
    =
      (
        (Prims_list__CipherSuite_cipherSuite_){
          .tag = Prims_Cons,
          .hd = hd1,
          .tl = Extensions_list_valid_cs_is_list_cs(tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Parsers_NamedGroup_namedGroup
*Extensions_list_valid_ng_is_list_ng(Prims_list__Parsers_NamedGroup_namedGroup *l)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
    Prims_list__Parsers_NamedGroup_namedGroup
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
    buf[0U] = ((Prims_list__Parsers_NamedGroup_namedGroup){ .tag = Prims_Nil });
    return buf;
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Parsers_NamedGroup_namedGroup *tl1 = l->tl;
    Parsers_NamedGroup_namedGroup hd1 = l->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
    Prims_list__Parsers_NamedGroup_namedGroup
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
    buf[0U]
    =
      (
        (Prims_list__Parsers_NamedGroup_namedGroup){
          .tag = Prims_Cons,
          .hd = hd1,
          .tl = Extensions_list_valid_ng_is_list_ng(tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool Extensions_allow_psk_resumption(TLSConstants_pskInfo x)
{
  return x.allow_psk_resumption;
}

static bool Extensions_allow_dhe_resumption(TLSConstants_pskInfo x)
{
  return x.allow_dhe_resumption;
}

static bool Extensions_allow_resumption(K___FStar_Bytes_bytes_TLSConstants_pskInfo uu____6683)
{
  TLSConstants_pskInfo x = uu____6683.snd;
  return x.allow_psk_resumption || x.allow_dhe_resumption;
}

static bool Extensions_send_supported_groups(CipherSuite_cipherSuite_ cs)
{
  return CipherSuite_isDHECipherSuite(cs) || CipherSuite_uu___is_CipherSuite13(cs);
}

static Prims_int Extensions_compute_binder_len(Prims_int ctr, TLSConstants_pskInfo pski)
{
  Spec_Hash_Definitions_hash_alg h1 = PSK_pskInfo_hash(pski);
  uint32_t sw;
  switch (h1)
  {
    case Spec_Hash_Definitions_MD5:
      {
        sw = (uint32_t)16U;
        break;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        sw = (uint32_t)20U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        sw = (uint32_t)28U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        sw = (uint32_t)32U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        sw = (uint32_t)48U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        sw = (uint32_t)64U;
        break;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  return Prims_op_Addition(Prims_op_Addition(ctr, (krml_checked_int_t)1), FStar_UInt32_v(sw));
}

static Prims_list__K___FStar_Bytes_bytes_uint32_t
*Extensions_obfuscate_age(
  uint32_t now,
  Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *uu___11_6745
)
{
  if (uu___11_6745->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t), (uint32_t)1U);
    Prims_list__K___FStar_Bytes_bytes_uint32_t
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t));
    buf[0U] = ((Prims_list__K___FStar_Bytes_bytes_uint32_t){ .tag = Prims_Nil });
    return buf;
  }
  else if (uu___11_6745->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *t = uu___11_6745->tl;
    TLSConstants_pskInfo ctx = uu___11_6745->hd.snd;
    FStar_Bytes_bytes id1 = uu___11_6745->hd.fst;
    uint32_t age = (now - ctx.time_created) * (uint32_t)1000U;
    KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t), (uint32_t)1U);
    Prims_list__K___FStar_Bytes_bytes_uint32_t
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_uint32_t));
    buf[0U]
    =
      (
        (Prims_list__K___FStar_Bytes_bytes_uint32_t){
          .tag = Prims_Cons,
          .hd = { .fst = id1, .snd = PSK_encode_age(age, ctx.ticket_age_add) },
          .tl = Extensions_obfuscate_age(now, t)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
FStar_List_Tot_Base_existsb__CipherSuite_cipherSuite_(
  bool (*f)(CipherSuite_cipherSuite_ x0),
  Prims_list__CipherSuite_cipherSuite_ *l
)
{
  if (l->tag == Prims_Nil)
    return false;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__CipherSuite_cipherSuite_ *tl1 = l->tl;
    CipherSuite_cipherSuite_ hd1 = l->hd;
    if (f(hd1))
      return true;
    else
      return FStar_List_Tot_Base_existsb__CipherSuite_cipherSuite_(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo
*FStar_List_Tot_Base_filter__FStar_Bytes_bytes___TLSConstants_pskInfo(
  bool (*f)(K___FStar_Bytes_bytes_TLSConstants_pskInfo x0),
  Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *uu___8_1135
)
{
  if (uu___8_1135->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo), (uint32_t)1U);
    Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo));
    buf[0U] = ((Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo){ .tag = Prims_Nil });
    return buf;
  }
  else if (uu___8_1135->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *tl1 = uu___8_1135->tl;
    K___FStar_Bytes_bytes_TLSConstants_pskInfo hd1 = uu___8_1135->hd;
    if (f(hd1))
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo),
        (uint32_t)1U);
      Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo));
      buf[0U]
      =
        (
          (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo){
            .tag = Prims_Cons,
            .hd = hd1,
            .tl = FStar_List_Tot_Base_filter__FStar_Bytes_bytes___TLSConstants_pskInfo(f, tl1)
          }
        );
      return buf;
    }
    else
      return FStar_List_Tot_Base_filter__FStar_Bytes_bytes___TLSConstants_pskInfo(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo_s
{
  Prims_list__FStar_Bytes_bytes *fst;
  Prims_list__TLSConstants_pskInfo *snd;
}
K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo;

static K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo
FStar_List_Tot_Base_split__FStar_Bytes_bytes_TLSConstants_pskInfo(
  Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *l
)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf0[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_pskInfo), (uint32_t)1U);
    Prims_list__TLSConstants_pskInfo
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_pskInfo));
    buf[0U] = ((Prims_list__TLSConstants_pskInfo){ .tag = Prims_Nil });
    return
      (
        (K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo){
          .fst = buf0,
          .snd = buf
        }
      );
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *tl1 = l->tl;
    TLSConstants_pskInfo hd2 = l->hd.snd;
    FStar_Bytes_bytes hd1 = l->hd.fst;
    K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo
    scrut = FStar_List_Tot_Base_split__FStar_Bytes_bytes_TLSConstants_pskInfo(tl1);
    Prims_list__FStar_Bytes_bytes *tl11 = scrut.fst;
    Prims_list__TLSConstants_pskInfo *tl2 = scrut.snd;
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf0[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Cons, .hd = hd1, .tl = tl11 });
    KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_pskInfo), (uint32_t)1U);
    Prims_list__TLSConstants_pskInfo
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_pskInfo));
    buf[0U] = ((Prims_list__TLSConstants_pskInfo){ .tag = Prims_Cons, .hd = hd2, .tl = tl2 });
    return
      (
        (K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo){
          .fst = buf0,
          .snd = buf
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
FStar_List_Tot_Base_existsb__TLSConstants_pskInfo(
  bool (*f)(TLSConstants_pskInfo x0),
  Prims_list__TLSConstants_pskInfo *l
)
{
  if (l->tag == Prims_Nil)
    return false;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__TLSConstants_pskInfo *tl1 = l->tl;
    TLSConstants_pskInfo hd1 = l->hd;
    if (f(hd1))
      return true;
    else
      return FStar_List_Tot_Base_existsb__TLSConstants_pskInfo(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_int
FStar_List_Tot_Base_fold_left__Prims_int_TLSConstants_pskInfo(
  Prims_int (*f)(Prims_int x0, TLSConstants_pskInfo x1),
  Prims_int x,
  Prims_list__TLSConstants_pskInfo *l
)
{
  if (l->tag == Prims_Nil)
    return x;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__TLSConstants_pskInfo *tl1 = l->tl;
    TLSConstants_pskInfo hd1 = l->hd;
    return FStar_List_Tot_Base_fold_left__Prims_int_TLSConstants_pskInfo(f, f(x, hd1), tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__CommonDH_keyShare_s
{
  Parsers_ProtocolVersion_protocolVersion fst;
  FStar_Pervasives_Native_option__CommonDH_keyShare snd;
}
K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__CommonDH_keyShare;

bool
__neq__FStar_Pervasives_Native_option__FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__FStar_Bytes_bytes y,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes x
)
{
  if (x.tag == FStar_Pervasives_Native_None)
    if (y.tag == FStar_Pervasives_Native_None)
      return false;
    else
      return true;
  else if (x.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes x_v = x.v;
    if (y.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes y_v = y.v;
      return false || __neq__FStar_Bytes_bytes(y_v, x_v);
    }
    else
      return true;
  }
  else
    return true;
}

static bool __neq__EverCrypt_aead_alg(EverCrypt_aead_alg y, EverCrypt_aead_alg x)
{
  switch (x)
  {
    case EverCrypt_AES128_GCM:
      {
        switch (y)
        {
          case EverCrypt_AES128_GCM:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case EverCrypt_AES256_GCM:
      {
        switch (y)
        {
          case EverCrypt_AES256_GCM:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case EverCrypt_CHACHA20_POLY1305:
      {
        switch (y)
        {
          case EverCrypt_CHACHA20_POLY1305:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case EverCrypt_AES128_CCM:
      {
        switch (y)
        {
          case EverCrypt_AES128_CCM:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case EverCrypt_AES256_CCM:
      {
        switch (y)
        {
          case EverCrypt_AES256_CCM:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case EverCrypt_AES128_CCM8:
      {
        switch (y)
        {
          case EverCrypt_AES128_CCM8:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case EverCrypt_AES256_CCM8:
      {
        switch (y)
        {
          case EverCrypt_AES256_CCM8:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    default:
      {
        return true;
      }
  }
}

bool
__neq__Spec_Hash_Definitions_hash_alg(
  Spec_Hash_Definitions_hash_alg y,
  Spec_Hash_Definitions_hash_alg x
)
{
  switch (x)
  {
    case Spec_Hash_Definitions_SHA2_224:
      {
        switch (y)
        {
          case Spec_Hash_Definitions_SHA2_224:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        switch (y)
        {
          case Spec_Hash_Definitions_SHA2_256:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        switch (y)
        {
          case Spec_Hash_Definitions_SHA2_384:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        switch (y)
        {
          case Spec_Hash_Definitions_SHA2_512:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        switch (y)
        {
          case Spec_Hash_Definitions_SHA1:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Spec_Hash_Definitions_MD5:
      {
        switch (y)
        {
          case Spec_Hash_Definitions_MD5:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    default:
      {
        return true;
      }
  }
}

static bool
__neq__K___FStar_Bytes_bytes_FStar_Bytes_bytes(
  K___FStar_Bytes_bytes_FStar_Bytes_bytes y,
  K___FStar_Bytes_bytes_FStar_Bytes_bytes x
)
{
  return
    false
    || __neq__FStar_Bytes_bytes(x.fst, y.fst)
    || __neq__FStar_Bytes_bytes(x.snd, y.snd);
}

static bool __neq__TLSConstants_pskInfo(TLSConstants_pskInfo y, TLSConstants_pskInfo x)
{
  return
    false
    || __neq__FStar_Pervasives_Native_option__FStar_Bytes_bytes(x.ticket_nonce, y.ticket_nonce)
    || x.time_created != y.time_created
    || x.ticket_age_add != y.ticket_age_add
    || x.allow_early_data != y.allow_early_data
    || x.allow_dhe_resumption != y.allow_dhe_resumption
    || x.allow_psk_resumption != y.allow_psk_resumption
    || __neq__EverCrypt_aead_alg(x.early_ae, y.early_ae)
    || __neq__Spec_Hash_Definitions_hash_alg(x.early_hash, y.early_hash)
    || __neq__K___FStar_Bytes_bytes_FStar_Bytes_bytes(x.identities, y.identities);
}

static bool
__neq__K___FStar_Bytes_bytes_TLSConstants_pskInfo(
  K___FStar_Bytes_bytes_TLSConstants_pskInfo y,
  K___FStar_Bytes_bytes_TLSConstants_pskInfo x
)
{
  return
    false
    || __neq__FStar_Bytes_bytes(x.fst, y.fst)
    || __neq__TLSConstants_pskInfo(x.snd, y.snd);
}

static bool
__neq__Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo(
  Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *y,
  Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *x
)
{
  if (x->tag == Prims_Nil)
    if (y->tag == Prims_Nil)
      return false;
    else
      return true;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *x_tl = x->tl;
    K___FStar_Bytes_bytes_TLSConstants_pskInfo x_hd = x->hd;
    if (y->tag == Prims_Cons)
    {
      Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *y_tl = y->tl;
      K___FStar_Bytes_bytes_TLSConstants_pskInfo y_hd = y->hd;
      return
        false
        || __neq__K___FStar_Bytes_bytes_TLSConstants_pskInfo(y_hd, x_hd)
        || __neq__Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo(y_tl, x_tl);
    }
    else
      return true;
  }
  else
    return true;
}

Prims_list__Extensions_extension_
*Extensions_prepareExtensions(
  Parsers_ProtocolVersion_protocolVersion minpv,
  Parsers_ProtocolVersion_protocolVersion pv,
  Prims_list__CipherSuite_cipherSuite_ *cs,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes host,
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes alps,
  Prims_list__K___uint16_t_FStar_Bytes_bytes *custom,
  bool ems,
  bool sren,
  bool edi,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes ticket,
  Prims_list__Parsers_SignatureScheme_signatureScheme *sigAlgs,
  Prims_list__Parsers_NamedGroup_namedGroup *namedGroups,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  FStar_Pervasives_Native_option__CommonDH_keyShare ks,
  Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo *psks,
  uint32_t now
)
{
  Prims_list__Extensions_extension_ *res = Extensions_ext_of_custom(custom);
  K___Parsers_ProtocolVersion_protocolVersion_Parsers_ProtocolVersion_protocolVersion
  scrut0 = { .fst = minpv, .snd = pv };
  Prims_list__Extensions_extension_ *res1;
  if
  (
    scrut0.fst.tag
    == Parsers_ProtocolVersion_TLS_1p3
    && scrut0.snd.tag == Parsers_ProtocolVersion_TLS_1p3
  )
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
    Prims_list__Parsers_ProtocolVersion_protocolVersion
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
    buf[0U] = ((Prims_list__Parsers_ProtocolVersion_protocolVersion){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
    Prims_list__Parsers_ProtocolVersion_protocolVersion
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
    buf0[0U]
    =
      (
        (Prims_list__Parsers_ProtocolVersion_protocolVersion){
          .tag = Prims_Cons,
          .hd = { .tag = Parsers_ProtocolVersion_TLS_1p3 },
          .tl = buf
        }
      );
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf1[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = {
            .tag = Extensions_E_supported_versions,
            .val = {
              .case_E_supported_versions = {
                .tag = Extensions_ClientPV,
                .val = { .case_ClientPV = buf0 }
              }
            }
          },
          .tl = res
        }
      );
    res1 = buf1;
  }
  else if
  (
    scrut0.fst.tag
    == Parsers_ProtocolVersion_TLS_1p2
    && scrut0.snd.tag == Parsers_ProtocolVersion_TLS_1p3
  )
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
    Prims_list__Parsers_ProtocolVersion_protocolVersion
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
    buf[0U] = ((Prims_list__Parsers_ProtocolVersion_protocolVersion){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
    Prims_list__Parsers_ProtocolVersion_protocolVersion
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
    buf0[0U]
    =
      (
        (Prims_list__Parsers_ProtocolVersion_protocolVersion){
          .tag = Prims_Cons,
          .hd = { .tag = Parsers_ProtocolVersion_TLS_1p2 },
          .tl = buf
        }
      );
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion), (uint32_t)1U);
    Prims_list__Parsers_ProtocolVersion_protocolVersion
    *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_ProtocolVersion_protocolVersion));
    buf1[0U]
    =
      (
        (Prims_list__Parsers_ProtocolVersion_protocolVersion){
          .tag = Prims_Cons,
          .hd = { .tag = Parsers_ProtocolVersion_TLS_1p3 },
          .tl = buf0
        }
      );
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf2 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf2[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = {
            .tag = Extensions_E_supported_versions,
            .val = {
              .case_E_supported_versions = {
                .tag = Extensions_ClientPV,
                .val = { .case_ClientPV = buf1 }
              }
            }
          },
          .tl = res
        }
      );
    res1 = buf2;
  }
  else
    res1 = res;
  K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__CommonDH_keyShare
  scrut = { .fst = pv, .snd = ks };
  Prims_list__Extensions_extension_ *res2;
  if
  (
    scrut.fst.tag
    == Parsers_ProtocolVersion_TLS_1p3
    && scrut.snd.tag == FStar_Pervasives_Native_Some
  )
  {
    CommonDH_keyShare ks1 = scrut.snd.v;
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_E_key_share, .val = { .case_E_key_share = ks1 } },
          .tl = res1
        }
      );
    res2 = buf;
  }
  else
    res2 = res1;
  Prims_list__Extensions_extension_ *res3;
  if (host.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes dns = host.v;
    KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
    Prims_list__TLSConstants_serverName
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
    buf[0U] = ((Prims_list__TLSConstants_serverName){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
    Prims_list__TLSConstants_serverName
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
    buf0[0U]
    =
      (
        (Prims_list__TLSConstants_serverName){
          .tag = Prims_Cons,
          .hd = { .tag = TLSConstants_SNI_DNS, .val = { .case_SNI_DNS = dns } },
          .tl = buf
        }
      );
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf1[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_E_server_name, .val = { .case_E_server_name = buf0 } },
          .tl = res2
        }
      );
    res3 = buf1;
  }
  else if (host.tag == FStar_Pervasives_Native_None)
    res3 = res2;
  else
    res3 =
      KRML_EABORT(Prims_list__Extensions_extension_ *,
        "unreachable (pattern matches are exhaustive in F*)");
  Prims_list__Extensions_extension_ *res4;
  if (alps.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__FStar_Bytes_bytes *al = alps.v;
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_E_alpn, .val = { .case_E_alpn = al } },
          .tl = res3
        }
      );
    res4 = buf;
  }
  else if (alps.tag == FStar_Pervasives_Native_None)
    res4 = res3;
  else
    res4 =
      KRML_EABORT(Prims_list__Extensions_extension_ *,
        "unreachable (pattern matches are exhaustive in F*)");
  Prims_list__Extensions_extension_ *res5;
  if (ticket.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes t = ticket.v;
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_E_session_ticket, .val = { .case_E_session_ticket = t } },
          .tl = res4
        }
      );
    res5 = buf;
  }
  else if (ticket.tag == FStar_Pervasives_Native_None)
    res5 = res4;
  else
    res5 =
      KRML_EABORT(Prims_list__Extensions_extension_ *,
        "unreachable (pattern matches are exhaustive in F*)");
  Prims_list__Extensions_extension_ *res6;
  if (ems)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_E_extended_ms },
          .tl = res5
        }
      );
    res6 = buf;
  }
  else
    res6 = res5;
  KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
  Prims_list__Extensions_extension_
  *res7 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
  res7[0U]
  =
    (
      (Prims_list__Extensions_extension_){
        .tag = Prims_Cons,
        .hd = {
          .tag = Extensions_E_signature_algorithms,
          .val = { .case_E_signature_algorithms = sigAlgs }
        },
        .tl = res6
      }
    );
  Prims_list__Extensions_extension_ *res8;
  if
  (
    FStar_List_Tot_Base_existsb__CipherSuite_cipherSuite_(CipherSuite_isECDHECipherSuite,
      Extensions_list_valid_cs_is_list_cs(cs))
  )
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_point_format), (uint32_t)1U);
    Prims_list__Extensions_point_format
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_point_format));
    buf[0U] = ((Prims_list__Extensions_point_format){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_point_format), (uint32_t)1U);
    Prims_list__Extensions_point_format
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_point_format));
    buf0[0U]
    =
      (
        (Prims_list__Extensions_point_format){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_ECP_UNCOMPRESSED },
          .tl = buf
        }
      );
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf1[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = { .tag = Extensions_E_ec_point_format, .val = { .case_E_ec_point_format = buf0 } },
          .tl = res7
        }
      );
    res8 = buf1;
  }
  else
    res8 = res7;
  Prims_list__Extensions_extension_ *res9;
  if
  (
    FStar_List_Tot_Base_existsb__CipherSuite_cipherSuite_(Extensions_send_supported_groups,
      Extensions_list_valid_cs_is_list_cs(cs))
  )
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = {
            .tag = Extensions_E_supported_groups,
            .val = { .case_E_supported_groups = Extensions_list_valid_ng_is_list_ng(namedGroups) }
          },
          .tl = res8
        }
      );
    res9 = buf;
  }
  else
    res9 = res8;
  Prims_list__Extensions_extension_ *res10;
  if (pv.tag == Parsers_ProtocolVersion_TLS_1p3)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo), (uint32_t)1U);
    Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo));
    buf0[0U] = ((Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo){ .tag = Prims_Nil });
    if
    (
      __neq__Prims_list__K___FStar_Bytes_bytes_TLSConstants_pskInfo(FStar_List_Tot_Base_filter__FStar_Bytes_bytes___TLSConstants_pskInfo(Extensions_allow_resumption,
          psks),
        buf0)
    )
    {
      K___Prims_list__FStar_Bytes_bytes_Prims_list__TLSConstants_pskInfo
      uu____0 = FStar_List_Tot_Base_split__FStar_Bytes_bytes_TLSConstants_pskInfo(psks);
      Prims_list__TLSConstants_pskInfo *pskinfos = uu____0.snd;
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *psk_kex = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      psk_kex[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
      Prims_list__Extensions_psk_kex *psk_kex1;
      if
      (FStar_List_Tot_Base_existsb__TLSConstants_pskInfo(Extensions_allow_psk_resumption, pskinfos))
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf[0U]
        =
          (
            (Prims_list__Extensions_psk_kex){
              .tag = Prims_Cons,
              .hd = Extensions_PSK_KE,
              .tl = psk_kex
            }
          );
        psk_kex1 = buf;
      }
      else
        psk_kex1 = psk_kex;
      Prims_list__Extensions_psk_kex *psk_kex2;
      if
      (FStar_List_Tot_Base_existsb__TLSConstants_pskInfo(Extensions_allow_dhe_resumption, pskinfos))
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
        Prims_list__Extensions_psk_kex
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
        buf[0U]
        =
          (
            (Prims_list__Extensions_psk_kex){
              .tag = Prims_Cons,
              .hd = Extensions_PSK_DHE_KE,
              .tl = psk_kex1
            }
          );
        psk_kex2 = buf;
      }
      else
        psk_kex2 = psk_kex1;
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
      Prims_list__Extensions_extension_
      *res100 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
      res100[0U]
      =
        (
          (Prims_list__Extensions_extension_){
            .tag = Prims_Cons,
            .hd = {
              .tag = Extensions_E_psk_key_exchange_modes,
              .val = { .case_E_psk_key_exchange_modes = psk_kex2 }
            },
            .tl = res9
          }
        );
      Prims_int
      binder_len =
        FStar_List_Tot_Base_fold_left__Prims_int_TLSConstants_pskInfo(Extensions_compute_binder_len,
          (krml_checked_int_t)0,
          pskinfos);
      Prims_list__K___FStar_Bytes_bytes_uint32_t
      *pskidentities = Extensions_obfuscate_age(now, psks);
      Prims_list__Extensions_extension_ *res11;
      if (edi)
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
        Prims_list__Extensions_extension_
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
        buf[0U]
        =
          (
            (Prims_list__Extensions_extension_){
              .tag = Prims_Cons,
              .hd = {
                .tag = Extensions_E_early_data,
                .val = { .case_E_early_data = { .tag = FStar_Pervasives_Native_None } }
              },
              .tl = res100
            }
          );
        res11 = buf;
      }
      else
        res11 = res100;
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
      Prims_list__Extensions_extension_
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
      buf[0U]
      =
        (
          (Prims_list__Extensions_extension_){
            .tag = Prims_Cons,
            .hd = {
              .tag = Extensions_E_pre_shared_key,
              .val = {
                .case_E_pre_shared_key = {
                  .tag = Extensions_ClientPSK,
                  .val = {
                    .case_ClientPSK = { .identities = pskidentities, .binders_len = binder_len }
                  }
                }
              }
            },
            .tl = res11
          }
        );
      res10 = buf;
    }
    else
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf[0U] = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Nil });
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf0[0U]
      =
        (
          (Prims_list__Extensions_psk_kex){
            .tag = Prims_Cons,
            .hd = Extensions_PSK_DHE_KE,
            .tl = buf
          }
        );
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_psk_kex), (uint32_t)1U);
      Prims_list__Extensions_psk_kex
      *buf1 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_psk_kex));
      buf1[0U]
      = ((Prims_list__Extensions_psk_kex){ .tag = Prims_Cons, .hd = Extensions_PSK_KE, .tl = buf0 });
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
      Prims_list__Extensions_extension_
      *buf2 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
      buf2[0U]
      =
        (
          (Prims_list__Extensions_extension_){
            .tag = Prims_Cons,
            .hd = {
              .tag = Extensions_E_psk_key_exchange_modes,
              .val = { .case_E_psk_key_exchange_modes = buf1 }
            },
            .tl = res9
          }
        );
      res10 = buf2;
    }
  }
  else
    res10 = res9;
  Prims_list__Extensions_extension_
  *res11 = FStar_List_Tot_Base_rev__Extensions_extension_(res10);
  return res11;
}

bool
FStar_Pervasives_Native_uu___is_Some__Extensions_extension_(
  FStar_Pervasives_Native_option__Extensions_extension_ projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

FStar_Pervasives_Native_option__Extensions_extension_
List_Helpers_find_aux__Extensions_extension__Extensions_extension_(
  Extensions_extension_ env,
  bool (*f)(Extensions_extension_ x0, Extensions_extension_ x1),
  Prims_list__Extensions_extension_ *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Extensions_extension_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = l->tl;
    Extensions_extension_ hd1 = l->hd;
    if (f(env, hd1))
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return List_Helpers_find_aux__Extensions_extension__Extensions_extension_(env, f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
List_Helpers_exists_b_aux__Extensions_extension__Extensions_extension_(
  Extensions_extension_ env,
  bool (*f)(Extensions_extension_ x0, Extensions_extension_ x1),
  Prims_list__Extensions_extension_ *l
)
{
  return
    FStar_Pervasives_Native_uu___is_Some__Extensions_extension_(List_Helpers_find_aux__Extensions_extension__Extensions_extension_(env,
        f,
        l));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
FStar_Error_correct__Parsers_Alert_alert___Prims_string_Parsers_ProtocolVersion_protocolVersion(
  Parsers_ProtocolVersion_protocolVersion x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

Prims_string Extensions_string_of_extension____(Extensions_extension_ e)
{
  if (e.tag == Extensions_E_server_name)
    return "server_name";
  else if (e.tag == Extensions_E_supported_groups)
    return "supported_groups";
  else if (e.tag == Extensions_E_signature_algorithms)
    return "signature_algorithms";
  else if (e.tag == Extensions_E_signature_algorithms_cert)
    return "signature_algorithms_cert";
  else if (e.tag == Extensions_E_key_share)
    return "key_share";
  else if (e.tag == Extensions_E_pre_shared_key)
    return "pre_shared_key";
  else if (e.tag == Extensions_E_session_ticket)
    return "session_ticket";
  else if (e.tag == Extensions_E_early_data)
    return "early_data";
  else if (e.tag == Extensions_E_supported_versions)
    return "supported_versions";
  else if (e.tag == Extensions_E_cookie)
    return "cookie";
  else if (e.tag == Extensions_E_psk_key_exchange_modes)
    return "psk_key_exchange_modes";
  else if (e.tag == Extensions_E_extended_ms)
    return "extended_master_secret";
  else if (e.tag == Extensions_E_ec_point_format)
    return "ec_point_formats";
  else if (e.tag == Extensions_E_alpn)
    return "alpn";
  else if (e.tag == Extensions_E_unknown_extension)
  {
    FStar_Bytes_bytes n1 = e.val.case_E_unknown_extension.x;
    return FStar_Bytes_print_bytes(n1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct K___Parsers_ProtocolVersion_protocolVersion_Extensions_protocol_versions_s
{
  Parsers_ProtocolVersion_protocolVersion fst;
  Extensions_protocol_versions snd;
}
K___Parsers_ProtocolVersion_protocolVersion_Extensions_protocol_versions;

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
Extensions_serverToNegotiatedExtension(
  TLSConstants_config cfg,
  Prims_list__Extensions_extension_ *cExtL,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  bool resuming,
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
  res,
  Extensions_extension_ sExt
)
{
  if (res.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = res.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else if (res.tag == FStar_Error_Correct)
  {
    Parsers_ProtocolVersion_protocolVersion pv0 = res.val.case_Correct;
    if
    (
      !List_Helpers_exists_b_aux__Extensions_extension__Extensions_extension_(sExt,
        Extensions_sameExt____,
        cExtL)
    )
      return
        TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Unsupported_extension,
          FStar_Error_perror("Extensions.fst",
            (krml_checked_int_t)1290,
            "server sent an unexpected extension"));
    else if (sExt.tag == Extensions_E_supported_versions)
    {
      Extensions_protocol_versions v1 = sExt.val.case_E_supported_versions;
      K___Parsers_ProtocolVersion_protocolVersion_Extensions_protocol_versions
      scrut = { .fst = pv0, .snd = v1 };
      if (scrut.snd.tag == Extensions_ClientPV)
        return
          TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Illegal_parameter,
            FStar_Error_perror("Extensions.fst",
              (krml_checked_int_t)1308,
              "list of protocol versions in ServerHello"));
      else if
      (scrut.fst.tag == Parsers_ProtocolVersion_TLS_1p2 && scrut.snd.tag == Extensions_ServerPV)
      {
        Parsers_ProtocolVersion_protocolVersion pv = scrut.snd.val.case_ServerPV;
        return
          FStar_Error_correct__Parsers_Alert_alert___Prims_string_Parsers_ProtocolVersion_protocolVersion(pv);
      }
      else
        return
          TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Illegal_parameter,
            FStar_Error_perror("Extensions.fst",
              (krml_checked_int_t)1310,
              "failed extension-based version negotiation"));
    }
    else if (sExt.tag == Extensions_E_server_name)
      if (resuming)
        return
          TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Unsupported_extension,
            FStar_Error_perror("Extensions.fst",
              (krml_checked_int_t)1314,
              "server sent SNI acknowledge in resumption"));
      else
        return res;
    else if (sExt.tag == Extensions_E_session_ticket)
      return res;
    else if (sExt.tag == Extensions_E_alpn)
    {
      Prims_list__FStar_Bytes_bytes *sal = sExt.val.case_E_alpn;
      if (FStar_List_Tot_Base_length__FStar_Bytes_bytes(sal) == (krml_checked_int_t)1)
        return res;
      else
        return
          TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Illegal_parameter,
            FStar_Error_perror("Extensions.fst",
              (krml_checked_int_t)1318,
              "Multiple ALPN selected by server"));
    }
    else if (sExt.tag == Extensions_E_extended_ms)
      return res;
    else if (sExt.tag == Extensions_E_ec_point_format)
      return res;
    else if
    (
      sExt.tag
      == Extensions_E_key_share
      && sExt.val.case_E_key_share.tag == CommonDH_ServerKeyShare
    )
      return res;
    else if
    (
      sExt.tag
      == Extensions_E_pre_shared_key
      && sExt.val.case_E_pre_shared_key.tag == Extensions_ServerPSK
    )
      return res;
    else if (sExt.tag == Extensions_E_supported_groups)
      if (resuming)
        return
          TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Unsupported_extension,
            FStar_Error_perror("Extensions.fst",
              (krml_checked_int_t)1324,
              "server sent supported groups in resumption"));
      else
        return res;
    else
    {
      Extensions_extension_ e = sExt;
      return
        TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Handshake_failure,
          FStar_Error_perror("Extensions.fst",
            (krml_checked_int_t)1327,
            Prims_strcat("unhandled server extension: ", Extensions_string_of_extension____(e))));
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
Extensions_serverToNegotiatedExtensions_aux(
  TLSConstants_config cfg,
  Prims_list__Extensions_extension_ *cExtL,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  bool resuming,
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
  rpv,
  Prims_list__Extensions_extension_ *sExtL
)
{
  if (sExtL->tag == Prims_Nil)
    return rpv;
  else if (sExtL->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = sExtL->tl;
    Extensions_extension_ hd1 = sExtL->hd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
    scrut = Extensions_serverToNegotiatedExtension(cfg, cExtL, cs, ri, resuming, rpv, hd1);
    if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
      rpv1 = scrut;
      return Extensions_serverToNegotiatedExtensions_aux(cfg, cExtL, cs, ri, resuming, rpv1, tl1);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__Extensions_extension__s
{
  Parsers_ProtocolVersion_protocolVersion fst;
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ snd;
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ thd;
}
K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__Extensions_extension_;

bool
__neq__Parsers_ProtocolVersion_protocolVersion(
  Parsers_ProtocolVersion_protocolVersion y,
  Parsers_ProtocolVersion_protocolVersion x
)
{
  if (x.tag == Parsers_ProtocolVersion_SSL_3p0)
    if (y.tag == Parsers_ProtocolVersion_SSL_3p0)
      return false;
    else
      return true;
  else if (x.tag == Parsers_ProtocolVersion_TLS_1p0)
    if (y.tag == Parsers_ProtocolVersion_TLS_1p0)
      return false;
    else
      return true;
  else if (x.tag == Parsers_ProtocolVersion_TLS_1p1)
    if (y.tag == Parsers_ProtocolVersion_TLS_1p1)
      return false;
    else
      return true;
  else if (x.tag == Parsers_ProtocolVersion_TLS_1p2)
    if (y.tag == Parsers_ProtocolVersion_TLS_1p2)
      return false;
    else
      return true;
  else if (x.tag == Parsers_ProtocolVersion_TLS_1p3)
    if (y.tag == Parsers_ProtocolVersion_TLS_1p3)
      return false;
    else
      return true;
  else if (x.tag == Parsers_ProtocolVersion_Unknown_protocolVersion)
  {
    uint16_t x__0 = x._0;
    if (y.tag == Parsers_ProtocolVersion_Unknown_protocolVersion)
    {
      uint16_t y__0 = y._0;
      return false || y__0 != x__0;
    }
    else
      return true;
  }
  else
    return true;
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
Extensions_negotiateClientExtensions(
  Parsers_ProtocolVersion_protocolVersion pv,
  TLSConstants_config cfg,
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ cExtL,
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ sExtL,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  bool resuming
)
{
  K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
  scrut = { .fst = pv, .snd = cExtL, .thd = sExtL };
  if
  (
    scrut.fst.tag
    == Parsers_ProtocolVersion_SSL_3p0
    && scrut.thd.tag == FStar_Pervasives_Native_None
  )
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_ProtocolVersion_SSL_3p0 } }
        }
      );
  else if
  (
    scrut.fst.tag
    == Parsers_ProtocolVersion_SSL_3p0
    && scrut.thd.tag == FStar_Pervasives_Native_Some
  )
    return
      TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Internal_error,
        FStar_Error_perror("Extensions.fst",
          (krml_checked_int_t)1342,
          "Received extensions in SSL 3.0 ServerHello"));
  else if (scrut.snd.tag == FStar_Pervasives_Native_None)
    return
      TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Internal_error,
        FStar_Error_perror("Extensions.fst",
          (krml_checked_int_t)1343,
          "negotiation failed: missing extensions in TLS ClientHello (shouldn\'t happen)"));
  else if (scrut.thd.tag == FStar_Pervasives_Native_None)
  {
    Parsers_ProtocolVersion_protocolVersion pv1 = scrut.fst;
    if
    (
      __neq__Parsers_ProtocolVersion_protocolVersion(pv1,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
    )
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = pv1 }
          }
        );
    else
      return
        TLSError_fatal__Parsers_ProtocolVersion_protocolVersion(Parsers_AlertDescription_Internal_error,
          FStar_Error_perror("Extensions.fst",
            (krml_checked_int_t)1344,
            "Cannot negotiate TLS 1.3 explicitly"));
  }
  else if
  (
    scrut.snd.tag
    == FStar_Pervasives_Native_Some
    && scrut.thd.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__Extensions_extension_ *sExtL1 = scrut.thd.v;
    Prims_list__Extensions_extension_ *cExtL1 = scrut.snd.v;
    Parsers_ProtocolVersion_protocolVersion pv1 = scrut.fst;
    return
      Extensions_serverToNegotiatedExtensions_aux(cfg,
        cExtL1,
        cs,
        ri,
        resuming,
        FStar_Error_correct__Parsers_Alert_alert___Prims_string_Parsers_ProtocolVersion_protocolVersion(pv1),
        sExtL1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__FStar_Bytes_bytes
*List_Helpers_filter_aux__FStar_Bytes_bytes_Prims_list_FStar_Bytes_bytes(
  Prims_list__FStar_Bytes_bytes *env,
  bool (*f)(Prims_list__FStar_Bytes_bytes *x0, FStar_Bytes_bytes x1),
  Prims_list__FStar_Bytes_bytes *l
)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
    return buf;
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *tl1 = l->tl;
    FStar_Bytes_bytes hd1 = l->hd;
    if (f(env, hd1))
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
      Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
      buf[0U]
      =
        (
          (Prims_list__FStar_Bytes_bytes){
            .tag = Prims_Cons,
            .hd = hd1,
            .tl = List_Helpers_filter_aux__FStar_Bytes_bytes_Prims_list_FStar_Bytes_bytes(env,
              f,
              tl1)
          }
        );
      return buf;
    }
    else
      return List_Helpers_filter_aux__FStar_Bytes_bytes_Prims_list_FStar_Bytes_bytes(env, f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
FStar_List_Tot_Base_mem__FStar_Bytes_bytes(
  FStar_Bytes_bytes x,
  Prims_list__FStar_Bytes_bytes *uu___7_953
)
{
  if (uu___7_953->tag == Prims_Nil)
    return false;
  else if (uu___7_953->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *tl1 = uu___7_953->tl;
    FStar_Bytes_bytes hd1 = uu___7_953->hd;
    if (__eq__FStar_Bytes_bytes(hd1, x))
      return true;
    else
      return FStar_List_Tot_Base_mem__FStar_Bytes_bytes(x, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
List_Helpers_mem_rev__FStar_Bytes_bytes(Prims_list__FStar_Bytes_bytes *l, FStar_Bytes_bytes x)
{
  return FStar_List_Tot_Base_mem__FStar_Bytes_bytes(x, l);
}

typedef struct FStar_Pervasives_Native_option__TLSConstants_serverName_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  TLSConstants_serverName v;
}
FStar_Pervasives_Native_option__TLSConstants_serverName;

static FStar_Pervasives_Native_option__TLSConstants_serverName
FStar_List_Tot_Base_tryFind__TLSConstants_serverName(
  bool (*p)(TLSConstants_serverName x0),
  Prims_list__TLSConstants_serverName *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__TLSConstants_serverName){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__TLSConstants_serverName *tl1 = l->tl;
    TLSConstants_serverName hd1 = l->hd;
    if (p(hd1))
      return
        (
          (FStar_Pervasives_Native_option__TLSConstants_serverName){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return FStar_List_Tot_Base_tryFind__TLSConstants_serverName(p, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
FStar_Pervasives_Native_uu___is_Some__uint32_t(
  FStar_Pervasives_Native_option__uint32_t projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

bool
__eq__FStar_Pervasives_Native_option__Prims_int(
  FStar_Pervasives_Native_option__Prims_int y,
  FStar_Pervasives_Native_option__Prims_int x
)
{
  if (x.tag == FStar_Pervasives_Native_None)
    if (y.tag == FStar_Pervasives_Native_None)
      return true;
    else
      return false;
  else if (x.tag == FStar_Pervasives_Native_Some)
  {
    Prims_int x_v = x.v;
    if (y.tag == FStar_Pervasives_Native_Some)
    {
      Prims_int y_v = y.v;
      return true && y_v == x_v;
    }
    else
      return false;
  }
  else
    return false;
}

static FStar_Pervasives_Native_option__Extensions_extension_
Extensions_clientToServerExtension(
  Parsers_ProtocolVersion_protocolVersion pv,
  TLSConstants_config cfg,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  FStar_Pervasives_Native_option__Prims_int pski,
  FStar_Pervasives_Native_option__CommonDH_keyShare ks,
  bool resuming,
  Extensions_extension_ cext
)
{
  if (cext.tag == Extensions_E_supported_versions)
    if
    (
      __eq__Parsers_ProtocolVersion_protocolVersion(pv,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = {
              .tag = Extensions_E_supported_versions,
              .val = {
                .case_E_supported_versions = {
                  .tag = Extensions_ServerPV,
                  .val = { .case_ServerPV = pv }
                }
              }
            }
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
  else if (cext.tag == Extensions_E_key_share)
    if
    (
      __eq__Parsers_ProtocolVersion_protocolVersion(pv,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
    )
      if (ks.tag == FStar_Pervasives_Native_Some)
      {
        CommonDH_keyShare x = ks.v;
        return
          (
            (FStar_Pervasives_Native_option__Extensions_extension_){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .tag = Extensions_E_key_share, .val = { .case_E_key_share = x } }
            }
          );
      }
      else if (ks.tag == FStar_Pervasives_Native_None)
        return
          (
            (FStar_Pervasives_Native_option__Extensions_extension_){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    else
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
  else if (cext.tag == Extensions_E_alpn)
  {
    Prims_list__FStar_Bytes_bytes *cal = cext.val.case_E_alpn;
    if (cfg.alpn.tag == FStar_Pervasives_Native_None)
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (cfg.alpn.tag == FStar_Pervasives_Native_Some)
    {
      Prims_list__FStar_Bytes_bytes *sal = cfg.alpn.v;
      Prims_list__FStar_Bytes_bytes
      *common =
        List_Helpers_filter_aux__FStar_Bytes_bytes_Prims_list_FStar_Bytes_bytes(sal,
          List_Helpers_mem_rev__FStar_Bytes_bytes,
          cal);
      if (common->tag == Prims_Cons)
      {
        FStar_Bytes_bytes a = common->hd;
        KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
        Prims_list__FStar_Bytes_bytes
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
        buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
        KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
        Prims_list__FStar_Bytes_bytes
        *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
        buf0[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Cons, .hd = a, .tl = buf });
        return
          (
            (FStar_Pervasives_Native_option__Extensions_extension_){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .tag = Extensions_E_alpn, .val = { .case_E_alpn = buf0 } }
            }
          );
      }
      else
        return
          (
            (FStar_Pervasives_Native_option__Extensions_extension_){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (cext.tag == Extensions_E_server_name)
  {
    Prims_list__TLSConstants_serverName *server_name_list = cext.val.case_E_server_name;
    if (resuming)
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
    {
      FStar_Pervasives_Native_option__TLSConstants_serverName
      scrut =
        FStar_List_Tot_Base_tryFind__TLSConstants_serverName(TLSConstants_uu___is_SNI_DNS,
          server_name_list);
      if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__TLSConstants_serverName), (uint32_t)1U);
        Prims_list__TLSConstants_serverName
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__TLSConstants_serverName));
        buf[0U] = ((Prims_list__TLSConstants_serverName){ .tag = Prims_Nil });
        return
          (
            (FStar_Pervasives_Native_option__Extensions_extension_){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .tag = Extensions_E_server_name, .val = { .case_E_server_name = buf } }
            }
          );
      }
      else
        return
          (
            (FStar_Pervasives_Native_option__Extensions_extension_){
              .tag = FStar_Pervasives_Native_None
            }
          );
    }
  }
  else if (cext.tag == Extensions_E_extended_ms)
    if
    (
      __eq__Parsers_ProtocolVersion_protocolVersion(pv,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
      || !cfg.extended_master_secret
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .tag = Extensions_E_extended_ms }
          }
        );
  else if (cext.tag == Extensions_E_ec_point_format)
    if
    (
      __eq__Parsers_ProtocolVersion_protocolVersion(pv,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
    {
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_point_format), (uint32_t)1U);
      Prims_list__Extensions_point_format
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_point_format));
      buf[0U] = ((Prims_list__Extensions_point_format){ .tag = Prims_Nil });
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_point_format), (uint32_t)1U);
      Prims_list__Extensions_point_format
      *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_point_format));
      buf0[0U]
      =
        (
          (Prims_list__Extensions_point_format){
            .tag = Prims_Cons,
            .hd = { .tag = Extensions_ECP_UNCOMPRESSED },
            .tl = buf
          }
        );
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .tag = Extensions_E_ec_point_format, .val = { .case_E_ec_point_format = buf0 } }
          }
        );
    }
  else if (cext.tag == Extensions_E_pre_shared_key)
    if
    (
      __eq__FStar_Pervasives_Native_option__Prims_int(pski,
        ((FStar_Pervasives_Native_option__Prims_int){ .tag = FStar_Pervasives_Native_None }))
      ||
        __neq__Parsers_ProtocolVersion_protocolVersion(pv,
          ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
    {
      Prims_int x;
      if (pski.tag == FStar_Pervasives_Native_Some)
        x = pski.v;
      else
        x = KRML_EABORT(Prims_int, "unreachable (pattern matches are exhaustive in F*)");
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = {
              .tag = Extensions_E_pre_shared_key,
              .val = {
                .case_E_pre_shared_key = {
                  .tag = Extensions_ServerPSK,
                  .val = { .case_ServerPSK = FStar_UInt16_uint_to_t(x) }
                }
              }
            }
          }
        );
    }
  else if (cext.tag == Extensions_E_supported_groups)
    if
    (
      __eq__Parsers_ProtocolVersion_protocolVersion(pv,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = {
              .tag = Extensions_E_supported_groups,
              .val = {
                .case_E_supported_groups = Extensions_list_valid_ng_is_list_ng(cfg.named_groups)
              }
            }
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
  else if (cext.tag == Extensions_E_early_data)
    if
    (
      FStar_Pervasives_Native_uu___is_Some__uint32_t(cfg.max_early_data)
      &&
        __eq__FStar_Pervasives_Native_option__Prims_int(pski,
          (
            (FStar_Pervasives_Native_option__Prims_int){
              .tag = FStar_Pervasives_Native_Some,
              .v = (krml_checked_int_t)0
            }
          ))
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = {
              .tag = Extensions_E_early_data,
              .val = { .case_E_early_data = { .tag = FStar_Pervasives_Native_None } }
            }
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
  else if (cext.tag == Extensions_E_session_ticket)
    if
    (
      __eq__Parsers_ProtocolVersion_protocolVersion(pv,
        ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
      || !cfg.enable_tickets
    )
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__Extensions_extension_){
            .tag = FStar_Pervasives_Native_Some,
            .v = {
              .tag = Extensions_E_session_ticket,
              .val = { .case_E_session_ticket = FStar_Bytes_empty_bytes }
            }
          }
        );
  else
    return
      (
        (FStar_Pervasives_Native_option__Extensions_extension_){
          .tag = FStar_Pervasives_Native_None
        }
      );
}

static Prims_list__Extensions_extension_
*Extensions_choose_clientToServerExtension(
  Parsers_ProtocolVersion_protocolVersion pv,
  TLSConstants_config cfg,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  FStar_Pervasives_Native_option__Prims_int pski,
  FStar_Pervasives_Native_option__CommonDH_keyShare ks,
  bool resuming,
  Prims_list__Extensions_extension_ *cExtL
)
{
  if (cExtL->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
    return buf;
  }
  else if (cExtL->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *cExtL1 = cExtL->tl;
    Extensions_extension_ hd1 = cExtL->hd;
    FStar_Pervasives_Native_option__Extensions_extension_
    scrut = Extensions_clientToServerExtension(pv, cfg, cs, ri, pski, ks, resuming, hd1);
    if (scrut.tag == FStar_Pervasives_Native_None)
      return Extensions_choose_clientToServerExtension(pv, cfg, cs, ri, pski, ks, resuming, cExtL1);
    else if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      Extensions_extension_ e = scrut.v;
      KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
      Prims_list__Extensions_extension_
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
      buf[0U]
      =
        (
          (Prims_list__Extensions_extension_){
            .tag = Prims_Cons,
            .hd = e,
            .tl = Extensions_choose_clientToServerExtension(pv,
              cfg,
              cs,
              ri,
              pski,
              ks,
              resuming,
              cExtL1)
          }
        );
      return buf;
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
TLSError_fatal__FStar_Pervasives_Native_option_Prims_list_Extensions_extension_(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
Extensions_negotiateServerExtensions(
  Parsers_ProtocolVersion_protocolVersion pv,
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ cExtL,
  Prims_list__Parsers_CipherSuite_cipherSuite *csl,
  TLSConstants_config cfg,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ri,
  FStar_Pervasives_Native_option__Prims_int pski,
  FStar_Pervasives_Native_option__CommonDH_keyShare ks,
  bool resuming
)
{
  if (cExtL.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *cExtL1 = cExtL.v;
    Prims_list__Extensions_extension_
    *sexts = Extensions_choose_clientToServerExtension(pv, cfg, cs, ri, pski, ks, resuming, cExtL1);
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = FStar_Pervasives_Native_Some, .v = sexts } }
        }
      );
  }
  else if (cExtL.tag == FStar_Pervasives_Native_None)
    return
      TLSError_fatal__FStar_Pervasives_Native_option_Prims_list_Extensions_extension_(Parsers_AlertDescription_Internal_error,
        FStar_Error_perror("Extensions.fst",
          (krml_checked_int_t)1435,
          "No extensions in ClientHello"));
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__Parsers_SignatureScheme_signatureScheme
*Extensions_default_signatureScheme(
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_cipherSuite_ cs
)
{
  switch (CipherSuite_sigAlg_of_ciphersuite(cs))
  {
    case CipherSuite_ECDSA:
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme), (uint32_t)1U);
        Prims_list__Parsers_SignatureScheme_signatureScheme
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme));
        buf[0U] = ((Prims_list__Parsers_SignatureScheme_signatureScheme){ .tag = Prims_Nil });
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme), (uint32_t)1U);
        Prims_list__Parsers_SignatureScheme_signatureScheme
        *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme));
        buf0[0U]
        =
          (
            (Prims_list__Parsers_SignatureScheme_signatureScheme){
              .tag = Prims_Cons,
              .hd = { .tag = Parsers_SignatureScheme_Ecdsa_sha1 },
              .tl = buf
            }
          );
        return buf0;
      }
    default:
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme), (uint32_t)1U);
        Prims_list__Parsers_SignatureScheme_signatureScheme
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme));
        buf[0U] = ((Prims_list__Parsers_SignatureScheme_signatureScheme){ .tag = Prims_Nil });
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme), (uint32_t)1U);
        Prims_list__Parsers_SignatureScheme_signatureScheme
        *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme));
        buf0[0U]
        =
          (
            (Prims_list__Parsers_SignatureScheme_signatureScheme){
              .tag = Prims_Cons,
              .hd = { .tag = Parsers_SignatureScheme_Rsa_pkcs1_sha1 },
              .tl = buf
            }
          );
        return buf0;
      }
  }
}

