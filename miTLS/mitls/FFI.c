/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "FFI.h"

void FFI_discard(bool uu____12)
{
  
}

void FFI_print(Prims_string s)
{
  FFI_discard(FStar_IO_debug_print_string(Prims_strcat("FFI| ", Prims_strcat(s, "\n"))));
}

void (*FFI_trace)(Prims_string x0) = FFI_print;

static FStar_Bytes_bytes FFI_fragment_1(TLSInfo_id i1, FStar_Bytes_bytes b)
{
  K___Prims_int_Prims_int rg1 = TLS_point(FStar_UInt32_v(FStar_Bytes_len(b)));
  return DataStream_appFragment(i1, rg1, b);
}

static FStar_Bytes_bytes FFI_sub(FStar_Bytes_bytes buffer, Prims_int first, Prims_int len1)
{
  K___FStar_Bytes_bytes_FStar_Bytes_bytes
  scrut = FStar_Bytes_split(buffer, FStar_UInt32_uint_to_t(first));
  K___FStar_Bytes_bytes_FStar_Bytes_bytes
  scrut0 = FStar_Bytes_split(buffer, FStar_UInt32_uint_to_t(len1));
  return scrut0.fst;
}

static TLS_ioresult_w
FFI_write_all_(
  Connection_connection c,
  TLSInfo_id i1,
  FStar_Bytes_bytes buffer,
  Prims_int sent
)
{
  if (sent == FStar_UInt32_v(FStar_Bytes_len(buffer)))
    return ((TLS_ioresult_w){ .tag = TLS_Written });
  else
  {
    Prims_int
    size1 =
      DataStream_min(Prims_op_Subtraction(FStar_UInt32_v(FStar_Bytes_len(buffer)), sent),
        TLSConstants_max_TLSPlaintext_fragment_length);
    FStar_Bytes_bytes payload = FFI_sub(buffer, sent, size1);
    K___Prims_int_Prims_int rg1 = TLS_point(FStar_UInt32_v(FStar_Bytes_len(payload)));
    FStar_Bytes_bytes f = FFI_fragment_1(i1, payload);
    TLS_ioresult_w scrut = TLS_write(c, i1, rg1, f);
    if (scrut.tag == TLS_Written)
      return FFI_write_all_(c, i1, buffer, Prims_op_Addition(sent, size1));
    else
      return scrut;
  }
}

static TLS_ioresult_w
FFI_write_all(Connection_connection c, TLSInfo_id i1, FStar_Bytes_bytes b)
{
  return FFI_write_all_(c, i1, b, (krml_checked_int_t)0);
}

static Prims_int
FFI_errno(FStar_Pervasives_Native_option__Parsers_Alert_alert description, Prims_string txt)
{
  Prims_string txt0;
  if (description.tag == FStar_Pervasives_Native_Some)
  {
    Parsers_Alert_alert ad = description.v;
    txt0 = TLSError_string_of_alert(ad);
  }
  else if (description.tag == FStar_Pervasives_Native_None)
    txt0 = "(None)";
  else
    txt0 = KRML_EABORT(Prims_string, "unreachable (pattern matches are exhaustive in F*)");
  FFI_print(Prims_strcat("returning error: ",
      Prims_strcat(txt0, Prims_strcat(" ", Prims_strcat(txt, "\n")))));
  if (description.tag == FStar_Pervasives_Native_Some)
  {
    Parsers_Alert_alert ad = description.v;
    return FStar_Bytes_int_of_bytes(Alert_alertBytes(ad));
  }
  else if (description.tag == FStar_Pervasives_Native_None)
    return (krml_checked_int_t)-1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

K___Connection_connection_Prims_int
FFI_connect(
  FStar_Dyn_dyn ctx,
  int32_t (*send1)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  int32_t (*recv1)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  TLSConstants_config config_1
)
{
  Transport_t tcp = Transport_callbacks(ctx, send1, recv1);
  Connection_connection c = TLS_connect(tcp, config_1);
  FStar_Pervasives_Native_option__Prims_int err = { .tag = FStar_Pervasives_Native_None };
  while (true)
  {
    TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Reader);
    TLS_ioresult_i read_r = TLS_read(c, i1);
    FFI_print(Prims_strcat("Read returned ", TLS_string_of_ioresult_i(i1, read_r)));
    bool ite;
    if (read_r.tag == TLS_Update && read_r.val.case_Update == false)
      ite = false;
    else if (read_r.tag == TLS_ReadAgain)
      ite = false;
    else if (read_r.tag == TLS_ReadAgainFinishing)
      ite = false;
    else if (read_r.tag == TLS_ReadWouldBlock)
      ite = false;
    else if (read_r.tag == TLS_Complete)
    {
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = (krml_checked_int_t)0
          }
        );
      ite = true;
    }
    else if (read_r.tag == TLS_Update && read_r.val.case_Update == true)
    {
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = (krml_checked_int_t)0
          }
        );
      ite = true;
    }
    else if (read_r.tag == TLS_Read && read_r.val.case_Read.tag == DataStream_Alert)
    {
      Parsers_Alert_alert a = read_r.val.case_Read.val.case_Alert;
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = FFI_errno((
                (FStar_Pervasives_Native_option__Parsers_Alert_alert){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = a
                }
              ),
              Prims_strcat("received ",
                Prims_strcat(TLSError_string_of_alert(a), " alert from peer")))
          }
        );
      ite = true;
    }
    else if (read_r.tag == TLS_ReadError)
    {
      Prims_string txt = read_r.val.case_ReadError.txt;
      FStar_Pervasives_Native_option__Parsers_Alert_alert description = read_r.val.case_ReadError.o;
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = FFI_errno(description, txt)
          }
        );
      ite = true;
    }
    else
    {
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = FFI_errno((
                (FStar_Pervasives_Native_option__Parsers_Alert_alert){
                  .tag = FStar_Pervasives_Native_None
                }
              ),
              "unhandled ioresult_i")
          }
        );
      ite = true;
    }
    if (ite)
      break;
  }
  FStar_Pervasives_Native_option__Prims_int scrut = err;
  Prims_int firstResult;
  if (scrut.tag == FStar_Pervasives_Native_Some)
    firstResult = scrut.v;
  else
    firstResult = KRML_EABORT(Prims_int, "FFI: Unexpected TLS read signal in connect");
  return ((K___Connection_connection_Prims_int){ .fst = c, .snd = firstResult });
}

FStar_Bytes_bytes FFI_getCert(Connection_connection c)
{
  Negotiation_mode mode = TLS_get_mode(c);
  if
  (
    mode.n_server_cert.tag
    == FStar_Pervasives_Native_Some
    && mode.n_server_cert.v.fst->tag == Prims_Cons
  )
    return mode.n_server_cert.v.fst->hd.fst;
  else
    return FStar_Bytes_empty_bytes;
}

K___Connection_connection_Prims_int
FFI_accept_connected(
  FStar_Dyn_dyn ctx,
  int32_t (*send1)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  int32_t (*recv1)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  TLSConstants_config config_1
)
{
  Transport_t tcp = Transport_callbacks(ctx, send1, recv1);
  Connection_connection c = TLS_accept_connected(tcp, config_1);
  FStar_Pervasives_Native_option__Prims_int err = { .tag = FStar_Pervasives_Native_None };
  while (true)
  {
    TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Reader);
    TLS_ioresult_i read_r = TLS_read(c, i1);
    FFI_print(Prims_strcat("Read returned ", TLS_string_of_ioresult_i(i1, read_r)));
    bool ite;
    if (read_r.tag == TLS_Update && read_r.val.case_Update == false)
      ite = false;
    else if (read_r.tag == TLS_ReadAgain)
      ite = false;
    else if (read_r.tag == TLS_ReadAgainFinishing)
      ite = false;
    else if (read_r.tag == TLS_ReadWouldBlock)
      ite = false;
    else if (read_r.tag == TLS_Complete)
    {
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = (krml_checked_int_t)0
          }
        );
      ite = true;
    }
    else if (read_r.tag == TLS_Update && read_r.val.case_Update == true)
    {
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = (krml_checked_int_t)0
          }
        );
      ite = true;
    }
    else if (read_r.tag == TLS_Read && read_r.val.case_Read.tag == DataStream_Alert)
    {
      Parsers_Alert_alert a = read_r.val.case_Read.val.case_Alert;
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = FFI_errno((
                (FStar_Pervasives_Native_option__Parsers_Alert_alert){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = a
                }
              ),
              Prims_strcat("received ",
                Prims_strcat(TLSError_string_of_alert(a), " alert from peer")))
          }
        );
      ite = true;
    }
    else if (read_r.tag == TLS_ReadError)
    {
      Prims_string txt = read_r.val.case_ReadError.txt;
      FStar_Pervasives_Native_option__Parsers_Alert_alert description = read_r.val.case_ReadError.o;
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = FFI_errno(description, txt)
          }
        );
      ite = true;
    }
    else
    {
      err =
        (
          (FStar_Pervasives_Native_option__Prims_int){
            .tag = FStar_Pervasives_Native_Some,
            .v = FFI_errno((
                (FStar_Pervasives_Native_option__Parsers_Alert_alert){
                  .tag = FStar_Pervasives_Native_None
                }
              ),
              "unhandled ioresult_i")
          }
        );
      ite = true;
    }
    if (ite)
      break;
  }
  FStar_Pervasives_Native_option__Prims_int scrut = err;
  Prims_int firstResult;
  if (scrut.tag == FStar_Pervasives_Native_Some)
    firstResult = scrut.v;
  else if (scrut.tag == FStar_Pervasives_Native_None)
    firstResult = KRML_EABORT(Prims_int, "FFI: Unexpected TLS read signal in accept_connected");
  else
    firstResult = KRML_EABORT(Prims_int, "unreachable (pattern matches are exhaustive in F*)");
  return ((K___Connection_connection_Prims_int){ .fst = c, .snd = firstResult });
}

bool FFI_uu___is_Received(FFI_read_result projectee)
{
  if (projectee.tag == FFI_Received)
    return true;
  else
    return false;
}

FStar_Bytes_bytes FFI___proj__Received__item___0(FFI_read_result projectee)
{
  if (projectee.tag == FFI_Received)
    return projectee.val.case_Received;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool FFI_uu___is_WouldBlock(FFI_read_result projectee)
{
  if (projectee.tag == FFI_WouldBlock)
    return true;
  else
    return false;
}

bool FFI_uu___is_Errno(FFI_read_result projectee)
{
  if (projectee.tag == FFI_Errno)
    return true;
  else
    return false;
}

Prims_int FFI___proj__Errno__item___0(FFI_read_result projectee)
{
  if (projectee.tag == FFI_Errno)
    return projectee.val.case_Errno;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FFI_read_result FFI_read(Connection_connection c)
{
  TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Reader);
  TLS_ioresult_i scrut = TLS_read(c, i1);
  if (scrut.tag == TLS_Complete)
    return FFI_read(c);
  else if (scrut.tag == TLS_Read && scrut.val.case_Read.tag == DataStream_Data)
  {
    FStar_Bytes_bytes d = scrut.val.case_Read.val.case_Data;
    return
      (
        (FFI_read_result){
          .tag = FFI_Received,
          .val = { .case_Received = DataStream_appBytes(i1, Range_fragment_range, d) }
        }
      );
  }
  else if (scrut.tag == TLS_Read && scrut.val.case_Read.tag == DataStream_Close)
    return ((FFI_read_result){ .tag = FFI_Errno, .val = { .case_Errno = (krml_checked_int_t)0 } });
  else if (scrut.tag == TLS_Read && scrut.val.case_Read.tag == DataStream_Alert)
  {
    Parsers_Alert_alert a = scrut.val.case_Read.val.case_Alert;
    return
      (
        (FFI_read_result){
          .tag = FFI_Errno,
          .val = {
            .case_Errno = FFI_errno((
                (FStar_Pervasives_Native_option__Parsers_Alert_alert){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = a
                }
              ),
              "alert")
          }
        }
      );
  }
  else if (scrut.tag == TLS_ReadError)
  {
    Prims_string txt = scrut.val.case_ReadError.txt;
    FStar_Pervasives_Native_option__Parsers_Alert_alert description = scrut.val.case_ReadError.o;
    return
      ((FFI_read_result){ .tag = FFI_Errno, .val = { .case_Errno = FFI_errno(description, txt) } });
  }
  else if (scrut.tag == TLS_ReadWouldBlock)
    return ((FFI_read_result){ .tag = FFI_WouldBlock });
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unexpected FFI read result");
    KRML_HOST_EXIT(255U);
  }
}

Prims_int FFI_write(Connection_connection c, FStar_Bytes_bytes msg)
{
  TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Writer);
  TLS_ioresult_w scrut = FFI_write_all(c, i1, msg);
  if (scrut.tag == TLS_Written)
    return (krml_checked_int_t)0;
  else if (scrut.tag == TLS_WriteError)
  {
    Prims_string txt = scrut.val.case_WriteError.txt;
    FStar_Pervasives_Native_option__Parsers_Alert_alert description = scrut.val.case_WriteError.o;
    return FFI_errno(description, txt);
  }
  else
    return (krml_checked_int_t)-1;
}

Prims_int FFI_close(Connection_connection c)
{
  FFI_print("FFI close\n");
  TLS_ioresult_w scrut = TLS_writeCloseNotify(c);
  if (scrut.tag == TLS_WriteClose)
    return (krml_checked_int_t)0;
  else if (scrut.tag == TLS_WriteError)
  {
    Prims_string txt = scrut.val.case_WriteError.txt;
    FStar_Pervasives_Native_option__Parsers_Alert_alert description = scrut.val.case_WriteError.o;
    return FFI_errno(description, txt);
  }
  else
    return (krml_checked_int_t)-1;
}

Prims_int FFI_close_extraction_bug(Connection_connection c)
{
  TLS_ioresult_w uu____0 = TLS_writeCloseNotify(c);
  return (krml_checked_int_t)0;
}

Parsers_ProtocolVersion_protocolVersion FFI_s2pv(Prims_string s)
{
  if (__eq__Prims_string(s, "1.2"))
    return ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p2 });
  else if (__eq__Prims_string(s, "1.3"))
    return ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 });
  else if (__eq__Prims_string(s, "1.1"))
    return ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p1 });
  else if (__eq__Prims_string(s, "1.0"))
    return ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p0 });
  else
  {
    FStar_HyperStack_IO_print_string(Prims_strcat("Invalid protocol version specified: ", s));
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__K___Prims_string_Parsers_CipherSuite_cipherSuite *FFI_css;

Prims_list__K___Prims_string_Parsers_SignatureScheme_signatureScheme *FFI_sas;

Prims_list__K___Prims_string_Parsers_NamedGroup_namedGroup *FFI_ngs;

Prims_list__K___Prims_string_EverCrypt_aead_alg *FFI_aeads;

TLSConstants_config FFI_ffiConfig(Prims_string version1, FStar_Bytes_bytes host)
{
  Parsers_ProtocolVersion_protocolVersion v1 = FFI_s2pv(version1);
  FStar_Pervasives_Native_option__FStar_Bytes_bytes h1;
  if (FStar_UInt32_v(FStar_Bytes_len(host)) == (krml_checked_int_t)0)
    h1 =
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  else
    h1 =
      (
        (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = host
        }
      );
  TLSConstants_config uu____0 = TLSInfo_defaultConfig;
  return
    (
      (TLSConstants_config){
        .min_version = { .tag = Parsers_ProtocolVersion_TLS_1p2 },
        .max_version = v1,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = h1
      }
    );
}

TLSConstants_config FFI_updatecfg(TLSConstants_config cfg, Prims_list__Prims_string *l)
{
  if (l->tag == Prims_Nil)
    return cfg;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Prims_string *t = l->tl;
    Prims_string hd1 = l->hd;
    if (__eq__Prims_string(hd1, "EDI"))
    {
      TLSConstants_config uu____0 = cfg;
      return
        FFI_updatecfg((
            (TLSConstants_config){
              .min_version = uu____0.min_version,
              .max_version = uu____0.max_version,
              .is_quic = uu____0.is_quic,
              .cipher_suites = uu____0.cipher_suites,
              .named_groups = uu____0.named_groups,
              .signature_algorithms = uu____0.signature_algorithms,
              .hello_retry = uu____0.hello_retry,
              .offer_shares = uu____0.offer_shares,
              .custom_extensions = uu____0.custom_extensions,
              .use_tickets = uu____0.use_tickets,
              .send_ticket = uu____0.send_ticket,
              .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
              .request_client_certificate = uu____0.request_client_certificate,
              .non_blocking_read = uu____0.non_blocking_read,
              .max_early_data = { .tag = FStar_Pervasives_Native_Some, .v = (uint32_t)0x1000U },
              .max_ticket_age = uu____0.max_ticket_age,
              .safe_renegotiation = uu____0.safe_renegotiation,
              .extended_master_secret = uu____0.extended_master_secret,
              .enable_tickets = uu____0.enable_tickets,
              .ticket_callback = uu____0.ticket_callback,
              .nego_callback = uu____0.nego_callback,
              .cert_callbacks = uu____0.cert_callbacks,
              .alpn = uu____0.alpn,
              .peer_name = uu____0.peer_name
            }
          ),
          t);
    }
    else
    {
      FStar_HyperStack_IO_print_string(Prims_strcat("Unknown flag: ", hd1));
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__Parsers_CipherSuite_cipherSuite
FFI_findsetting__Prims_string_Parsers_CipherSuite_cipherSuite(
  Prims_string f,
  Prims_list__K___Prims_string_Parsers_CipherSuite_cipherSuite *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___Prims_string_Parsers_CipherSuite_cipherSuite *tl1 = l->tl;
    Parsers_CipherSuite_cipherSuite i1 = l->hd.snd;
    Prims_string s = l->hd.fst;
    if (__eq__Prims_string(s, f))
      return
        (
          (FStar_Pervasives_Native_option__Parsers_CipherSuite_cipherSuite){
            .tag = FStar_Pervasives_Native_Some,
            .v = i1
          }
        );
    else
      return FFI_findsetting__Prims_string_Parsers_CipherSuite_cipherSuite(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Parsers_CipherSuite_cipherSuite FFI_findSetting_css(Prims_string x)
{
  FStar_Pervasives_Native_option__Parsers_CipherSuite_cipherSuite
  scrut = FFI_findsetting__Prims_string_Parsers_CipherSuite_cipherSuite(x, FFI_css);
  if (scrut.tag == FStar_Pervasives_Native_None)
  {
    FStar_HyperStack_IO_print_string(Prims_strcat("Unknown ciphersuite: ", x));
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
    KRML_HOST_EXIT(255U);
  }
  else if (scrut.tag == FStar_Pervasives_Native_Some)
    return scrut.v;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__Prims_string *FFI_split_string(FStar_Char_char c, Prims_string x)
{
  Prims_int i1 = FStar_String_index_of(x, c);
  if (Prims_op_LessThan(i1, (krml_checked_int_t)0))
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_string), (uint32_t)1U);
    Prims_list__Prims_string *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_string));
    buf[0U] = ((Prims_list__Prims_string){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_string), (uint32_t)1U);
    Prims_list__Prims_string *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_string));
    buf0[0U] = ((Prims_list__Prims_string){ .tag = Prims_Cons, .hd = x, .tl = buf });
    return buf0;
  }
  else
  {
    Prims_string prefix = FStar_String_substring(x, (krml_checked_int_t)0, i1);
    Prims_string
    suffix =
      FStar_String_substring(x,
        Prims_op_Addition(i1, (krml_checked_int_t)1),
        Prims_op_Subtraction(FStar_String_strlen(x), Prims_op_Addition(i1, (krml_checked_int_t)1)));
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_string), (uint32_t)1U);
    Prims_list__Prims_string *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_string));
    buf[0U]
    =
      (
        (Prims_list__Prims_string){
          .tag = Prims_Cons,
          .hd = prefix,
          .tl = FFI_split_string(c, suffix)
        }
      );
    return buf;
  }
}

Prims_list__Parsers_CipherSuite_cipherSuite
*FFI_map__Prims_string_Parsers_CipherSuite_cipherSuite(
  Parsers_CipherSuite_cipherSuite (*f)(Prims_string x0),
  Prims_list__Prims_string *x
)
{
  if (x->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
    Prims_list__Parsers_CipherSuite_cipherSuite
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
    buf[0U] = ((Prims_list__Parsers_CipherSuite_cipherSuite){ .tag = Prims_Nil });
    return buf;
  }
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Prims_string *tl1 = x->tl;
    Prims_string a = x->hd;
    Parsers_CipherSuite_cipherSuite uu____0 = f(a);
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
    Prims_list__Parsers_CipherSuite_cipherSuite
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
    buf[0U]
    =
      (
        (Prims_list__Parsers_CipherSuite_cipherSuite){
          .tag = Prims_Cons,
          .hd = uu____0,
          .tl = FFI_map__Prims_string_Parsers_CipherSuite_cipherSuite(f, tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_config FFI_ffiSetCipherSuites(TLSConstants_config cfg, Prims_string x)
{
  Prims_list__Prims_string *scrut = FFI_split_string(FStar_Char_char_of_int((uint32_t)64U), x);
  if (scrut->tag == Prims_Cons)
  {
    Prims_list__Prims_string *t = scrut->tl;
    Prims_string x1 = scrut->hd;
    TLSConstants_config cfg1 = FFI_updatecfg(cfg, t);
    Prims_list__Prims_string *csl = FFI_split_string(FStar_Char_char_of_int((uint32_t)58U), x1);
    Prims_list__Parsers_CipherSuite_cipherSuite
    *csl1 = FFI_map__Prims_string_Parsers_CipherSuite_cipherSuite(FFI_findSetting_css, csl);
    TLSConstants_config uu____0 = cfg1;
    return
      (
        (TLSConstants_config){
          .min_version = uu____0.min_version,
          .max_version = uu____0.max_version,
          .is_quic = uu____0.is_quic,
          .cipher_suites = CipherSuite_cipherSuites_of_nameList(csl1),
          .named_groups = uu____0.named_groups,
          .signature_algorithms = uu____0.signature_algorithms,
          .hello_retry = uu____0.hello_retry,
          .offer_shares = uu____0.offer_shares,
          .custom_extensions = uu____0.custom_extensions,
          .use_tickets = uu____0.use_tickets,
          .send_ticket = uu____0.send_ticket,
          .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
          .request_client_certificate = uu____0.request_client_certificate,
          .non_blocking_read = uu____0.non_blocking_read,
          .max_early_data = uu____0.max_early_data,
          .max_ticket_age = uu____0.max_ticket_age,
          .safe_renegotiation = uu____0.safe_renegotiation,
          .extended_master_secret = uu____0.extended_master_secret,
          .enable_tickets = uu____0.enable_tickets,
          .ticket_callback = uu____0.ticket_callback,
          .nego_callback = uu____0.nego_callback,
          .cert_callbacks = uu____0.cert_callbacks,
          .alpn = uu____0.alpn,
          .peer_name = uu____0.peer_name
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__Parsers_SignatureScheme_signatureScheme
FFI_findsetting__Prims_string_Parsers_SignatureScheme_signatureScheme(
  Prims_string f,
  Prims_list__K___Prims_string_Parsers_SignatureScheme_signatureScheme *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_SignatureScheme_signatureScheme){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___Prims_string_Parsers_SignatureScheme_signatureScheme *tl1 = l->tl;
    Parsers_SignatureScheme_signatureScheme i1 = l->hd.snd;
    Prims_string s = l->hd.fst;
    if (__eq__Prims_string(s, f))
      return
        (
          (FStar_Pervasives_Native_option__Parsers_SignatureScheme_signatureScheme){
            .tag = FStar_Pervasives_Native_Some,
            .v = i1
          }
        );
    else
      return FFI_findsetting__Prims_string_Parsers_SignatureScheme_signatureScheme(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Parsers_SignatureScheme_signatureScheme FFI_findSetting_sas(Prims_string x)
{
  FStar_Pervasives_Native_option__Parsers_SignatureScheme_signatureScheme
  scrut = FFI_findsetting__Prims_string_Parsers_SignatureScheme_signatureScheme(x, FFI_sas);
  if (scrut.tag == FStar_Pervasives_Native_None)
  {
    FStar_HyperStack_IO_print_string(Prims_strcat("Unknown signature algorithm: ", x));
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
    KRML_HOST_EXIT(255U);
  }
  else if (scrut.tag == FStar_Pervasives_Native_Some)
    return scrut.v;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__Parsers_SignatureScheme_signatureScheme
*FFI_map__Prims_string_Parsers_SignatureScheme_signatureScheme(
  Parsers_SignatureScheme_signatureScheme (*f)(Prims_string x0),
  Prims_list__Prims_string *x
)
{
  if (x->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme), (uint32_t)1U);
    Prims_list__Parsers_SignatureScheme_signatureScheme
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme));
    buf[0U] = ((Prims_list__Parsers_SignatureScheme_signatureScheme){ .tag = Prims_Nil });
    return buf;
  }
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Prims_string *tl1 = x->tl;
    Prims_string a = x->hd;
    Parsers_SignatureScheme_signatureScheme uu____0 = f(a);
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme), (uint32_t)1U);
    Prims_list__Parsers_SignatureScheme_signatureScheme
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_SignatureScheme_signatureScheme));
    buf[0U]
    =
      (
        (Prims_list__Parsers_SignatureScheme_signatureScheme){
          .tag = Prims_Cons,
          .hd = uu____0,
          .tl = FFI_map__Prims_string_Parsers_SignatureScheme_signatureScheme(f, tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_config FFI_ffiSetSignatureAlgorithms(TLSConstants_config cfg, Prims_string x)
{
  Prims_list__Prims_string *sal = FFI_split_string(FStar_Char_char_of_int((uint32_t)58U), x);
  Prims_list__Parsers_SignatureScheme_signatureScheme
  *sal1 = FFI_map__Prims_string_Parsers_SignatureScheme_signatureScheme(FFI_findSetting_sas, sal);
  TLSConstants_config uu____0 = cfg;
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = sal1,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup
FFI_findsetting__Prims_string_Parsers_NamedGroup_namedGroup(
  Prims_string f,
  Prims_list__K___Prims_string_Parsers_NamedGroup_namedGroup *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___Prims_string_Parsers_NamedGroup_namedGroup *tl1 = l->tl;
    Parsers_NamedGroup_namedGroup i1 = l->hd.snd;
    Prims_string s = l->hd.fst;
    if (__eq__Prims_string(s, f))
      return
        (
          (FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup){
            .tag = FStar_Pervasives_Native_Some,
            .v = i1
          }
        );
    else
      return FFI_findsetting__Prims_string_Parsers_NamedGroup_namedGroup(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Parsers_NamedGroup_namedGroup FFI_findSetting_ngs(Prims_string x)
{
  FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup
  scrut = FFI_findsetting__Prims_string_Parsers_NamedGroup_namedGroup(x, FFI_ngs);
  if (scrut.tag == FStar_Pervasives_Native_None)
  {
    FStar_HyperStack_IO_print_string(Prims_strcat("Unknown named group: ", x));
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
    KRML_HOST_EXIT(255U);
  }
  else if (scrut.tag == FStar_Pervasives_Native_Some)
    return scrut.v;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__Parsers_NamedGroup_namedGroup
*FFI_map__Prims_string_Parsers_NamedGroup_namedGroup(
  Parsers_NamedGroup_namedGroup (*f)(Prims_string x0),
  Prims_list__Prims_string *x
)
{
  if (x->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
    Prims_list__Parsers_NamedGroup_namedGroup
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
    buf[0U] = ((Prims_list__Parsers_NamedGroup_namedGroup){ .tag = Prims_Nil });
    return buf;
  }
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Prims_string *tl1 = x->tl;
    Prims_string a = x->hd;
    Parsers_NamedGroup_namedGroup uu____0 = f(a);
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
    Prims_list__Parsers_NamedGroup_namedGroup
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
    buf[0U]
    =
      (
        (Prims_list__Parsers_NamedGroup_namedGroup){
          .tag = Prims_Cons,
          .hd = uu____0,
          .tl = FFI_map__Prims_string_Parsers_NamedGroup_namedGroup(f, tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_config FFI_ffiSetNamedGroups(TLSConstants_config cfg, Prims_string x)
{
  Prims_list__Prims_string *scrut = FFI_split_string(FStar_Char_char_of_int((uint32_t)64U), x);
  if (scrut->tag == Prims_Cons)
  {
    Prims_list__Prims_string *offered = scrut->tl;
    Prims_string supported = scrut->hd;
    Prims_list__Prims_string
    *ngl = FFI_split_string(FStar_Char_char_of_int((uint32_t)58U), supported);
    Prims_list__Parsers_NamedGroup_namedGroup
    *ngl1 = FFI_map__Prims_string_Parsers_NamedGroup_namedGroup(FFI_findSetting_ngs, ngl);
    Prims_list__Parsers_NamedGroup_namedGroup *ogl;
    if (offered->tag == Prims_Nil)
      ogl = ngl1;
    else if (offered->tag == Prims_Cons && offered->tl->tag == Prims_Nil)
    {
      Prims_string og = offered->hd;
      if (FStar_String_strlen(og) == (krml_checked_int_t)0)
      {
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_NamedGroup_namedGroup), (uint32_t)1U);
        Prims_list__Parsers_NamedGroup_namedGroup
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_NamedGroup_namedGroup));
        buf[0U] = ((Prims_list__Parsers_NamedGroup_namedGroup){ .tag = Prims_Nil });
        ogl = buf;
      }
      else
        ogl =
          FFI_map__Prims_string_Parsers_NamedGroup_namedGroup(FFI_findSetting_ngs,
            FFI_split_string(FStar_Char_char_of_int((uint32_t)58U), og));
    }
    else
      ogl =
        KRML_EABORT(Prims_list__Parsers_NamedGroup_namedGroup *,
          "Use @G1:..:Gn to set groups on which to offer shares");
    TLSConstants_config uu____0 = cfg;
    return
      (
        (TLSConstants_config){
          .min_version = uu____0.min_version,
          .max_version = uu____0.max_version,
          .is_quic = uu____0.is_quic,
          .cipher_suites = uu____0.cipher_suites,
          .named_groups = ngl1,
          .signature_algorithms = uu____0.signature_algorithms,
          .hello_retry = uu____0.hello_retry,
          .offer_shares = ogl,
          .custom_extensions = uu____0.custom_extensions,
          .use_tickets = uu____0.use_tickets,
          .send_ticket = uu____0.send_ticket,
          .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
          .request_client_certificate = uu____0.request_client_certificate,
          .non_blocking_read = uu____0.non_blocking_read,
          .max_early_data = uu____0.max_early_data,
          .max_ticket_age = uu____0.max_ticket_age,
          .safe_renegotiation = uu____0.safe_renegotiation,
          .extended_master_secret = uu____0.extended_master_secret,
          .enable_tickets = uu____0.enable_tickets,
          .ticket_callback = uu____0.ticket_callback,
          .nego_callback = uu____0.nego_callback,
          .cert_callbacks = uu____0.cert_callbacks,
          .alpn = uu____0.alpn,
          .peer_name = uu____0.peer_name
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes FFI_encodeALPN(Prims_string x)
{
  if (Prims_op_LessThan(FStar_String_strlen(x), (krml_checked_int_t)256))
    return FStar_Bytes_utf8_encode(x);
  else
  {
    FStar_HyperStack_IO_print_string(Prims_strcat("ffiSetALPN: protocol <",
        Prims_strcat(x, "> is too long")));
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_int FStar_List_Tot_Base_length__Prims_string(Prims_list__Prims_string *uu___4_154)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Prims_string *tl1 = uu___4_154->tl;
    return Prims_op_Addition((krml_checked_int_t)1, FStar_List_Tot_Base_length__Prims_string(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__FStar_Bytes_bytes
*FFI_map__Prims_string_FStar_Bytes_bytes(
  FStar_Bytes_bytes (*f)(Prims_string x0),
  Prims_list__Prims_string *x
)
{
  if (x->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
    return buf;
  }
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Prims_string *tl1 = x->tl;
    Prims_string a = x->hd;
    FStar_Bytes_bytes uu____0 = f(a);
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf[0U]
    =
      (
        (Prims_list__FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = uu____0,
          .tl = FFI_map__Prims_string_FStar_Bytes_bytes(f, tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_list__FStar_Bytes_bytes *FFI_ffiSplitALPN(TLSConstants_config cfg, Prims_string x)
{
  Prims_list__Prims_string *apl;
  if (__eq__Prims_string(x, ""))
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_string), (uint32_t)1U);
    Prims_list__Prims_string *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_string));
    buf[0U] = ((Prims_list__Prims_string){ .tag = Prims_Nil });
    apl = buf;
  }
  else
    apl = FFI_split_string(FStar_Char_char_of_int((uint32_t)58U), x);
  if
  (Prims_op_GreaterThan(FStar_List_Tot_Base_length__Prims_string(apl), (krml_checked_int_t)255))
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "ffiSetALPN: too many entries");
    KRML_HOST_EXIT(255U);
  }
  return FFI_map__Prims_string_FStar_Bytes_bytes(FFI_encodeALPN, apl);
}

TLSConstants_config FFI_ffiSetALPN(TLSConstants_config cfg, Prims_list__FStar_Bytes_bytes *x)
{
  TLSConstants_config uu____0 = cfg;
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes ite;
  if (__eq__Prims_list__FStar_Bytes_bytes(x, buf))
    ite =
      (
        (FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
    ite =
      (
        (FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = x
        }
      );
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = ite,
        .peer_name = uu____0.peer_name
      }
    );
}

TLSConstants_config FFI_ffiSetEarlyData(TLSConstants_config cfg, uint32_t x)
{
  FFI_print(Prims_strcat("setting early data limit to ",
      FStar_Bytes_hex_of_bytes(Parse_bytes_of_uint32(x))));
  TLSConstants_config uu____0 = cfg;
  FStar_Pervasives_Native_option__uint32_t ite;
  if (x == (uint32_t)0U)
    ite = ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_None });
  else
    ite =
      ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_Some, .v = x });
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = ite,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

TLSConstants_config
FFI_ffiAddCustomExtension(TLSConstants_config cfg, uint16_t h1, FStar_Bytes_bytes b)
{
  FFI_print(Prims_strcat("offering custom extension ",
      FStar_Bytes_hex_of_bytes(Parse_bytes_of_uint16(h1))));
  FFI_print(Prims_strcat("extension contents: ", FStar_Bytes_hex_of_bytes(b)));
  TLSConstants_config uu____0 = cfg;
  KRML_CHECK_SIZE(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__K___uint16_t_FStar_Bytes_bytes
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes));
  buf[0U]
  =
    (
      (Prims_list__K___uint16_t_FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = { .fst = h1, .snd = b },
        .tl = cfg.custom_extensions
      }
    );
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = buf,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

FStar_Pervasives_Native_option__EverCrypt_aead_alg
FFI_findsetting__Prims_string_EverCrypt_aead_alg(
  Prims_string f,
  Prims_list__K___Prims_string_EverCrypt_aead_alg *l
)
{
  if (l->tag == Prims_Nil)
    return
      ((FStar_Pervasives_Native_option__EverCrypt_aead_alg){ .tag = FStar_Pervasives_Native_None });
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___Prims_string_EverCrypt_aead_alg *tl1 = l->tl;
    EverCrypt_aead_alg i1 = l->hd.snd;
    Prims_string s = l->hd.fst;
    if (__eq__Prims_string(s, f))
      return
        (
          (FStar_Pervasives_Native_option__EverCrypt_aead_alg){
            .tag = FStar_Pervasives_Native_Some,
            .v = i1
          }
        );
    else
      return FFI_findsetting__Prims_string_EverCrypt_aead_alg(f, tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool FFI_ffiSetTicketKey(Prims_string a, FStar_Bytes_bytes k1)
{
  FStar_Pervasives_Native_option__EverCrypt_aead_alg
  scrut = FFI_findsetting__Prims_string_EverCrypt_aead_alg(a, FFI_aeads);
  if (scrut.tag == FStar_Pervasives_Native_None)
    return false;
  else if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    EverCrypt_aead_alg a1 = scrut.v;
    return TLS_set_ticket_key(a1, k1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool FFI_ffiSetSealingKey(Prims_string a, FStar_Bytes_bytes k1)
{
  FStar_Pervasives_Native_option__EverCrypt_aead_alg
  scrut = FFI_findsetting__Prims_string_EverCrypt_aead_alg(a, FFI_aeads);
  if (scrut.tag == FStar_Pervasives_Native_None)
    return false;
  else if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    EverCrypt_aead_alg a1 = scrut.v;
    return TLS_set_sealing_key(a1, k1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_config
FFI_ffiSetTicket(TLSConstants_config cfg, FStar_Bytes_bytes tid, FStar_Bytes_bytes si)
{
  TLSConstants_config uu____0 = cfg;
  KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes));
  buf[0U]
  =
    (
      (Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = { .fst = tid, .snd = si },
        .tl = cfg.use_tickets
      }
    );
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = buf,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

K___Connection_connection_Prims_int
FFI_ffiConnect(
  FStar_Dyn_dyn ctx,
  int32_t (*snd1)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  int32_t (*rcv)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  TLSConstants_config config
)
{
  return FFI_connect(ctx, snd1, rcv, config);
}

K___Connection_connection_Prims_int
FFI_ffiAcceptConnected(
  FStar_Dyn_dyn ctx,
  int32_t (*snd1)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  int32_t (*rcv)(FStar_Dyn_dyn x0, uint8_t *x1, uint32_t x2),
  TLSConstants_config config
)
{
  return FFI_accept_connected(ctx, snd1, rcv, config);
}

FStar_Bytes_bytes FFI_ffiRecv(Connection_connection c)
{
  FFI_read_result scrut = FFI_read(c);
  if (scrut.tag == FFI_Received)
    return scrut.val.case_Received;
  else if (scrut.tag == FFI_WouldBlock)
    return FStar_Bytes_empty_bytes;
  else if (scrut.tag == FFI_Errno)
    return FStar_Bytes_empty_bytes;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_int FFI_ffiSend(Connection_connection c, FStar_Bytes_bytes b)
{
  return FFI_write(c, b);
}

TLSConstants_config
FFI_ffiSetTicketCallback(
  TLSConstants_config cfg,
  FStar_Dyn_dyn ctx,
  void
  (*cb)(
    FStar_Dyn_dyn x0,
    Prims_string x1,
    FStar_Bytes_bytes x2,
    TLSConstants_ticketInfo x3,
    FStar_Bytes_bytes x4
  )
)
{
  FFI_print("Setting a new ticket callback.");
  TLSConstants_config uu____0 = cfg;
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = { .ticket_context = ctx, .new_ticket = cb },
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

TLSConstants_config
FFI_ffiSetNegoCallback(
  TLSConstants_config cfg,
  FStar_Dyn_dyn ctx,
  TLSConstants_nego_action
  (*cb)(
    FStar_Dyn_dyn x0,
    Parsers_ProtocolVersion_protocolVersion x1,
    FStar_Bytes_bytes x2,
    FStar_Pervasives_Native_option__FStar_Bytes_bytes x3
  )
)
{
  FFI_print("Setting a new server negotiation callback.");
  TLSConstants_config uu____0 = cfg;
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = { .nego_context = ctx, .negotiate = cb },
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

TLSConstants_config FFI_ffiSetCertCallbacks(TLSConstants_config cfg, TLSConstants_cert_cb cb)
{
  FFI_print("Setting up certificate callbacks.");
  TLSConstants_config uu____0 = cfg;
  return
    (
      (TLSConstants_config){
        .min_version = uu____0.min_version,
        .max_version = uu____0.max_version,
        .is_quic = uu____0.is_quic,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = uu____0.send_ticket,
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = uu____0.non_blocking_read,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = cb,
        .alpn = uu____0.alpn,
        .peer_name = uu____0.peer_name
      }
    );
}

Prims_string FFI_ffiGetCert(Connection_connection c)
{
  FStar_Bytes_bytes cert = FFI_getCert(c);
  return FStar_Bytes_print_bytes(cert);
}

static FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
FStar_List_Tot_Base_hd__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *uu___0_39
)
{
  if (uu___0_39->tag == Prims_Cons)
    return uu___0_39->hd;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_List_Tot_Base_tail__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *uu___1_64
)
{
  if (uu___1_64->tag == Prims_Cons)
    return uu___1_64->tl;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*(*FStar_List_Tot_Base_tl__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes)(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *x0
) =
  FStar_List_Tot_Base_tail__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes;

static FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
FStar_List_Tot_Base_index__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *l,
  Prims_int i
)
{
  if (i == (krml_checked_int_t)0)
    return
      FStar_List_Tot_Base_hd__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(l);
  else
    return
      FStar_List_Tot_Base_index__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(FStar_List_Tot_Base_tl__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(l),
        Prims_op_Subtraction(i, (krml_checked_int_t)1));
}

static FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
FStar_Seq_Base_index__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *s,
  Prims_int i
)
{
  return
    FStar_List_Tot_Base_index__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(s,
      i);
}

typedef struct K___bool_TLSInfo_pre_exportId_s
{
  bool fst;
  TLSInfo_pre_exportId *snd;
}
K___bool_TLSInfo_pre_exportId;

FStar_Pervasives_Native_option__K___Spec_Hash_Definitions_hash_alg_EverCrypt_aead_alg_FStar_Bytes_bytes
FFI_ffiGetExporter(Connection_connection c, bool early)
{
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *keys = Old_Handshake_xkeys_of(c.hs);
  if
  (
    FStar_Seq_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(keys)
    == (krml_checked_int_t)0
  )
    return
      (
        (FStar_Pervasives_Native_option__K___Spec_Hash_Definitions_hash_alg_EverCrypt_aead_alg_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    Prims_int i1;
    if
    (
      FStar_Seq_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(keys)
      == (krml_checked_int_t)2
      && !early
    )
      i1 = (krml_checked_int_t)1;
    else
      i1 = (krml_checked_int_t)0;
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    scrut0 =
      FStar_Seq_Base_index__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(keys,
        i1);
    TLSInfo_logInfo li = scrut0._1;
    TLSInfo_pre_exportId *expId = scrut0._2;
    FStar_Bytes_bytes b = scrut0._3;
    Spec_Hash_Definitions_hash_alg h1 = TLSInfo_exportId_hash(li, expId);
    EverCrypt_aead_alg ae = TLSInfo_logInfo_ae(li);
    K___bool_TLSInfo_pre_exportId scrut = { .fst = early, .snd = expId };
    if (scrut.fst == false && scrut.snd->tag == TLSInfo_ExportID)
      return
        (
          (FStar_Pervasives_Native_option__K___Spec_Hash_Definitions_hash_alg_EverCrypt_aead_alg_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = h1, .snd = ae, .thd = b }
          }
        );
    else if (scrut.fst == true && scrut.snd->tag == TLSInfo_EarlyExportID)
      return
        (
          (FStar_Pervasives_Native_option__K___Spec_Hash_Definitions_hash_alg_EverCrypt_aead_alg_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = h1, .snd = ae, .thd = b }
          }
        );
    else
      return
        (
          (FStar_Pervasives_Native_option__K___Spec_Hash_Definitions_hash_alg_EverCrypt_aead_alg_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
}

FStar_Bytes_bytes FFI_ffiTicketInfoBytes(TLSConstants_ticketInfo info, FStar_Bytes_bytes key)
{
  Ticket_ticket si;
  if (info.tag == TLSConstants_TicketInfo_13)
  {
    TLSConstants_pskInfo ctx = info.val.case_TicketInfo_13;
    EverCrypt_aead_alg ae = ctx.early_ae;
    Spec_Hash_Definitions_hash_alg h1 = ctx.early_hash;
    Prims_dtuple2__TLSInfo_logInfo_TLSInfo_pre_rmsId scrut = Ticket_dummy_rmsid(ae, h1);
    TLSInfo_logInfo li = scrut.fst;
    TLSInfo_pre_rmsId *rmsid = scrut.snd;
    si =
      (
        (Ticket_ticket){
          .tag = Ticket_Ticket13,
          .val = {
            .case_Ticket13 = {
              .cs = {
                .tag = CipherSuite_CipherSuite13,
                .val = { .case_CipherSuite13 = { ._0 = ae, ._1 = h1 } }
              }, .li = li, .rmsId = rmsid, .rms = key, .nonce = FStar_Bytes_empty_bytes,
              .ticket_created = ctx.time_created, .ticket_age_add = ctx.ticket_age_add,
              .custom = FStar_Bytes_empty_bytes
            }
          }
        }
      );
  }
  else if (info.tag == TLSConstants_TicketInfo_12)
  {
    bool ems = info.val.case_TicketInfo_12.thd;
    CipherSuite_cipherSuite_ cs = info.val.case_TicketInfo_12.snd;
    Parsers_ProtocolVersion_protocolVersion pv = info.val.case_TicketInfo_12.fst;
    si =
      (
        (Ticket_ticket){
          .tag = Ticket_Ticket12,
          .val = {
            .case_Ticket12 = {
              .pv = pv, .cs = cs, .ems = ems, .msId = Ticket_dummy_msId(pv, cs, ems), .ms = key
            }
          }
        }
      );
  }
  else
    si = KRML_EABORT(Ticket_ticket, "unreachable (pattern matches are exhaustive in F*)");
  return Ticket_create_ticket(true, si);
}

Prims_list__FStar_Bytes_bytes *FFI_ffiSplitChain(FStar_Bytes_bytes chain)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
  scrut = Cert_parseCertificateList(chain);
  if (scrut.tag == FStar_Error_Error)
  {
    Prims_string msg = scrut.val.case_Error.snd;
    FStar_HyperStack_IO_print_string(Prims_strcat("ffiCertFormatCallback: formatted chain was invalid, ",
        msg));
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
    KRML_HOST_EXIT(255U);
  }
  else if (scrut.tag == FStar_Error_Correct)
    return scrut.val.case_Correct;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Pervasives_Native_option__FStar_Bytes_bytes
FFI_ext_filter(uint16_t ext_type, Prims_list__Extensions_extension_ *e)
{
  if (e->tag == Prims_Nil)
    return
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  else if (e->tag == Prims_Cons && e->hd.tag == Extensions_E_unknown_extension)
  {
    Prims_list__Extensions_extension_ *t = e->tl;
    FStar_Bytes_bytes b = e->hd.val.case_E_unknown_extension._1;
    FStar_Bytes_bytes hd1 = e->hd.val.case_E_unknown_extension.x;
    if (Parse_uint16_of_bytes(hd1) == ext_type)
      return
        (
          (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = b
          }
        );
    else
      return FFI_ext_filter(ext_type, t);
  }
  else if (e->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *t = e->tl;
    return FFI_ext_filter(ext_type, t);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes
FFI_ffiFindCustomExtension(bool server, FStar_Bytes_bytes exts, uint16_t ext_type)
{
  Extensions_ext_msg mt;
  if (server)
    mt = Extensions_EM_ClientHello;
  else
    mt = Extensions_EM_EncryptedExtensions;
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
  scrut = Extensions_parseOptExtensions(mt, exts);
  if
  (
    scrut.tag
    == FStar_Error_Correct
    && scrut.val.case_Correct.fst.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__Extensions_extension_ *el = scrut.val.case_Correct.fst.v;
    return FFI_ext_filter(ext_type, el);
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    Prims_string txt = scrut.val.case_Error.snd;
    FFI_print(Prims_strcat("Warning: error ", Prims_strcat(txt, "while parsing extensions")));
    return
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes FFI_ffiFindSNI(FStar_Bytes_bytes exts)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
  scrut = Extensions_parseOptExtensions(Extensions_EM_ClientHello, exts);
  if
  (
    scrut.tag
    == FStar_Error_Correct
    && scrut.val.case_Correct.fst.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__Extensions_extension_ *el = scrut.val.case_Correct.fst.v;
    FStar_Pervasives_Native_option__Extensions_extension_
    scrut =
      FStar_List_Tot_Base_find__Extensions_extension_(Extensions_uu___is_E_server_name____,
        el);
    if
    (
      scrut.tag
      == FStar_Pervasives_Native_Some
      &&
        scrut.v.tag
        == Extensions_E_server_name
        &&
          scrut.v.val.case_E_server_name->tag
          == Prims_Cons
          && scrut.v.val.case_E_server_name->hd.tag == TLSConstants_SNI_DNS
    )
    {
      FStar_Bytes_bytes b = scrut.v.val.case_E_server_name->hd.val.case_SNI_DNS;
      return
        (
          (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = b
          }
        );
    }
    else
      return
        ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    FFI_print("Warning: bad extension list passed to get_transport_parameters");
    return
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes FFI_ffiFindALPN(FStar_Bytes_bytes exts)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
  scrut = Extensions_parseOptExtensions(Extensions_EM_ClientHello, exts);
  if
  (
    scrut.tag
    == FStar_Error_Correct
    && scrut.val.case_Correct.fst.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__Extensions_extension_ *el = scrut.val.case_Correct.fst.v;
    FStar_Pervasives_Native_option__Extensions_extension_
    scrut = FStar_List_Tot_Base_find__Extensions_extension_(Extensions_uu___is_E_alpn____, el);
    if (scrut.tag == FStar_Pervasives_Native_Some && scrut.v.tag == Extensions_E_alpn)
    {
      Prims_list__FStar_Bytes_bytes *a = scrut.v.val.case_E_alpn;
      return
        (
          (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = Extensions_alpnBytes(a)
          }
        );
    }
    else
      return
        ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    FFI_print("Warning: bad extension list passed to get_transport_parameters");
    return
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

