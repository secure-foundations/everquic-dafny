/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "HandshakeMessages.h"

bool HandshakeMessages_uu___is_HT_hello_request(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_hello_request:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_client_hello(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_client_hello:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_server_hello(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_server_hello:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_session_ticket(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_session_ticket:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_end_of_early_data(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_end_of_early_data:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool
HandshakeMessages_uu___is_HT_hello_retry_request(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_hello_retry_request:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool
HandshakeMessages_uu___is_HT_encrypted_extensions(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_encrypted_extensions:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_certificate(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_certificate:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool
HandshakeMessages_uu___is_HT_server_key_exchange(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_server_key_exchange:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool
HandshakeMessages_uu___is_HT_certificate_request(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_certificate_request:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_server_hello_done(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_server_hello_done:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_certificate_verify(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_certificate_verify:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool
HandshakeMessages_uu___is_HT_client_key_exchange(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_client_key_exchange:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_finished(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_finished:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_key_update(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_key_update:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool HandshakeMessages_uu___is_HT_message_hash(HandshakeMessages_handshakeType projectee)
{
  switch (projectee)
  {
    case HandshakeMessages_HT_message_hash:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

typedef struct K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_s
{
  FStar_Bytes_bytes fst;
  FStar_Bytes_bytes snd;
  FStar_Bytes_bytes thd;
}
K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes;

static K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes
HandshakeMessages_split2(FStar_Bytes_bytes abc, Prims_int n1, Prims_int n2)
{
  K___FStar_Bytes_bytes_FStar_Bytes_bytes
  scrut = FStar_Bytes_split(abc, FStar_UInt32_uint_to_t(n1));
  FStar_Bytes_bytes a = scrut.fst;
  FStar_Bytes_bytes bc = scrut.snd;
  K___FStar_Bytes_bytes_FStar_Bytes_bytes
  scrut0 = FStar_Bytes_split(bc, FStar_UInt32_uint_to_t(n2));
  FStar_Bytes_bytes b = scrut0.fst;
  FStar_Bytes_bytes c = scrut0.snd;
  return
    ((K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes){ .fst = a, .snd = b, .thd = c });
}

FStar_Bytes_bytes HandshakeMessages_htBytes(HandshakeMessages_handshakeType t)
{
  uint8_t z;
  switch (t)
  {
    case HandshakeMessages_HT_hello_request:
      {
        z = (uint8_t)0U;
        break;
      }
    case HandshakeMessages_HT_client_hello:
      {
        z = (uint8_t)1U;
        break;
      }
    case HandshakeMessages_HT_server_hello:
      {
        z = (uint8_t)2U;
        break;
      }
    case HandshakeMessages_HT_session_ticket:
      {
        z = (uint8_t)4U;
        break;
      }
    case HandshakeMessages_HT_end_of_early_data:
      {
        z = (uint8_t)5U;
        break;
      }
    case HandshakeMessages_HT_encrypted_extensions:
      {
        z = (uint8_t)8U;
        break;
      }
    case HandshakeMessages_HT_certificate:
      {
        z = (uint8_t)11U;
        break;
      }
    case HandshakeMessages_HT_server_key_exchange:
      {
        z = (uint8_t)12U;
        break;
      }
    case HandshakeMessages_HT_certificate_request:
      {
        z = (uint8_t)13U;
        break;
      }
    case HandshakeMessages_HT_server_hello_done:
      {
        z = (uint8_t)14U;
        break;
      }
    case HandshakeMessages_HT_certificate_verify:
      {
        z = (uint8_t)15U;
        break;
      }
    case HandshakeMessages_HT_client_key_exchange:
      {
        z = (uint8_t)16U;
        break;
      }
    case HandshakeMessages_HT_finished:
      {
        z = (uint8_t)20U;
        break;
      }
    case HandshakeMessages_HT_key_update:
      {
        z = (uint8_t)24U;
        break;
      }
    case HandshakeMessages_HT_message_hash:
      {
        z = (uint8_t)254U;
        break;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  return FStar_Bytes_abyte(z);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType
TLSError_fatal__HandshakeMessages_handshakeType(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType
HandshakeMessages_parseHt(FStar_Bytes_bytes b)
{
  switch (FStar_Bytes_get(b, (uint32_t)0U))
  {
    case 0U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_hello_request }
            }
          );
      }
    case 1U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_client_hello }
            }
          );
      }
    case 2U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_server_hello }
            }
          );
      }
    case 4U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_session_ticket }
            }
          );
      }
    case 5U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_end_of_early_data }
            }
          );
      }
    case 8U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_encrypted_extensions }
            }
          );
      }
    case 11U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_certificate }
            }
          );
      }
    case 12U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_server_key_exchange }
            }
          );
      }
    case 13U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_certificate_request }
            }
          );
      }
    case 14U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_server_hello_done }
            }
          );
      }
    case 15U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_certificate_verify }
            }
          );
      }
    case 16U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_client_key_exchange }
            }
          );
      }
    case 20U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_finished }
            }
          );
      }
    case 24U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_key_update }
            }
          );
      }
    case 254U:
      {
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = HandshakeMessages_HT_message_hash }
            }
          );
      }
    default:
      {
        return
          TLSError_fatal__HandshakeMessages_handshakeType(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)87, ""));
      }
  }
}

Parsers_ProtocolVersion_protocolVersion
HandshakeMessages___proj__Mkch__item__ch_protocol_version(HandshakeMessages_ch projectee)
{
  return projectee.ch_protocol_version;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mkch__item__ch_client_random(HandshakeMessages_ch projectee)
{
  return projectee.ch_client_random;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mkch__item__ch_sessionID(HandshakeMessages_ch projectee)
{
  return projectee.ch_sessionID;
}

Prims_list__Parsers_CipherSuite_cipherSuite
*HandshakeMessages___proj__Mkch__item__ch_cipher_suites(HandshakeMessages_ch projectee)
{
  return projectee.ch_cipher_suites;
}

Prims_list__Parsers_CompressionMethod_compressionMethod
*HandshakeMessages___proj__Mkch__item__ch_compressions(HandshakeMessages_ch projectee)
{
  return projectee.ch_compressions;
}

FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
HandshakeMessages___proj__Mkch__item__ch_extensions(HandshakeMessages_ch projectee)
{
  return projectee.ch_extensions;
}

Prims_int HandshakeMessages_bindersLen_of_ch(HandshakeMessages_ch ch)
{
  if (ch.ch_extensions.tag == FStar_Pervasives_Native_None)
    return (krml_checked_int_t)0;
  else if (ch.ch_extensions.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *el = ch.ch_extensions.v;
    return Extensions_bindersLen____(el);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Parsers_ProtocolVersion_protocolVersion
HandshakeMessages___proj__Mksh__item__sh_protocol_version(HandshakeMessages_sh projectee)
{
  return projectee.sh_protocol_version;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mksh__item__sh_server_random(HandshakeMessages_sh projectee)
{
  return projectee.sh_server_random;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mksh__item__sh_sessionID(HandshakeMessages_sh projectee)
{
  return projectee.sh_sessionID;
}

Parsers_CipherSuite_cipherSuite
HandshakeMessages___proj__Mksh__item__sh_cipher_suite(HandshakeMessages_sh projectee)
{
  return projectee.sh_cipher_suite;
}

Parsers_CompressionMethod_compressionMethod
HandshakeMessages___proj__Mksh__item__sh_compression(HandshakeMessages_sh projectee)
{
  return projectee.sh_compression;
}

FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
HandshakeMessages___proj__Mksh__item__sh_extensions(HandshakeMessages_sh projectee)
{
  return projectee.sh_extensions;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mkhrr__item__hrr_sessionID(HandshakeMessages_hrr projectee)
{
  return projectee.hrr_sessionID;
}

Parsers_CipherSuite_cipherSuite
HandshakeMessages___proj__Mkhrr__item__hrr_cipher_suite(HandshakeMessages_hrr projectee)
{
  return projectee.hrr_cipher_suite;
}

Prims_list__Extensions_extension_
*HandshakeMessages___proj__Mkhrr__item__hrr_extensions(HandshakeMessages_hrr projectee)
{
  return projectee.hrr_extensions;
}

bool HandshakeMessages_uu___is_KEX_S_DHE(HandshakeMessages_kex_s projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_DHE)
    return true;
  else
    return false;
}

Prims_dtuple2__CommonDH_group__CommonDH_pre_share_
HandshakeMessages___proj__KEX_S_DHE__item___0(HandshakeMessages_kex_s projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_DHE)
    return projectee.val.case_KEX_S_DHE;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_S_RSA(HandshakeMessages_kex_s projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_RSA)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__KEX_S_RSA__item___0(HandshakeMessages_kex_s projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_RSA)
    return projectee.val.case_KEX_S_RSA;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_S_PRIV_DHE(HandshakeMessages_kex_s_priv projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_PRIV_DHE)
    return true;
  else
    return false;
}

Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
HandshakeMessages___proj__KEX_S_PRIV_DHE__item___0(HandshakeMessages_kex_s_priv projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_PRIV_DHE)
    return projectee.val.case_KEX_S_PRIV_DHE;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_S_PRIV_RSA(HandshakeMessages_kex_s_priv projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_PRIV_RSA)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__KEX_S_PRIV_RSA__item___0(HandshakeMessages_kex_s_priv projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_S_PRIV_RSA)
    return projectee.val.case_KEX_S_PRIV_RSA;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_C_DHE(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_DHE)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__KEX_C_DHE__item___0(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_DHE)
    return projectee.val.case_KEX_C_DHE;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_C_ECDHE(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_ECDHE)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__KEX_C_ECDHE__item___0(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_ECDHE)
    return projectee.val.case_KEX_C_ECDHE;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_C_RSA(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_RSA)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__KEX_C_RSA__item___0(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_RSA)
    return projectee.val.case_KEX_C_RSA;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KEX_C_DH(HandshakeMessages_kex_c projectee)
{
  if (projectee.tag == HandshakeMessages_KEX_C_DH)
    return true;
  else
    return false;
}

HandshakeMessages_kex_c
HandshakeMessages___proj__Mkcke__item__cke_kex_c(HandshakeMessages_kex_c projectee)
{
  return projectee;
}

Prims_list__TLSConstants_certType
*HandshakeMessages___proj__Mkcr__item__cr_cert_types(HandshakeMessages_cr projectee)
{
  return projectee.cr_cert_types;
}

FStar_Pervasives_Native_option__Prims_list__Parsers_SignatureScheme_signatureScheme
HandshakeMessages___proj__Mkcr__item__cr_sig_algorithms(HandshakeMessages_cr projectee)
{
  return projectee.cr_sig_algorithms;
}

Prims_list__Prims_string
*HandshakeMessages___proj__Mkcr__item__cr_certificate_authorities(
  HandshakeMessages_cr projectee
)
{
  return projectee.cr_certificate_authorities;
}

Prims_list__FStar_Bytes_bytes
*HandshakeMessages___proj__Mkcrt__item__crt_chain(Prims_list__FStar_Bytes_bytes *projectee)
{
  return projectee;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mkcrt13__item__crt_request_context(HandshakeMessages_crt13 projectee)
{
  return projectee.crt_request_context;
}

Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
*HandshakeMessages___proj__Mkcrt13__item__crt_chain13(HandshakeMessages_crt13 projectee)
{
  return projectee.crt_chain13;
}

FStar_Pervasives_Native_option__Parsers_SignatureScheme_signatureScheme
HandshakeMessages___proj__Mksignature__item__sig_algorithm(
  HandshakeMessages_signature projectee
)
{
  return projectee.sig_algorithm;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mksignature__item__sig_signature(
  HandshakeMessages_signature projectee
)
{
  return projectee.sig_signature;
}

HandshakeMessages_kex_s
HandshakeMessages___proj__Mkske__item__ske_kex_s(HandshakeMessages_ske projectee)
{
  return projectee.ske_kex_s;
}

HandshakeMessages_signature
HandshakeMessages___proj__Mkske__item__ske_signed_params(HandshakeMessages_ske projectee)
{
  return projectee.ske_signed_params;
}

FStar_Bytes_bytes HandshakeMessages___proj__Mkfin__item__fin_vd(FStar_Bytes_bytes projectee)
{
  return projectee;
}

uint32_t
HandshakeMessages___proj__Mksticket__item__sticket_lifetime(
  HandshakeMessages_sticket projectee
)
{
  return projectee.sticket_lifetime;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mksticket__item__sticket_ticket(HandshakeMessages_sticket projectee)
{
  return projectee.sticket_ticket;
}

uint32_t
HandshakeMessages___proj__Mksticket13__item__ticket13_lifetime(
  HandshakeMessages_sticket13 projectee
)
{
  return projectee.ticket13_lifetime;
}

uint32_t
HandshakeMessages___proj__Mksticket13__item__ticket13_age_add(
  HandshakeMessages_sticket13 projectee
)
{
  return projectee.ticket13_age_add;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mksticket13__item__ticket13_nonce(
  HandshakeMessages_sticket13 projectee
)
{
  return projectee.ticket13_nonce;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Mksticket13__item__ticket13_ticket(
  HandshakeMessages_sticket13 projectee
)
{
  return projectee.ticket13_ticket;
}

Prims_list__Extensions_extension_
*HandshakeMessages___proj__Mksticket13__item__ticket13_extensions(
  HandshakeMessages_sticket13 projectee
)
{
  return projectee.ticket13_extensions;
}

bool HandshakeMessages_uu___is_ClientHello(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ClientHello)
    return true;
  else
    return false;
}

HandshakeMessages_ch
HandshakeMessages___proj__ClientHello__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ClientHello)
    return projectee.val.case_ClientHello;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_ServerHello(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ServerHello)
    return true;
  else
    return false;
}

HandshakeMessages_sh
HandshakeMessages___proj__ServerHello__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ServerHello)
    return projectee.val.case_ServerHello;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_CertificateVerify(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_CertificateVerify)
    return true;
  else
    return false;
}

HandshakeMessages_signature
HandshakeMessages___proj__CertificateVerify__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_CertificateVerify)
    return projectee.val.case_CertificateVerify;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_Finished(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Finished)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__Finished__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Finished)
    return projectee.val.case_Finished;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_ClientKeyExchange(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ClientKeyExchange)
    return true;
  else
    return false;
}

HandshakeMessages_kex_c
HandshakeMessages___proj__ClientKeyExchange__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ClientKeyExchange)
    return projectee.val.case_ClientKeyExchange;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_ServerKeyExchange(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ServerKeyExchange)
    return true;
  else
    return false;
}

HandshakeMessages_ske
HandshakeMessages___proj__ServerKeyExchange__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ServerKeyExchange)
    return projectee.val.case_ServerKeyExchange;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_ServerHelloDone(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_ServerHelloDone)
    return true;
  else
    return false;
}

bool HandshakeMessages_uu___is_Certificate(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Certificate)
    return true;
  else
    return false;
}

Prims_list__FStar_Bytes_bytes
*HandshakeMessages___proj__Certificate__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Certificate)
    return projectee.val.case_Certificate;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_CertificateRequest(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_CertificateRequest)
    return true;
  else
    return false;
}

HandshakeMessages_cr
HandshakeMessages___proj__CertificateRequest__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_CertificateRequest)
    return projectee.val.case_CertificateRequest;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_HelloRequest(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_HelloRequest)
    return true;
  else
    return false;
}

bool HandshakeMessages_uu___is_NewSessionTicket(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_NewSessionTicket)
    return true;
  else
    return false;
}

HandshakeMessages_sticket
HandshakeMessages___proj__NewSessionTicket__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_NewSessionTicket)
    return projectee.val.case_NewSessionTicket;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_EndOfEarlyData(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_EndOfEarlyData)
    return true;
  else
    return false;
}

bool HandshakeMessages_uu___is_EncryptedExtensions(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_EncryptedExtensions)
    return true;
  else
    return false;
}

Prims_list__Extensions_extension_
*HandshakeMessages___proj__EncryptedExtensions__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_EncryptedExtensions)
    return projectee.val.case_EncryptedExtensions;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_Certificate13(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Certificate13)
    return true;
  else
    return false;
}

HandshakeMessages_crt13
HandshakeMessages___proj__Certificate13__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Certificate13)
    return projectee.val.case_Certificate13;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_CertificateRequest13(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_CertificateRequest13)
    return true;
  else
    return false;
}

HandshakeMessages_cr
HandshakeMessages___proj__CertificateRequest13__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_CertificateRequest13)
    return projectee.val.case_CertificateRequest13;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_HelloRetryRequest(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_HelloRetryRequest)
    return true;
  else
    return false;
}

HandshakeMessages_hrr
HandshakeMessages___proj__HelloRetryRequest__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_HelloRetryRequest)
    return projectee.val.case_HelloRetryRequest;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_NewSessionTicket13(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_NewSessionTicket13)
    return true;
  else
    return false;
}

HandshakeMessages_sticket13
HandshakeMessages___proj__NewSessionTicket13__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_NewSessionTicket13)
    return projectee.val.case_NewSessionTicket13;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_KeyUpdate(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_KeyUpdate)
    return true;
  else
    return false;
}

bool HandshakeMessages___proj__KeyUpdate__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_KeyUpdate)
    return projectee.val.case_KeyUpdate;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_Binders(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Binders)
    return true;
  else
    return false;
}

Prims_list__FStar_Bytes_bytes
*HandshakeMessages___proj__Binders__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_Binders)
    return projectee.val.case_Binders;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool HandshakeMessages_uu___is_MessageHash(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_MessageHash)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
HandshakeMessages___proj__MessageHash__item___0(HandshakeMessages_hs_msg projectee)
{
  if (projectee.tag == HandshakeMessages_MessageHash)
    return projectee.val.case_MessageHash;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes
HandshakeMessages_messageBytes(HandshakeMessages_handshakeType ht, FStar_Bytes_bytes data)
{
  FStar_Bytes_bytes htb = HandshakeMessages_htBytes(ht);
  FStar_Bytes_bytes vldata = Parse_vlbytes((krml_checked_int_t)3, data);
  return FStar_Bytes_append(htb, vldata);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__FStar_Pervasives_dtuple4__FStar_Bytes_bytes_HandshakeMessages_handshakeType_FStar_Bytes_bytes_FStar_Bytes_bytes
HandshakeMessages_parseMessage(FStar_Bytes_bytes buf1)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(buf1)), (krml_checked_int_t)4))
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__FStar_Pervasives_dtuple4__FStar_Bytes_bytes_HandshakeMessages_handshakeType_FStar_Bytes_bytes_FStar_Bytes_bytes){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = FStar_Pervasives_Native_None } }
        }
      );
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(buf1, (uint32_t)1U);
    FStar_Bytes_bytes hstypeb = scrut0.fst;
    FStar_Bytes_bytes rem1 = scrut0.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_handshakeType
    scrut1 = HandshakeMessages_parseHt(hstypeb);
    if (scrut1.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut1.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__FStar_Pervasives_dtuple4__FStar_Bytes_bytes_HandshakeMessages_handshakeType_FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut1.tag == FStar_Error_Correct)
    {
      HandshakeMessages_handshakeType ht = scrut1.val.case_Correct;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut = Parse_vlsplit((krml_checked_int_t)3, rem1);
      if (scrut.tag == FStar_Error_Error)
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__FStar_Pervasives_dtuple4__FStar_Bytes_bytes_HandshakeMessages_handshakeType_FStar_Bytes_bytes_FStar_Bytes_bytes){
              .tag = FStar_Error_Correct,
              .val = { .case_Correct = { .tag = FStar_Pervasives_Native_None } }
            }
          );
      else if (scrut.tag == FStar_Error_Correct)
      {
        K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut.val.case_Correct;
        FStar_Bytes_bytes payload = x.fst;
        FStar_Bytes_bytes rem_ = x.snd;
        FStar_Bytes_bytes to_log = HandshakeMessages_messageBytes(ht, payload);
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__FStar_Pervasives_dtuple4__FStar_Bytes_bytes_HandshakeMessages_handshakeType_FStar_Bytes_bytes_FStar_Bytes_bytes){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { ._1 = rem_, ._2 = ht, ._3 = payload, ._4 = to_log }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static FStar_Bytes_bytes
HandshakeMessages_messageBytes_extra(
  HandshakeMessages_handshakeType ht,
  FStar_Bytes_bytes data,
  Prims_int extra
)
{
  FStar_Bytes_bytes htb = HandshakeMessages_htBytes(ht);
  FStar_Bytes_bytes vldata = Parse_vlbytes_trunc((krml_checked_int_t)3, data, extra);
  return FStar_Bytes_append(htb, vldata);
}

typedef struct K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  FStar_Bytes_bytes fst;
  Prims_list__Parsers_CipherSuite_cipherSuite *snd;
}
K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite;

typedef struct K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  bool fst;
  K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite snd;
}
K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite;

static FStar_Bytes_bytes
HandshakeMessages_cipherSuitesVLBytes(Prims_list__Parsers_CipherSuite_cipherSuite *l)
{
  Prims_list__Parsers_CipherSuite_cipherSuite *x0 = l;
  bool b = true;
  K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
  x = { .fst = true, .snd = { .fst = FStar_Bytes_empty_bytes, .snd = x0 } };
  while (b)
  {
    K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite x1 = x.snd;
    FStar_Bytes_bytes accu = x1.fst;
    Prims_list__Parsers_CipherSuite_cipherSuite *input_ = x1.snd;
    K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite ite;
    if (input_->tag == Prims_Nil)
      ite =
        (
          (K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite){
            .fst = false,
            .snd = x1
          }
        );
    else if (input_->tag == Prims_Cons)
    {
      Prims_list__Parsers_CipherSuite_cipherSuite *q = input_->tl;
      Parsers_CipherSuite_cipherSuite a = input_->hd;
      FStar_Bytes_bytes sa = Parsers_CipherSuite_cipherSuite_serializer32(a);
      FStar_Bytes_bytes accu_ = FStar_Bytes_append(accu, sa);
      ite =
        (
          (K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite){
            .fst = true,
            .snd = { .fst = accu_, .snd = q }
          }
        );
    }
    else
      ite =
        KRML_EABORT(K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite,
          "unreachable (pattern matches are exhaustive in F*)");
    x = ite;
    b = x.fst;
  }
  K___bool_K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite scrut = x;
  K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite scrut0 = scrut.snd;
  FStar_Bytes_bytes pl = scrut0.fst;
  uint32_t len1 = FStar_Bytes_len(pl);
  FStar_Bytes_bytes slen = LowParse_SLow_BoundedInt_serialize32_bounded_integer_2(len1);
  FStar_Bytes_bytes res = FStar_Bytes_append(slen, pl);
  return res;
}

FStar_Bytes_bytes HandshakeMessages_clientHelloBytes(HandshakeMessages_ch ch)
{
  Parsers_ProtocolVersion_protocolVersion
  legacyVersion =
    TLSConstants_minPV((
        (Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p2 }
      ),
      ch.ch_protocol_version);
  FStar_Bytes_bytes verB = TLSConstants_versionBytes(legacyVersion);
  FStar_Bytes_bytes sidB = Parse_vlbytes((krml_checked_int_t)1, ch.ch_sessionID);
  FStar_Bytes_bytes csB = HandshakeMessages_cipherSuitesVLBytes(ch.ch_cipher_suites);
  FStar_Bytes_bytes
  cmB =
    Parse_vlbytes((krml_checked_int_t)1,
      TLSConstants_compressionMethodsBytes(ch.ch_compressions));
  FStar_Bytes_bytes extB;
  if (ch.ch_extensions.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *ext = ch.ch_extensions.v;
    extB = Extensions_extensionsBytes(ext);
  }
  else if (ch.ch_extensions.tag == FStar_Pervasives_Native_None)
    extB = FStar_Bytes_empty_bytes;
  else
    extB = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  FStar_Bytes_bytes
  data =
    FStar_Bytes_append(verB,
      FStar_Bytes_append(ch.ch_client_random,
        FStar_Bytes_append(sidB, FStar_Bytes_append(csB, FStar_Bytes_append(cmB, extB)))));
  Prims_int binders_len = HandshakeMessages_bindersLen_of_ch(ch);
  FStar_Bytes_bytes
  b = HandshakeMessages_messageBytes_extra(HandshakeMessages_HT_client_hello, data, binders_len);
  return b;
}

FStar_Bytes_bytes
HandshakeMessages_optionExtensionsBytes(
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ exts
)
{
  if (exts.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *ext = exts.v;
    return Extensions_extensionsBytes(ext);
  }
  else if (exts.tag == FStar_Pervasives_Native_None)
    return FStar_Bytes_empty_bytes;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
HandshakeMessages_coercion_helper(
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ e
)
{
  if (e.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (e.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *li = e.v;
    return
      (
        (FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_Some,
          .v = li
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite v;
}
FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite;

typedef struct
K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  bool fst;
  FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
  snd;
}
K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite;

typedef struct
K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  Prims_list__Parsers_CipherSuite_cipherSuite *fst;
  Prims_list__Parsers_CipherSuite_cipherSuite *snd;
}
K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite;

typedef struct
K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  bool fst;
  K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite
  snd;
}
K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite;

static Prims_list__Parsers_CipherSuite_cipherSuite
*LowParse_SLow_List_list_rev__Parsers_CipherSuite_cipherSuite(
  Prims_list__Parsers_CipherSuite_cipherSuite *l
)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
    Prims_list__Parsers_CipherSuite_cipherSuite
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
    buf[0U] = ((Prims_list__Parsers_CipherSuite_cipherSuite){ .tag = Prims_Nil });
    return buf;
  }
  else
  {
    bool b = true;
    KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
    Prims_list__Parsers_CipherSuite_cipherSuite
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
    buf[0U] = ((Prims_list__Parsers_CipherSuite_cipherSuite){ .tag = Prims_Nil });
    K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite
    x0 = { .fst = true, .snd = { .fst = l, .snd = buf } };
    while (b)
    {
      K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite
      x = x0.snd;
      Prims_list__Parsers_CipherSuite_cipherSuite *rem1 = x.fst;
      Prims_list__Parsers_CipherSuite_cipherSuite *acc = x.snd;
      K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite
      ite;
      if (rem1->tag == Prims_Nil)
        ite =
          (
            (K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite){
              .fst = false,
              .snd = { .fst = rem1, .snd = acc }
            }
          );
      else if (rem1->tag == Prims_Cons)
      {
        Prims_list__Parsers_CipherSuite_cipherSuite *q = rem1->tl;
        Parsers_CipherSuite_cipherSuite a = rem1->hd;
        KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
        Prims_list__Parsers_CipherSuite_cipherSuite
        *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
        buf[0U]
        = ((Prims_list__Parsers_CipherSuite_cipherSuite){ .tag = Prims_Cons, .hd = a, .tl = acc });
        ite =
          (
            (K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite){
              .fst = true,
              .snd = { .fst = q, .snd = buf }
            }
          );
      }
      else
        ite =
          KRML_EABORT(K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite,
            "unreachable (pattern matches are exhaustive in F*)");
      x0 = ite;
      b = x0.fst;
    }
    K___bool_K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite
    scrut = x0;
    K___Prims_list__Parsers_CipherSuite_cipherSuite_Prims_list__Parsers_CipherSuite_cipherSuite
    scrut0 = scrut.snd;
    return scrut0.snd;
  }
}

typedef struct K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes_s
{
  Prims_list__Parsers_CipherSuite_cipherSuite *fst;
  FStar_Bytes_bytes snd;
}
K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes;

typedef struct
FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes v;
}
FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes;

typedef struct K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t_s
{
  Prims_list__Parsers_CipherSuite_cipherSuite *fst;
  uint32_t snd;
}
K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t;

typedef struct
FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t v;
}
FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t;

typedef struct FStar_Pervasives_Native_option__Prims_list__Parsers_CipherSuite_cipherSuite_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  Prims_list__Parsers_CipherSuite_cipherSuite *v;
}
FStar_Pervasives_Native_option__Prims_list__Parsers_CipherSuite_cipherSuite;

static FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes
HandshakeMessages_parseVLCipherSuites(FStar_Bytes_bytes b)
{
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t
  scrut0 = LowParse_SLow_BoundedInt_parse32_bounded_integer_2(b);
  FStar_Pervasives_Native_option__K___uint32_t_uint32_t scrut1;
  if (scrut0.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut0.v.snd;
    uint32_t v1 = scrut0.v.fst;
    if (!(v1 < (uint32_t)2U || (uint32_t)65534U < v1))
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v1, .snd = consumed }
          }
        );
    else
      scrut1 =
        (
          (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
    scrut1 =
      (
        (FStar_Pervasives_Native_option__K___uint32_t_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t
  scrut2;
  if (scrut1.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t l = scrut1.v.snd;
    uint32_t v1 = scrut1.v.fst;
    FStar_Bytes_bytes input_ = FStar_Bytes_slice(b, l, FStar_Bytes_len(b));
    FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t
    scrut0;
    if (FStar_Bytes_len(input_) < v1)
      scrut0 =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else
    {
      bool b = true;
      KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
      Prims_list__Parsers_CipherSuite_cipherSuite
      *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
      buf0[0U] = ((Prims_list__Parsers_CipherSuite_cipherSuite){ .tag = Prims_Nil });
      K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
      x0 =
        {
          .fst = true,
          .snd = {
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = FStar_Bytes_slice(input_, (uint32_t)0U, v1), .snd = buf0 }
          }
        };
      while (b)
      {
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
        x = x0.snd;
        K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
        ite;
        if (x.tag == FStar_Pervasives_Native_Some)
        {
          Prims_list__Parsers_CipherSuite_cipherSuite *accu_ = x.v.snd;
          FStar_Bytes_bytes input_1 = x.v.fst;
          uint32_t len1 = FStar_Bytes_len(input_1);
          if (len1 == (uint32_t)0U)
            ite =
              (
                (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite){
                  .fst = false,
                  .snd = x
                }
              );
          else
          {
            FStar_Pervasives_Native_option__K___Parsers_CipherSuite_cipherSuite_uint32_t
            scrut = Parsers_CipherSuite_cipherSuite_parser32(input_1);
            if (scrut.tag == FStar_Pervasives_Native_Some)
            {
              uint32_t consumed = scrut.v.snd;
              Parsers_CipherSuite_cipherSuite v2 = scrut.v.fst;
              if (consumed == (uint32_t)0U)
                ite =
                  (
                    (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite){
                      .fst = false,
                      .snd = { .tag = FStar_Pervasives_Native_None }
                    }
                  );
              else
              {
                FStar_Bytes_bytes input__ = FStar_Bytes_slice(input_1, consumed, len1);
                KRML_CHECK_SIZE(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite), (uint32_t)1U);
                Prims_list__Parsers_CipherSuite_cipherSuite
                *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Parsers_CipherSuite_cipherSuite));
                buf[0U]
                =
                  (
                    (Prims_list__Parsers_CipherSuite_cipherSuite){
                      .tag = Prims_Cons,
                      .hd = v2,
                      .tl = accu_
                    }
                  );
                ite =
                  (
                    (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite){
                      .fst = true,
                      .snd = {
                        .tag = FStar_Pervasives_Native_Some,
                        .v = { .fst = input__, .snd = buf }
                      }
                    }
                  );
              }
            }
            else if (scrut.tag == FStar_Pervasives_Native_None)
              ite =
                (
                  (K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite){
                    .fst = false,
                    .snd = { .tag = FStar_Pervasives_Native_None }
                  }
                );
            else
              ite =
                KRML_EABORT(K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite,
                  "unreachable (pattern matches are exhaustive in F*)");
          }
        }
        else
          ite =
            KRML_EABORT(K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite,
              "unreachable (pattern matches are exhaustive in F*)");
        x0 = ite;
        b = x0.fst;
      }
      K___bool_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
      scrut1 = x0;
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Prims_list__Parsers_CipherSuite_cipherSuite
      accu = scrut1.snd;
      FStar_Pervasives_Native_option__Prims_list__Parsers_CipherSuite_cipherSuite scrut2;
      if (accu.tag == FStar_Pervasives_Native_None)
        scrut2 =
          (
            (FStar_Pervasives_Native_option__Prims_list__Parsers_CipherSuite_cipherSuite){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (accu.tag == FStar_Pervasives_Native_Some)
      {
        Prims_list__Parsers_CipherSuite_cipherSuite *accu_ = accu.v.snd;
        scrut2 =
          (
            (FStar_Pervasives_Native_option__Prims_list__Parsers_CipherSuite_cipherSuite){
              .tag = FStar_Pervasives_Native_Some,
              .v = LowParse_SLow_List_list_rev__Parsers_CipherSuite_cipherSuite(accu_)
            }
          );
      }
      else
        scrut2 =
          KRML_EABORT(FStar_Pervasives_Native_option__Prims_list__Parsers_CipherSuite_cipherSuite,
            "unreachable (pattern matches are exhaustive in F*)");
      FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t
      scrut;
      if (scrut2.tag == FStar_Pervasives_Native_None)
        scrut =
          (
            (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (scrut2.tag == FStar_Pervasives_Native_Some)
      {
        Prims_list__Parsers_CipherSuite_cipherSuite *res = scrut2.v;
        scrut =
          (
            (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = {
                .fst = res,
                .snd = FStar_Bytes_len(FStar_Bytes_slice(input_, (uint32_t)0U, v1))
              }
            }
          );
      }
      else
        scrut =
          KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
      if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t consumed = scrut.v.snd;
        Prims_list__Parsers_CipherSuite_cipherSuite *v2 = scrut.v.fst;
        if (consumed == v1)
          scrut0 =
            (
              (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = v2, .snd = consumed }
              }
            );
        else
          scrut0 =
            (
              (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
                .tag = FStar_Pervasives_Native_None
              }
            );
      }
      else if (scrut.tag == FStar_Pervasives_Native_None)
        scrut0 =
          (
            (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else
        scrut0 =
          KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t,
            "unreachable (pattern matches are exhaustive in F*)");
    }
    if (scrut0.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t l_ = scrut0.v.snd;
      Prims_list__Parsers_CipherSuite_cipherSuite *v_ = scrut0.v.fst;
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = v_, .snd = l + l_ }
          }
        );
    }
    else
      scrut2 =
        (
          (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
            .tag = FStar_Pervasives_Native_None
          }
        );
  }
  else
    scrut2 =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t res;
  if (scrut2.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut2.v.snd;
    Prims_list__Parsers_CipherSuite_cipherSuite *x = scrut2.v.fst;
    res =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = x, .snd = consumed }
        }
      );
  }
  else
    res =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t
  scrut3;
  if (res.tag == FStar_Pervasives_Native_None)
    scrut3 =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (res.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = res.v.snd;
    Prims_list__Parsers_CipherSuite_cipherSuite *x = res.v.fst;
    Prims_list__Parsers_CipherSuite_cipherSuite *x1 = x;
    scrut3 =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = x1, .snd = consumed }
        }
      );
  }
  else
    scrut3 =
      KRML_EABORT(FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t,
        "unreachable (pattern matches are exhaustive in F*)");
  FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t scrut;
  if (scrut3.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut3.v.snd;
    Prims_list__Parsers_CipherSuite_cipherSuite *v1 = scrut3.v.fst;
    scrut =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = v1, .snd = consumed }
        }
      );
  }
  else
    scrut =
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t consumed = scrut.v.snd;
    Prims_list__Parsers_CipherSuite_cipherSuite *l = scrut.v.fst;
    FStar_Bytes_bytes rem1 = FStar_Bytes_slice(b, consumed, FStar_Bytes_len(b));
    return
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = l, .snd = rem1 }
        }
      );
  }
  else if (scrut.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSError_fatal__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
HandshakeMessages_error__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Prims_string s
)
{
  return
    TLSError_fatal__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static Prims_int
FStar_List_Tot_Base_length__Parsers_CipherSuite_cipherSuite(
  Prims_list__Parsers_CipherSuite_cipherSuite *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Parsers_CipherSuite_cipherSuite *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__Parsers_CipherSuite_cipherSuite(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSError_fatal__Prims_list_Parsers_CompressionMethod_compressionMethod___FStar_Pervasives_Native_option_Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
HandshakeMessages_error__Prims_list_Parsers_CompressionMethod_compressionMethod___FStar_Pervasives_Native_option_Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(
  Prims_string s
)
{
  return
    TLSError_fatal__Prims_list_Parsers_CompressionMethod_compressionMethod___FStar_Pervasives_Native_option_Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static Prims_int
FStar_List_Tot_Base_length__Extensions_extension_(
  Prims_list__Extensions_extension_ *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Extensions_extension_ *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__Extensions_extension_(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_int
FStar_List_Tot_Base_length__Parsers_CompressionMethod_compressionMethod(
  Prims_list__Parsers_CompressionMethod_compressionMethod *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Parsers_CompressionMethod_compressionMethod *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__Parsers_CompressionMethod_compressionMethod(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
HandshakeMessages_parseClientHello(FStar_Bytes_bytes data)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)35))
    return
      HandshakeMessages_error__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("ClientHello is too short");
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(data, (uint32_t)2U);
    FStar_Bytes_bytes clVerBytes = scrut0.fst;
    FStar_Bytes_bytes cr_data = scrut0.snd;
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut1 = FStar_Bytes_split(cr_data, (uint32_t)32U);
    FStar_Bytes_bytes cr = scrut1.fst;
    FStar_Bytes_bytes data1 = scrut1.snd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
    scrut2 = TLSConstants_parseVersion(clVerBytes);
    if (scrut2.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut2.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut2.tag == FStar_Error_Correct)
    {
      Parsers_ProtocolVersion_protocolVersion cv = scrut2.val.case_Correct;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut0 = Parse_vlsplit((krml_checked_int_t)1, data1);
      if (scrut0.tag == FStar_Error_Error)
        return
          HandshakeMessages_error__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("sid length");
      else if (scrut0.tag == FStar_Error_Correct)
      {
        K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut0.val.case_Correct;
        FStar_Bytes_bytes sid = x.fst;
        FStar_Bytes_bytes data2 = x.snd;
        if
        (
          Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(sid)),
            (krml_checked_int_t)32)
          || Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data2)), (krml_checked_int_t)2)
        )
          return
            HandshakeMessages_error__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("sid");
        else
        {
          FStar_Pervasives_Native_option__K___Prims_list__Parsers_CipherSuite_cipherSuite_FStar_Bytes_bytes
          scrut0 = HandshakeMessages_parseVLCipherSuites(data2);
          if (scrut0.tag == FStar_Pervasives_Native_None)
            return
              HandshakeMessages_error__HandshakeMessages_ch___FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("ciphersuites");
          else if (scrut0.tag == FStar_Pervasives_Native_Some)
          {
            FStar_Bytes_bytes data3 = scrut0.v.snd;
            Prims_list__Parsers_CipherSuite_cipherSuite *clientCipherSuites = scrut0.v.fst;
            FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
            compExts;
            if
            (
              Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data3)),
                (krml_checked_int_t)1)
              ||
                Prims_op_GreaterThanOrEqual(FStar_List_Tot_Base_length__Parsers_CipherSuite_cipherSuite(clientCipherSuites),
                  (krml_checked_int_t)256)
            )
              compExts =
                HandshakeMessages_error__Prims_list_Parsers_CompressionMethod_compressionMethod___FStar_Pervasives_Native_option_Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("ciphersuites length");
            else
            {
              FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
              scrut0 = Parse_vlsplit((krml_checked_int_t)1, data3);
              if (scrut0.tag == FStar_Error_Error)
                compExts =
                  TLSError_fatal__Prims_list_Parsers_CompressionMethod_compressionMethod___FStar_Pervasives_Native_option_Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes(Parsers_AlertDescription_Decode_error,
                    FStar_Error_perror("HandshakeMessages.fst",
                      (krml_checked_int_t)415,
                      "Failed to parse compression bytes"));
              else if (scrut0.tag == FStar_Error_Correct)
              {
                K___FStar_Bytes_bytes_FStar_Bytes_bytes x1 = scrut0.val.case_Correct;
                FStar_Bytes_bytes cmBytes = x1.fst;
                FStar_Bytes_bytes extensions = x1.snd;
                Prims_list__Parsers_CompressionMethod_compressionMethod
                *cm = TLSConstants_parseCompressions(cmBytes);
                FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
                scrut = Extensions_parseOptExtensions(Extensions_EM_ClientHello, extensions);
                if (scrut.tag == FStar_Error_Error)
                {
                  K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
                  compExts =
                    (
                      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                        .tag = FStar_Error_Error,
                        .val = { .case_Error = z }
                      }
                    );
                }
                else if (scrut.tag == FStar_Error_Correct)
                {
                  K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
                  x2 = scrut.val.case_Correct;
                  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ exts = x2.fst;
                  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes obinders = x2.snd;
                  bool ite;
                  if (exts.tag == FStar_Pervasives_Native_None)
                    ite = true;
                  else if (exts.tag == FStar_Pervasives_Native_Some)
                  {
                    Prims_list__Extensions_extension_ *l = exts.v;
                    ite =
                      Prims_op_LessThan(FStar_List_Tot_Base_length__Extensions_extension_(l),
                        (krml_checked_int_t)256);
                  }
                  else
                    ite = KRML_EABORT(bool, "unreachable (pattern matches are exhaustive in F*)");
                  if
                  (
                    ite
                    &&
                      Prims_op_LessThan(FStar_List_Tot_Base_length__Parsers_CompressionMethod_compressionMethod(cm),
                        (krml_checked_int_t)256)
                    &&
                      Prims_op_GreaterThan(FStar_List_Tot_Base_length__Parsers_CompressionMethod_compressionMethod(cm),
                        (krml_checked_int_t)0)
                  )
                    compExts =
                      (
                        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                          .tag = FStar_Error_Correct,
                          .val = {
                            .case_Correct = {
                              .fst = cm,
                              .snd = {
                                .fst = HandshakeMessages_coercion_helper(exts),
                                .snd = obinders
                              }
                            }
                          }
                        }
                      );
                  else
                    compExts =
                      HandshakeMessages_error__Prims_list_Parsers_CompressionMethod_compressionMethod___FStar_Pervasives_Native_option_Prims_list_Extensions_extension____FStar_Pervasives_Native_option_Prims_list_FStar_Bytes_bytes("bad extension lengths");
                }
                else
                  compExts =
                    KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes,
                      "unreachable (pattern matches are exhaustive in F*)");
              }
              else
                compExts =
                  KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Parsers_CompressionMethod_compressionMethod_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes,
                    "unreachable (pattern matches are exhaustive in F*)");
            }
            if (compExts.tag == FStar_Error_Error)
            {
              K___Parsers_Alert_alert_Prims_string z = compExts.val.case_Error;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                    .tag = FStar_Error_Error,
                    .val = { .case_Error = z }
                  }
                );
            }
            else if (compExts.tag == FStar_Error_Correct)
            {
              FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
              obinders = compExts.val.case_Correct.snd.snd;
              FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
              exts = compExts.val.case_Correct.snd.fst;
              Prims_list__Parsers_CompressionMethod_compressionMethod
              *cm = compExts.val.case_Correct.fst;
              Prims_list__Parsers_CipherSuite_cipherSuite *cCS = clientCipherSuites;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
                    .tag = FStar_Error_Correct,
                    .val = {
                      .case_Correct = {
                        .fst = {
                          .ch_protocol_version = cv, .ch_client_random = cr, .ch_sessionID = sid,
                          .ch_cipher_suites = cCS, .ch_compressions = cm, .ch_extensions = exts
                        },
                        .snd = obinders
                      }
                    }
                  }
                );
            }
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Bytes_bytes HandshakeMessages_serverHelloBytes(HandshakeMessages_sh sh)
{
  Parsers_ProtocolVersion_protocolVersion pv;
  if (sh.sh_protocol_version.tag == Parsers_ProtocolVersion_TLS_1p3)
    pv = ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p2 });
  else
    pv = sh.sh_protocol_version;
  FStar_Bytes_bytes verB = TLSConstants_versionBytes(pv);
  FStar_Bytes_bytes sidB = Parse_vlbytes((krml_checked_int_t)1, sh.sh_sessionID);
  FStar_Bytes_bytes csB = CipherSuite_cipherSuiteNameBytes(sh.sh_cipher_suite);
  FStar_Bytes_bytes cmB = TLSConstants_compressionBytes(sh.sh_compression);
  FStar_Bytes_bytes extB;
  if (sh.sh_extensions.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Extensions_extension_ *ext = sh.sh_extensions.v;
    extB = Extensions_extensionsBytes(ext);
  }
  else if (sh.sh_extensions.tag == FStar_Pervasives_Native_None)
    extB = FStar_Bytes_empty_bytes;
  else
    extB = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  FStar_Bytes_bytes
  data =
    FStar_Bytes_append(verB,
      FStar_Bytes_append(sh.sh_server_random,
        FStar_Bytes_append(sidB, FStar_Bytes_append(csB, FStar_Bytes_append(cmB, extB)))));
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_server_hello, data);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh
TLSError_fatal__HandshakeMessages_sh(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh
FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_sh(
  HandshakeMessages_sh x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh
HandshakeMessages_parseServerHello(FStar_Bytes_bytes data)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)34))
    return
      TLSError_fatal__HandshakeMessages_sh(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)570, ""));
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut0 = HandshakeMessages_split2(data, (krml_checked_int_t)2, (krml_checked_int_t)32);
    FStar_Bytes_bytes serverVerBytes = scrut0.fst;
    FStar_Bytes_bytes serverRandomBytes = scrut0.snd;
    FStar_Bytes_bytes data1 = scrut0.thd;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_ProtocolVersion_protocolVersion
    scrut1 = TLSConstants_parseVersion(serverVerBytes);
    if (scrut1.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut1.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut1.tag == FStar_Error_Correct)
    {
      Parsers_ProtocolVersion_protocolVersion serverVer = scrut1.val.case_Correct;
      if
      (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data1)), (krml_checked_int_t)1))
      {
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
        scrut = Parse_vlsplit((krml_checked_int_t)1, data1);
        if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else if (scrut.tag == FStar_Error_Correct)
        {
          K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut.val.case_Correct;
          FStar_Bytes_bytes sid = x.fst;
          FStar_Bytes_bytes data2 = x.snd;
          if
          (Prims_op_LessThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(sid)), (krml_checked_int_t)32))
            if
            (
              Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data2)),
                (krml_checked_int_t)3)
            )
            {
              K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes
              scrut = HandshakeMessages_split2(data2, (krml_checked_int_t)2, (krml_checked_int_t)1);
              FStar_Bytes_bytes csBytes = scrut.fst;
              FStar_Bytes_bytes cmBytes = scrut.snd;
              FStar_Bytes_bytes data3 = scrut.thd;
              Parsers_CipherSuite_cipherSuite cs = CipherSuite_parseCipherSuiteName(csBytes);
              Parsers_CompressionMethod_compressionMethod
              cm = TLSConstants_parseCompression(cmBytes);
              if (cm.tag == Parsers_CompressionMethod_Unknown_compressionMethod)
                return
                  TLSError_fatal__HandshakeMessages_sh(Parsers_AlertDescription_Decode_error,
                    FStar_Error_perror("HandshakeMessages.fst",
                      (krml_checked_int_t)588,
                      "server selected a compression mode"));
              else if (cm.tag == Parsers_CompressionMethod_NullCompression)
              {
                Extensions_ext_msg em;
                if
                (
                  __eq__FStar_Bytes_bytes(FStar_Bytes_bytes_of_hex("cf21ad74e59a6111be1d8c021e65b891c2a211167abb8c5e079e09e2c8a8339c"),
                    serverRandomBytes)
                )
                  em = Extensions_EM_HelloRetryRequest;
                else
                  em = Extensions_EM_ServerHello;
                FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
                scrut = Extensions_parseOptExtensions(em, data3);
                if (scrut.tag == FStar_Error_Error)
                {
                  K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
                  return
                    (
                      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh){
                        .tag = FStar_Error_Error,
                        .val = { .case_Error = z }
                      }
                    );
                }
                else if (scrut.tag == FStar_Error_Correct)
                {
                  K___FStar_Pervasives_Native_option__Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
                  x1 = scrut.val.case_Correct;
                  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ exts = x1.fst;
                  bool ite;
                  if (exts.tag == FStar_Pervasives_Native_None)
                    ite = true;
                  else if (exts.tag == FStar_Pervasives_Native_Some)
                  {
                    Prims_list__Extensions_extension_ *l = exts.v;
                    ite =
                      Prims_op_LessThan(FStar_List_Tot_Base_length__Extensions_extension_(l),
                        (krml_checked_int_t)256);
                  }
                  else
                    ite = KRML_EABORT(bool, "unreachable (pattern matches are exhaustive in F*)");
                  if (ite)
                  {
                    FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
                    exts1 = HandshakeMessages_coercion_helper(exts);
                    return
                      FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_sh((
                          (HandshakeMessages_sh){
                            .sh_protocol_version = serverVer,
                            .sh_server_random = serverRandomBytes,
                            .sh_sessionID = sid,
                            .sh_cipher_suite = cs,
                            .sh_compression = { .tag = Parsers_CompressionMethod_NullCompression },
                            .sh_extensions = exts1
                          }
                        ));
                  }
                  else
                    return
                      TLSError_fatal__HandshakeMessages_sh(Parsers_AlertDescription_Decode_error,
                        FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)609, ""));
                }
                else
                {
                  KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                    __FILE__,
                    __LINE__,
                    "unreachable (pattern matches are exhaustive in F*)");
                  KRML_HOST_EXIT(255U);
                }
              }
              else
              {
                KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                  __FILE__,
                  __LINE__,
                  "unreachable (pattern matches are exhaustive in F*)");
                KRML_HOST_EXIT(255U);
              }
            }
            else
              return
                TLSError_fatal__HandshakeMessages_sh(Parsers_AlertDescription_Decode_error,
                  FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)610, ""));
          else
            return
              TLSError_fatal__HandshakeMessages_sh(Parsers_AlertDescription_Decode_error,
                FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)611, ""));
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
        return
          TLSError_fatal__HandshakeMessages_sh(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)612, ""));
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Bytes_bytes HandshakeMessages_helloRequestBytes;

FStar_Bytes_bytes HandshakeMessages_ccsBytes;

FStar_Bytes_bytes HandshakeMessages_serverHelloDoneBytes;

static FStar_Bytes_bytes HandshakeMessages_certificateBytes(Prims_list__FStar_Bytes_bytes *crt)
{
  FStar_Bytes_bytes cb = Cert_certificateListBytes(crt);
  return
    HandshakeMessages_messageBytes(HandshakeMessages_HT_certificate,
      Parse_vlbytes((krml_checked_int_t)3, cb));
}

static FStar_Bytes_bytes HandshakeMessages_certificateBytes13(HandshakeMessages_crt13 crt)
{
  FStar_Bytes_bytes cb = Cert_certificateListBytes13(crt.crt_chain13);
  return
    HandshakeMessages_messageBytes(HandshakeMessages_HT_certificate,
      FStar_Bytes_append(Parse_vlbytes((krml_checked_int_t)1, FStar_Bytes_empty_bytes),
        Parse_vlbytes((krml_checked_int_t)3, cb)));
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt
TLSError_fatal__HandshakeMessages_crt(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt
HandshakeMessages_error__HandshakeMessages_crt(Prims_string s)
{
  return
    TLSError_fatal__HandshakeMessages_crt(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt
HandshakeMessages_parseCertificate(FStar_Bytes_bytes data)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)3))
    return
      HandshakeMessages_error__HandshakeMessages_crt("not enough certificate-list length bytes");
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut0 = Parse_vlparse((krml_checked_int_t)3, data);
    if (scrut0.tag == FStar_Error_Error)
    {
      Prims_string y = scrut0.val.case_Error.snd;
      return TLSError_fatal__HandshakeMessages_crt(Parsers_AlertDescription_Bad_certificate, y);
    }
    else if (scrut0.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes certList = scrut0.val.case_Correct;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__FStar_Bytes_bytes
      scrut = Cert_parseCertificateList(certList);
      if (scrut.tag == FStar_Error_Error)
      {
        Prims_string y = scrut.val.case_Error.snd;
        return TLSError_fatal__HandshakeMessages_crt(Parsers_AlertDescription_Bad_certificate, y);
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__FStar_Bytes_bytes *l = scrut.val.case_Correct;
        if
        (
          Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(certList)),
            (krml_checked_int_t)16777212)
        )
          return HandshakeMessages_error__HandshakeMessages_crt("certificate list is too large");
        else
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt){
                .tag = FStar_Error_Correct,
                .val = { .case_Correct = l }
              }
            );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13
TLSError_fatal__HandshakeMessages_crt13(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13
HandshakeMessages_error__HandshakeMessages_crt13(Prims_string s)
{
  return
    TLSError_fatal__HandshakeMessages_crt13(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13
HandshakeMessages_parseCertificate13(FStar_Bytes_bytes data)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)1))
    return HandshakeMessages_error__HandshakeMessages_crt13("not enough bytes (context)");
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(data, (uint32_t)1U);
    FStar_Bytes_bytes hdr = scrut0.fst;
    FStar_Bytes_bytes data1 = scrut0.snd;
    if (!__eq__FStar_Bytes_bytes(hdr, FStar_Bytes_abyte((uint8_t)0U)))
      return HandshakeMessages_error__HandshakeMessages_crt13("non-empty context");
    else if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data1)), (krml_checked_int_t)3))
      return
        HandshakeMessages_error__HandshakeMessages_crt13("not enough bytes (certificate list length)");
    else
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
      scrut0 = Parse_vlparse((krml_checked_int_t)3, data1);
      if (scrut0.tag == FStar_Error_Error)
      {
        Prims_string y = scrut0.val.case_Error.snd;
        return TLSError_fatal__HandshakeMessages_crt13(Parsers_AlertDescription_Bad_certificate, y);
      }
      else if (scrut0.tag == FStar_Error_Correct)
      {
        FStar_Bytes_bytes certList = scrut0.val.case_Correct;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
        scrut = Cert_parseCertificateList13(certList);
        if (scrut.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else if (scrut.tag == FStar_Error_Correct)
        {
          Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
          *l = scrut.val.case_Correct;
          if
          (
            Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(certList)),
              (krml_checked_int_t)16777212)
          )
            return
              HandshakeMessages_error__HandshakeMessages_crt13("certificate list is too large");
          else
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .crt_request_context = FStar_Bytes_empty_bytes,
                      .crt_chain13 = l
                    }
                  }
                }
              );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
}

static FStar_Bytes_bytes HandshakeMessages_certificateRequestBytes(HandshakeMessages_cr cr)
{
  FStar_Bytes_bytes ctb = TLSConstants_certificateTypeListBytes(cr.cr_cert_types);
  FStar_Bytes_bytes ctB = Parse_vlbytes((krml_checked_int_t)1, ctb);
  FStar_Bytes_bytes saB;
  if (cr.cr_sig_algorithms.tag == FStar_Pervasives_Native_None)
    saB = FStar_Bytes_empty_bytes;
  else if (cr.cr_sig_algorithms.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Parsers_SignatureScheme_signatureScheme *sigAlgs = cr.cr_sig_algorithms.v;
    saB = TLSConstants_signatureSchemeListBytes(sigAlgs);
  }
  else
    saB = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  FStar_Bytes_bytes dnb = TLSConstants_distinguishedNameListBytes(cr.cr_certificate_authorities);
  FStar_Bytes_bytes dnB = Parse_vlbytes((krml_checked_int_t)2, dnb);
  FStar_Bytes_bytes data = FStar_Bytes_append(ctB, FStar_Bytes_append(saB, dnB));
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_certificate_request, data);
}

static Prims_int
FStar_List_Tot_Base_length__TLSConstants_certType(
  Prims_list__TLSConstants_certType *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__TLSConstants_certType *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__TLSConstants_certType(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_cr(
  HandshakeMessages_cr x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
TLSError_fatal__HandshakeMessages_cr(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
HandshakeMessages_parseCertificateRequest(
  Parsers_ProtocolVersion_protocolVersion pv,
  FStar_Bytes_bytes data
)
{
  if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)1))
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut0 = Parse_vlsplit((krml_checked_int_t)1, data);
    if (scrut0.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut0.tag == FStar_Error_Correct)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut0.val.case_Correct;
      FStar_Bytes_bytes certTypeListBytes = x.fst;
      FStar_Bytes_bytes data1 = x.snd;
      Prims_list__TLSConstants_certType
      *certTypeList = TLSConstants_parseCertificateTypeList(certTypeListBytes);
      Prims_int n1 = FStar_List_Tot_Base_length__TLSConstants_certType(certTypeList);
      if
      (
        Prims_op_LessThan((krml_checked_int_t)0,
          n1)
        && Prims_op_LessThan(n1, (krml_checked_int_t)256)
      )
        if
        (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data1)), (krml_checked_int_t)2))
          if (pv.tag == Parsers_ProtocolVersion_TLS_1p2)
          {
            FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
            scrut0 = Parse_vlsplit((krml_checked_int_t)2, data1);
            if (scrut0.tag == FStar_Error_Error)
            {
              K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
                    .tag = FStar_Error_Error,
                    .val = { .case_Error = z }
                  }
                );
            }
            else if (scrut0.tag == FStar_Error_Correct)
            {
              K___FStar_Bytes_bytes_FStar_Bytes_bytes x1 = scrut0.val.case_Correct;
              FStar_Bytes_bytes signatureAlgorithmsBytes = x1.fst;
              FStar_Bytes_bytes data2 = x1.snd;
              FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Parsers_SignatureScheme_signatureScheme
              scrut0 =
                TLSConstants_parseSignatureSchemeList(Parse_vlbytes((krml_checked_int_t)2,
                    signatureAlgorithmsBytes));
              if (scrut0.tag == FStar_Error_Error)
              {
                K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
                return
                  (
                    (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
                      .tag = FStar_Error_Error,
                      .val = { .case_Error = z }
                    }
                  );
              }
              else if (scrut0.tag == FStar_Error_Correct)
              {
                Prims_list__Parsers_SignatureScheme_signatureScheme
                *sigAlgs = scrut0.val.case_Correct;
                if
                (
                  Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data2)),
                    (krml_checked_int_t)2)
                )
                {
                  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
                  scrut = Parse_vlparse((krml_checked_int_t)2, data2);
                  if (scrut.tag == FStar_Error_Error)
                  {
                    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
                    return
                      (
                        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
                          .tag = FStar_Error_Error,
                          .val = { .case_Error = z }
                        }
                      );
                  }
                  else if (scrut.tag == FStar_Error_Correct)
                  {
                    FStar_Bytes_bytes certificateAuthoritiesBytes = scrut.val.case_Correct;
                    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_string), (uint32_t)1U);
                    Prims_list__Prims_string
                    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_string));
                    buf[0U] = ((Prims_list__Prims_string){ .tag = Prims_Nil });
                    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Prims_string
                    scrut =
                      TLSConstants_parseDistinguishedNameList(certificateAuthoritiesBytes,
                        buf);
                    if (scrut.tag == FStar_Error_Error)
                    {
                      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
                      return
                        (
                          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
                            .tag = FStar_Error_Error,
                            .val = { .case_Error = z }
                          }
                        );
                    }
                    else if (scrut.tag == FStar_Error_Correct)
                    {
                      Prims_list__Prims_string *distNamesList = scrut.val.case_Correct;
                      return
                        FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_cr((
                            (HandshakeMessages_cr){
                              .cr_cert_types = certTypeList,
                              .cr_sig_algorithms = {
                                .tag = FStar_Pervasives_Native_Some,
                                .v = sigAlgs
                              },
                              .cr_certificate_authorities = distNamesList
                            }
                          ));
                    }
                    else
                    {
                      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                        __FILE__,
                        __LINE__,
                        "unreachable (pattern matches are exhaustive in F*)");
                      KRML_HOST_EXIT(255U);
                    }
                  }
                  else
                  {
                    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                      __FILE__,
                      __LINE__,
                      "unreachable (pattern matches are exhaustive in F*)");
                    KRML_HOST_EXIT(255U);
                  }
                }
                else
                  return
                    TLSError_fatal__HandshakeMessages_cr(Parsers_AlertDescription_Decode_error,
                      FStar_Error_perror("HandshakeMessages.fst",
                        (krml_checked_int_t)897,
                        "Certificate Request message is too short"));
              }
              else
              {
                KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                  __FILE__,
                  __LINE__,
                  "unreachable (pattern matches are exhaustive in F*)");
                KRML_HOST_EXIT(255U);
              }
            }
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
          {
            KRML_CHECK_SIZE(sizeof (Prims_list__Prims_string), (uint32_t)1U);
            Prims_list__Prims_string *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_string));
            buf[0U] = ((Prims_list__Prims_string){ .tag = Prims_Nil });
            FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Prims_string
            scrut = TLSConstants_parseDistinguishedNameList(data1, buf);
            if (scrut.tag == FStar_Error_Error)
            {
              K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr){
                    .tag = FStar_Error_Error,
                    .val = { .case_Error = z }
                  }
                );
            }
            else if (scrut.tag == FStar_Error_Correct)
            {
              Prims_list__Prims_string *distNamesList = scrut.val.case_Correct;
              return
                FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_cr((
                    (HandshakeMessages_cr){
                      .cr_cert_types = certTypeList,
                      .cr_sig_algorithms = { .tag = FStar_Pervasives_Native_None },
                      .cr_certificate_authorities = distNamesList
                    }
                  ));
            }
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        else
          return
            TLSError_fatal__HandshakeMessages_cr(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst",
                (krml_checked_int_t)909,
                "Certificate Request message is too short"));
      else
        return
          TLSError_fatal__HandshakeMessages_cr(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("HandshakeMessages.fst",
              (krml_checked_int_t)910,
              "empty certificate_types in Certificate Request"));
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
    return
      TLSError_fatal__HandshakeMessages_cr(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("HandshakeMessages.fst",
          (krml_checked_int_t)911,
          "Certificate Request message is too short"));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
HandshakeMessages_error__HandshakeMessages_cr(Prims_string s)
{
  return
    TLSError_fatal__HandshakeMessages_cr(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
HandshakeMessages_parseCertificateRequest13(FStar_Bytes_bytes body)
{
  return
    HandshakeMessages_error__HandshakeMessages_cr("Certificate requests not yet implemented");
}

HandshakeMessages_kex_c
HandshakeMessages_kex_c_of_dh_key(CommonDH_group_ g1, CommonDH_pre_share_ kex)
{
  if (CommonDH_is_ec(g1))
    return
      (
        (HandshakeMessages_kex_c){
          .tag = HandshakeMessages_KEX_C_ECDHE,
          .val = { .case_KEX_C_ECDHE = CommonDH_serialize_raw(g1, kex) }
        }
      );
  else
    return
      (
        (HandshakeMessages_kex_c){
          .tag = HandshakeMessages_KEX_C_DHE,
          .val = { .case_KEX_C_DHE = CommonDH_serialize_raw(g1, kex) }
        }
      );
}

static FStar_Bytes_bytes HandshakeMessages_clientKeyExchangeBytes(HandshakeMessages_kex_c cke)
{
  FStar_Bytes_bytes kexB;
  if (cke.tag == HandshakeMessages_KEX_C_DHE)
  {
    FStar_Bytes_bytes b = cke.val.case_KEX_C_DHE;
    kexB = Parse_vlbytes((krml_checked_int_t)2, b);
  }
  else if (cke.tag == HandshakeMessages_KEX_C_ECDHE)
  {
    FStar_Bytes_bytes b = cke.val.case_KEX_C_ECDHE;
    kexB = Parse_vlbytes((krml_checked_int_t)1, b);
  }
  else if (cke.tag == HandshakeMessages_KEX_C_RSA)
  {
    FStar_Bytes_bytes encpms = cke.val.case_KEX_C_RSA;
    kexB = Parse_vlbytes((krml_checked_int_t)2, encpms);
  }
  else if (cke.tag == HandshakeMessages_KEX_C_DH)
    kexB = FStar_Bytes_empty_bytes;
  else
    kexB = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_client_key_exchange, kexB);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke
TLSError_fatal__HandshakeMessages_cke(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke
FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_cke(
  HandshakeMessages_kex_c x
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
        .tag = FStar_Error_Correct,
        .val = { .case_Correct = x }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke
HandshakeMessages_parseClientKeyExchange(CipherSuite_kexAlg kex, FStar_Bytes_bytes data)
{
  switch (kex)
  {
    case CipherSuite_Kex_DH:
      {
        if (FStar_UInt32_v(FStar_Bytes_len(data)) == (krml_checked_int_t)0)
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
                .tag = FStar_Error_Correct,
                .val = { .case_Correct = { .tag = HandshakeMessages_KEX_C_DH } }
              }
            );
        else
          return
            TLSError_fatal__HandshakeMessages_cke(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)975, ""));
        break;
      }
    case CipherSuite_Kex_DHE:
      {
        if
        (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)2))
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
          scrut = Parse_vlparse((krml_checked_int_t)2, data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Bytes_bytes y = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .tag = HandshakeMessages_KEX_C_DHE,
                      .val = { .case_KEX_C_DHE = y }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
          return
            TLSError_fatal__HandshakeMessages_cke(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)981, ""));
        break;
      }
    case CipherSuite_Kex_ECDHE:
      {
        if
        (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)1))
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
          scrut = Parse_vlparse((krml_checked_int_t)1, data);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Bytes_bytes y = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .tag = HandshakeMessages_KEX_C_ECDHE,
                      .val = { .case_KEX_C_ECDHE = y }
                    }
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
          return
            TLSError_fatal__HandshakeMessages_cke(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)987, ""));
        break;
      }
    case CipherSuite_Kex_RSA:
      {
        if
        (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)2))
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
          scrut = Parse_vlparse((krml_checked_int_t)2, data);
          if (scrut.tag == FStar_Error_Correct)
          {
            FStar_Bytes_bytes encPMS = scrut.val.case_Correct;
            if
            (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(encPMS)), (krml_checked_int_t)4096))
              return
                FStar_Error_correct__Parsers_Alert_alert___Prims_string_HandshakeMessages_cke((
                    (HandshakeMessages_kex_c){
                      .tag = HandshakeMessages_KEX_C_RSA,
                      .val = { .case_KEX_C_RSA = encPMS }
                    }
                  ));
            else
              return
                TLSError_fatal__HandshakeMessages_cke(Parsers_AlertDescription_Decode_error,
                  FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)997, ""));
          }
          else if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
          return
            TLSError_fatal__HandshakeMessages_cke(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst", (krml_checked_int_t)999, ""));
        break;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static FStar_Bytes_bytes HandshakeMessages_signatureBytes(HandshakeMessages_signature sig_6083)
{
  FStar_Bytes_bytes sig_bytes = Parse_vlbytes2(sig_6083.sig_signature);
  if (sig_6083.sig_algorithm.tag == FStar_Pervasives_Native_None)
    return sig_bytes;
  else if (sig_6083.sig_algorithm.tag == FStar_Pervasives_Native_Some)
  {
    Parsers_SignatureScheme_signatureScheme sigalg = sig_6083.sig_algorithm.v;
    FStar_Bytes_bytes
    sig_algorithm_bytes = Parsers_SignatureScheme_signatureScheme_serializer32(sigalg);
    return FStar_Bytes_append(sig_algorithm_bytes, sig_bytes);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
TLSError_fatal__HandshakeMessages_signature(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
HandshakeMessages_parseSignature(
  Parsers_ProtocolVersion_protocolVersion pv,
  FStar_Bytes_bytes data
)
{
  if
  (
    TLSConstants_geqPV(pv,
      ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p2 }))
  )
    if (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)4))
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(data, (uint32_t)2U);
      FStar_Bytes_bytes alg1 = scrut0.fst;
      FStar_Bytes_bytes sig_6139 = scrut0.snd;
      FStar_Pervasives_Native_option__K___Parsers_SignatureScheme_signatureScheme_uint32_t
      scrut1 = Parsers_SignatureScheme_signatureScheme_parser32(alg1);
      if (scrut1.tag == FStar_Pervasives_Native_Some)
      {
        Parsers_SignatureScheme_signatureScheme sigalg = scrut1.v.fst;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
        scrut = Parse_vlparse((krml_checked_int_t)2, sig_6139);
        if (scrut.tag == FStar_Error_Correct)
        {
          FStar_Bytes_bytes sigv = scrut.val.case_Correct;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .sig_algorithm = { .tag = FStar_Pervasives_Native_Some, .v = sigalg },
                    .sig_signature = sigv
                  }
                }
              }
            );
        }
        else
          return
            TLSError_fatal__HandshakeMessages_signature(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst",
                (krml_checked_int_t)1048,
                "Signature: incorrect signature length"));
      }
      else if (scrut1.tag == FStar_Pervasives_Native_None)
        return
          TLSError_fatal__HandshakeMessages_signature(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("HandshakeMessages.fst",
              (krml_checked_int_t)1050,
              "Signature: invalid signature scheme"));
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
      return
        TLSError_fatal__HandshakeMessages_signature(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("HandshakeMessages.fst",
            (krml_checked_int_t)1051,
            "Signature: message too short"));
  else if
  (Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)2))
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)2, data);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes sigv = scrut.val.case_Correct;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .sig_algorithm = { .tag = FStar_Pervasives_Native_None },
                .sig_signature = sigv
              }
            }
          }
        );
    }
    else
      return
        TLSError_fatal__HandshakeMessages_signature(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("HandshakeMessages.fst",
            (krml_checked_int_t)1059,
            "Signature: incorrect signature length"));
  }
  else
    return
      TLSError_fatal__HandshakeMessages_signature(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("HandshakeMessages.fst",
          (krml_checked_int_t)1060,
          "Signature: message too short"));
}

FStar_Bytes_bytes HandshakeMessages_kex_s_to_bytes(HandshakeMessages_kex_s kex)
{
  if (kex.tag == HandshakeMessages_KEX_S_DHE)
  {
    CommonDH_pre_share_ k1 = kex.val.case_KEX_S_DHE.snd;
    CommonDH_group_ g1 = kex.val.case_KEX_S_DHE.fst;
    return CommonDH_serialize(g1, k1);
  }
  else if (kex.tag == HandshakeMessages_KEX_S_RSA)
    return FStar_Bytes_empty_bytes;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

/*
 is this message parsed? 
*/
bool HandshakeMessages_parsed(HandshakeMessages_hs_msg uu___3_6267)
{
  if (uu___3_6267.tag == HandshakeMessages_Binders)
    return false;
  else if (uu___3_6267.tag == HandshakeMessages_MessageHash)
    return false;
  else
    return true;
}

static FStar_Bytes_bytes HandshakeMessages_serverKeyExchangeBytes(HandshakeMessages_ske ske)
{
  FStar_Bytes_bytes kexB = HandshakeMessages_kex_s_to_bytes(ske.ske_kex_s);
  FStar_Bytes_bytes sigB = HandshakeMessages_signatureBytes(ske.ske_signed_params);
  FStar_Bytes_bytes payload = FStar_Bytes_append(kexB, sigB);
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_server_key_exchange, payload);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske
TLSError_fatal__HandshakeMessages_ske(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske
HandshakeMessages_parseServerKeyExchange(
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_kexAlg kex,
  FStar_Bytes_bytes payload
)
{
  switch (kex)
  {
    case CipherSuite_Kex_DHE:
      {
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes
        scrut0 = CommonDH_parse_partial(false, payload);
        if (scrut0.tag == FStar_Error_Correct)
        {
          FStar_Bytes_bytes sigv = scrut0.val.case_Correct.snd;
          Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ k1 = scrut0.val.case_Correct.fst;
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
          scrut = HandshakeMessages_parseSignature(pv, sigv);
          if (scrut.tag == FStar_Error_Correct)
          {
            HandshakeMessages_signature sig_6382 = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .ske_kex_s = {
                        .tag = HandshakeMessages_KEX_S_DHE,
                        .val = { .case_KEX_S_DHE = k1 }
                      },
                      .ske_signed_params = sig_6382
                    }
                  }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else if (scrut0.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
        break;
      }
    case CipherSuite_Kex_ECDHE:
      {
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_dtuple2__CommonDH_group__CommonDH_pre_share__FStar_Bytes_bytes
        scrut0 = CommonDH_parse_partial(true, payload);
        if (scrut0.tag == FStar_Error_Correct)
        {
          FStar_Bytes_bytes sigv = scrut0.val.case_Correct.snd;
          Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ k1 = scrut0.val.case_Correct.fst;
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
          scrut = HandshakeMessages_parseSignature(pv, sigv);
          if (scrut.tag == FStar_Error_Correct)
          {
            HandshakeMessages_signature sig_6452 = scrut.val.case_Correct;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = {
                      .ske_kex_s = {
                        .tag = HandshakeMessages_KEX_S_DHE,
                        .val = { .case_KEX_S_DHE = k1 }
                      },
                      .ske_signed_params = sig_6452
                    }
                  }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else if (scrut0.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske){
                .tag = FStar_Error_Error,
                .val = { .case_Error = z }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
        break;
      }
    default:
      {
        return
          TLSError_fatal__HandshakeMessages_ske(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("HandshakeMessages.fst",
              (krml_checked_int_t)1138,
              "ServerKeyExchange: Unexpected Key Exchange"));
      }
  }
}

static FStar_Bytes_bytes
HandshakeMessages_certificateVerifyBytes(HandshakeMessages_signature cv)
{
  FStar_Bytes_bytes sigB = HandshakeMessages_signatureBytes(cv);
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_certificate_verify, sigB);
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
HandshakeMessages_parseCertificateVerify(
  Parsers_ProtocolVersion_protocolVersion pv,
  FStar_Bytes_bytes data
)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
  scrut = HandshakeMessages_parseSignature(pv, data);
  if (scrut.tag == FStar_Error_Correct)
  {
    HandshakeMessages_signature sig_6513 = scrut.val.case_Correct;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = sig_6513 }
        }
      );
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes HandshakeMessages_finishedBytes(FStar_Bytes_bytes fin)
{
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_finished, fin);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_fin
TLSError_fatal__HandshakeMessages_fin(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_fin){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_fin
HandshakeMessages_error__HandshakeMessages_fin(Prims_string s)
{
  return
    TLSError_fatal__HandshakeMessages_fin(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_fin
HandshakeMessages_parseFinished(FStar_Bytes_bytes data)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(data)), (krml_checked_int_t)65536))
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_fin){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = data }
        }
      );
  else
    return HandshakeMessages_error__HandshakeMessages_fin("Finished too large");
}

static FStar_Bytes_bytes HandshakeMessages_sessionTicketBytes(HandshakeMessages_sticket t)
{
  FStar_Bytes_bytes
  payload =
    FStar_Bytes_append(FStar_Bytes_bytes_of_int((krml_checked_int_t)4,
        FStar_UInt32_v(t.sticket_lifetime)),
      Parse_vlbytes((krml_checked_int_t)2, t.sticket_ticket));
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_session_ticket, payload);
}

static FStar_Bytes_bytes HandshakeMessages_sessionTicketBytes13(HandshakeMessages_sticket13 t)
{
  FStar_Bytes_bytes
  payload =
    FStar_Bytes_append(FStar_Bytes_bytes_of_int32(t.ticket13_lifetime),
      FStar_Bytes_append(FStar_Bytes_bytes_of_int32(t.ticket13_age_add),
        FStar_Bytes_append(Parse_vlbytes((krml_checked_int_t)1, t.ticket13_nonce),
          FStar_Bytes_append(Parse_vlbytes((krml_checked_int_t)2, t.ticket13_ticket),
            Extensions_extensionsBytes(t.ticket13_extensions)))));
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_session_ticket, payload);
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket
TLSError_fatal__HandshakeMessages_sticket(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket
HandshakeMessages_parseSessionTicket(FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)6))
    return
      TLSError_fatal__HandshakeMessages_sticket(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("HandshakeMessages.fst",
          (krml_checked_int_t)1233,
          "NewSessionTicket: too short"));
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(b, (uint32_t)4U);
    FStar_Bytes_bytes lifetimeB = scrut0.fst;
    FStar_Bytes_bytes ticketB = scrut0.snd;
    Prims_int lifetime = FStar_Bytes_int_of_bytes(lifetimeB);
    uint32_t lifetime1 = FStar_UInt32_uint_to_t(lifetime);
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes
    scrut = Parse_vlparse((krml_checked_int_t)2, ticketB);
    if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes ticket = scrut.val.case_Correct;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = { .sticket_lifetime = lifetime1, .sticket_ticket = ticket } }
          }
        );
    }
    else if (scrut.tag == FStar_Error_Error)
      return
        TLSError_fatal__HandshakeMessages_sticket(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("HandshakeMessages.fst",
            (krml_checked_int_t)1244,
            "NewSessionTicket: incorrect length"));
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket13
TLSError_fatal__HandshakeMessages_sticket13(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket13){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket13
HandshakeMessages_parseSessionTicket13(FStar_Bytes_bytes b)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(b)), (krml_checked_int_t)12))
    return
      TLSError_fatal__HandshakeMessages_sticket13(Parsers_AlertDescription_Decode_error,
        FStar_Error_perror("HandshakeMessages.fst",
          (krml_checked_int_t)1251,
          "NewSessionTicket13: too short"));
  else
  {
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(b, (uint32_t)4U);
    FStar_Bytes_bytes lifetimeB = scrut0.fst;
    FStar_Bytes_bytes rest = scrut0.snd;
    Prims_int lifetime = FStar_Bytes_int_of_bytes(lifetimeB);
    uint32_t lifetime1 = FStar_UInt32_uint_to_t(lifetime);
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut1 = FStar_Bytes_split(rest, (uint32_t)4U);
    FStar_Bytes_bytes ageB = scrut1.fst;
    FStar_Bytes_bytes rest1 = scrut1.snd;
    Prims_int age = FStar_Bytes_int_of_bytes(ageB);
    uint32_t age1 = FStar_UInt32_uint_to_t(age);
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut = Parse_vlsplit((krml_checked_int_t)1, rest1);
    if (scrut.tag == FStar_Error_Error)
      return
        TLSError_fatal__HandshakeMessages_sticket13(Parsers_AlertDescription_Decode_error,
          FStar_Error_perror("HandshakeMessages.fst",
            (krml_checked_int_t)1263,
            "NewSessionTicket13: invalid nonce (check draft version 21 or greater)"));
    else if (scrut.tag == FStar_Error_Correct)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes x = scrut.val.case_Correct;
      FStar_Bytes_bytes nonce = x.fst;
      FStar_Bytes_bytes rest2 = x.snd;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut = Parse_vlsplit((krml_checked_int_t)2, rest2);
      if (scrut.tag == FStar_Error_Correct)
      {
        K___FStar_Bytes_bytes_FStar_Bytes_bytes x1 = scrut.val.case_Correct;
        FStar_Bytes_bytes ticket = x1.fst;
        FStar_Bytes_bytes rest3 = x1.snd;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___FStar_Bytes_bytes_FStar_Bytes_bytes
        scrut = Parse_vlsplit((krml_checked_int_t)2, rest3);
        if (scrut.tag == FStar_Error_Correct)
        {
          K___FStar_Bytes_bytes_FStar_Bytes_bytes x2 = scrut.val.case_Correct;
          FStar_Bytes_bytes exts = x2.fst;
          FStar_Bytes_bytes eof = x2.snd;
          if (Prims_op_GreaterThan(FStar_UInt32_v(FStar_Bytes_len(eof)), (krml_checked_int_t)0))
            return
              TLSError_fatal__HandshakeMessages_sticket13(Parsers_AlertDescription_Decode_error,
                FStar_Error_perror("HandshakeMessages.fst",
                  (krml_checked_int_t)1275,
                  "NewSessionTicket13: dangling bytes"));
          else
          {
            FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
            scrut =
              Extensions_parseExtensions(Extensions_EM_NewSessionTicket,
                Parse_vlbytes((krml_checked_int_t)2, exts));
            if
            (
              scrut.tag
              == FStar_Error_Correct
              && scrut.val.case_Correct.snd.tag == FStar_Pervasives_Native_None
            )
            {
              Prims_list__Extensions_extension_ *exts1 = scrut.val.case_Correct.fst;
              return
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket13){
                    .tag = FStar_Error_Correct,
                    .val = {
                      .case_Correct = {
                        .ticket13_lifetime = lifetime1, .ticket13_age_add = age1,
                        .ticket13_nonce = nonce, .ticket13_ticket = ticket,
                        .ticket13_extensions = exts1
                      }
                    }
                  }
                );
            }
            else if (scrut.tag == FStar_Error_Error)
              return
                TLSError_fatal__HandshakeMessages_sticket13(Parsers_AlertDescription_Decode_error,
                  FStar_Error_perror("HandshakeMessages.fst",
                    (krml_checked_int_t)1285,
                    "NewSessionTicket13: invalid extensions"));
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
        else if (scrut.tag == FStar_Error_Error)
          return
            TLSError_fatal__HandshakeMessages_sticket13(Parsers_AlertDescription_Decode_error,
              FStar_Error_perror("HandshakeMessages.fst",
                (krml_checked_int_t)1287,
                "NewSessionTicket13: incorrect length"));
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else if (scrut.tag == FStar_Error_Error)
        return
          TLSError_fatal__HandshakeMessages_sticket13(Parsers_AlertDescription_Decode_error,
            FStar_Error_perror("HandshakeMessages.fst",
              (krml_checked_int_t)1289,
              "NewSessionTicket13: incorrect length"));
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

FStar_Bytes_bytes HandshakeMessages_helloRetryRequestBytes(HandshakeMessages_hrr hrr)
{
  return
    HandshakeMessages_serverHelloBytes((
        (HandshakeMessages_sh){
          .sh_protocol_version = { .tag = Parsers_ProtocolVersion_TLS_1p2 },
          .sh_server_random = FStar_Bytes_bytes_of_hex("cf21ad74e59a6111be1d8c021e65b891c2a211167abb8c5e079e09e2c8a8339c"),
          .sh_sessionID = hrr.hrr_sessionID,
          .sh_cipher_suite = hrr.hrr_cipher_suite,
          .sh_compression = { .tag = Parsers_CompressionMethod_NullCompression },
          .sh_extensions = { .tag = FStar_Pervasives_Native_Some, .v = hrr.hrr_extensions }
        }
      ));
}

static FStar_Bytes_bytes
HandshakeMessages_encryptedExtensionsBytes(Prims_list__Extensions_extension_ *ee)
{
  FStar_Bytes_bytes payload = Extensions_extensionsBytes(ee);
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_encrypted_extensions, payload);
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
HandshakeMessages_error__Prims_list_Extensions_extension_(Prims_string s)
{
  return
    TLSError_fatal__Prims_list_Extensions_extension_(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
HandshakeMessages_parseEncryptedExtensions(FStar_Bytes_bytes payload)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__Extensions_extension__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
  scrut = Extensions_parseExtensions(Extensions_EM_EncryptedExtensions, payload);
  if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else if
  (
    scrut.tag
    == FStar_Error_Correct
    && scrut.val.case_Correct.snd.tag == FStar_Pervasives_Native_None
  )
  {
    Prims_list__Extensions_extension_ *exts = scrut.val.case_Correct.fst;
    if
    (
      Prims_op_GreaterThanOrEqual(FStar_List_Tot_Base_length__Extensions_extension_(exts),
        (krml_checked_int_t)256)
    )
      return HandshakeMessages_error__Prims_list_Extensions_extension_("too many extensions");
    else
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = exts }
          }
        );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes HandshakeMessages_endOfEarlyDataBytes;

static FStar_Bytes_bytes HandshakeMessages_keyUpdateBytes(bool u2)
{
  uint8_t ite;
  if (u2)
    ite = (uint8_t)1U;
  else
    ite = (uint8_t)0U;
  return HandshakeMessages_messageBytes(HandshakeMessages_HT_key_update, FStar_Bytes_abyte(ite));
}

static FStar_Bytes_bytes HandshakeMessages_certificateRequestBytes13(HandshakeMessages_cr cr)
{
  return
    HandshakeMessages_messageBytes(HandshakeMessages_HT_certificate_request,
      FStar_Bytes_empty_bytes);
}

FStar_Bytes_bytes
HandshakeMessages_handshakeMessageBytes(
  FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion pvo,
  HandshakeMessages_hs_msg uu___0_6989
)
{
  if (uu___0_6989.tag == HandshakeMessages_ClientHello)
  {
    HandshakeMessages_ch ch = uu___0_6989.val.case_ClientHello;
    return HandshakeMessages_clientHelloBytes(ch);
  }
  else if (uu___0_6989.tag == HandshakeMessages_ServerHello)
  {
    HandshakeMessages_sh sh = uu___0_6989.val.case_ServerHello;
    return HandshakeMessages_serverHelloBytes(sh);
  }
  else if (uu___0_6989.tag == HandshakeMessages_Certificate)
  {
    Prims_list__FStar_Bytes_bytes *c = uu___0_6989.val.case_Certificate;
    return HandshakeMessages_certificateBytes(c);
  }
  else if (uu___0_6989.tag == HandshakeMessages_Certificate13)
  {
    HandshakeMessages_crt13 c = uu___0_6989.val.case_Certificate13;
    return HandshakeMessages_certificateBytes13(c);
  }
  else if (uu___0_6989.tag == HandshakeMessages_ServerKeyExchange)
  {
    HandshakeMessages_ske ske = uu___0_6989.val.case_ServerKeyExchange;
    return HandshakeMessages_serverKeyExchangeBytes(ske);
  }
  else if (uu___0_6989.tag == HandshakeMessages_ServerHelloDone)
    return HandshakeMessages_serverHelloDoneBytes;
  else if (uu___0_6989.tag == HandshakeMessages_ClientKeyExchange)
  {
    HandshakeMessages_kex_c cke = uu___0_6989.val.case_ClientKeyExchange;
    return HandshakeMessages_clientKeyExchangeBytes(cke);
  }
  else if (uu___0_6989.tag == HandshakeMessages_Finished)
  {
    FStar_Bytes_bytes f = uu___0_6989.val.case_Finished;
    return HandshakeMessages_finishedBytes(f);
  }
  else if (uu___0_6989.tag == HandshakeMessages_NewSessionTicket)
  {
    HandshakeMessages_sticket t = uu___0_6989.val.case_NewSessionTicket;
    return HandshakeMessages_sessionTicketBytes(t);
  }
  else if (uu___0_6989.tag == HandshakeMessages_NewSessionTicket13)
  {
    HandshakeMessages_sticket13 t = uu___0_6989.val.case_NewSessionTicket13;
    return HandshakeMessages_sessionTicketBytes13(t);
  }
  else if (uu___0_6989.tag == HandshakeMessages_EncryptedExtensions)
  {
    Prims_list__Extensions_extension_ *e = uu___0_6989.val.case_EncryptedExtensions;
    return HandshakeMessages_encryptedExtensionsBytes(e);
  }
  else if (uu___0_6989.tag == HandshakeMessages_CertificateRequest)
  {
    HandshakeMessages_cr cr = uu___0_6989.val.case_CertificateRequest;
    return HandshakeMessages_certificateRequestBytes(cr);
  }
  else if (uu___0_6989.tag == HandshakeMessages_CertificateVerify)
  {
    HandshakeMessages_signature cv = uu___0_6989.val.case_CertificateVerify;
    return HandshakeMessages_certificateVerifyBytes(cv);
  }
  else if (uu___0_6989.tag == HandshakeMessages_HelloRequest)
    return HandshakeMessages_helloRequestBytes;
  else if (uu___0_6989.tag == HandshakeMessages_HelloRetryRequest)
  {
    HandshakeMessages_hrr hrr = uu___0_6989.val.case_HelloRetryRequest;
    return HandshakeMessages_helloRetryRequestBytes(hrr);
  }
  else if (uu___0_6989.tag == HandshakeMessages_EndOfEarlyData)
    return HandshakeMessages_endOfEarlyDataBytes;
  else if (uu___0_6989.tag == HandshakeMessages_CertificateRequest13)
  {
    HandshakeMessages_cr cr = uu___0_6989.val.case_CertificateRequest13;
    return HandshakeMessages_certificateRequestBytes13(cr);
  }
  else if (uu___0_6989.tag == HandshakeMessages_KeyUpdate)
  {
    bool u2 = uu___0_6989.val.case_KeyUpdate;
    return HandshakeMessages_keyUpdateBytes(u2);
  }
  else if (uu___0_6989.tag == HandshakeMessages_Binders)
  {
    Prims_list__FStar_Bytes_bytes *bs = uu___0_6989.val.case_Binders;
    return Extensions_bindersBytes(bs);
  }
  else if (uu___0_6989.tag == HandshakeMessages_MessageHash)
    return uu___0_6989.val.case_MessageHash;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes
HandshakeMessages_handshakeMessagesBytes(
  FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion pv,
  Prims_list__HandshakeMessages_hs_msg *uu___1_7111
)
{
  if (uu___1_7111->tag == Prims_Nil)
    return FStar_Bytes_empty_bytes;
  else if (uu___1_7111->tag == Prims_Cons)
  {
    Prims_list__HandshakeMessages_hs_msg *t = uu___1_7111->tl;
    HandshakeMessages_hs_msg h1 = uu___1_7111->hd;
    return
      FStar_Bytes_append(HandshakeMessages_handshakeMessageBytes(pv, h1),
        HandshakeMessages_handshakeMessagesBytes(pv, t));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_string HandshakeMessages_string_of_handshakeMessage(HandshakeMessages_hs_msg hs)
{
  if (hs.tag == HandshakeMessages_ClientHello)
    return "ClientHello";
  else if (hs.tag == HandshakeMessages_ServerHello)
    return "ServerHello";
  else if (hs.tag == HandshakeMessages_CertificateVerify)
    return "CertificateVerify";
  else if (hs.tag == HandshakeMessages_Finished)
    return "Finished";
  else if (hs.tag == HandshakeMessages_ClientKeyExchange)
    return "ClientKeyExchange";
  else if (hs.tag == HandshakeMessages_ServerKeyExchange)
    return "ServerKeyExchange";
  else if (hs.tag == HandshakeMessages_ServerHelloDone)
    return "ServerHelloDone";
  else if (hs.tag == HandshakeMessages_Certificate)
    return "Certificate";
  else if (hs.tag == HandshakeMessages_CertificateRequest)
    return "CertificateRequest";
  else if (hs.tag == HandshakeMessages_HelloRequest)
    return "HelloRequest";
  else if (hs.tag == HandshakeMessages_NewSessionTicket)
    return "NewSessionTicket";
  else if (hs.tag == HandshakeMessages_EndOfEarlyData)
    return "EndOfEarlyData";
  else if (hs.tag == HandshakeMessages_EncryptedExtensions)
    return "EncryptedExtensions";
  else if (hs.tag == HandshakeMessages_Certificate13)
    return "Certificate13";
  else if (hs.tag == HandshakeMessages_CertificateRequest13)
    return "CertificateRequest13";
  else if (hs.tag == HandshakeMessages_HelloRetryRequest)
    return "HelloRetryRequest";
  else if (hs.tag == HandshakeMessages_NewSessionTicket13)
    return "NewSessionTicket13";
  else if (hs.tag == HandshakeMessages_KeyUpdate)
  {
    bool b = hs.val.case_KeyUpdate;
    Prims_string ite;
    if (b)
      ite = "1";
    else
      ite = "2";
    return Prims_strcat("KeyUpdate", ite);
  }
  else if (hs.tag == HandshakeMessages_Binders)
    return "Binders";
  else if (hs.tag == HandshakeMessages_MessageHash)
    return "MessageHash";
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool
TLSError_fatal__bool(Parsers_AlertDescription_alertDescription a, Prims_string s)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool
HandshakeMessages_error__bool(Prims_string s)
{
  return
    TLSError_fatal__bool(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool
HandshakeMessages_parseBoolean(FStar_Bytes_bytes body)
{
  if (__eq__FStar_Bytes_bytes(body, FStar_Bytes_abyte((uint8_t)1U)))
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = true }
        }
      );
  else if (__eq__FStar_Bytes_bytes(body, FStar_Bytes_abyte((uint8_t)0U)))
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = false }
        }
      );
  else
    return HandshakeMessages_error__bool("not a boolean");
}

typedef struct FStar_Pervasives_Native_option__HandshakeMessages_hrr_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  HandshakeMessages_hrr v;
}
FStar_Pervasives_Native_option__HandshakeMessages_hrr;

static FStar_Pervasives_Native_option__HandshakeMessages_hrr
HandshakeMessages_helloRetryRequest_of_serverHello(HandshakeMessages_sh sh)
{
  if
  (
    __eq__FStar_Bytes_bytes(sh.sh_server_random,
      FStar_Bytes_bytes_of_hex("cf21ad74e59a6111be1d8c021e65b891c2a211167abb8c5e079e09e2c8a8339c"))
  )
  {
    Prims_list__Extensions_extension_ *ite;
    if (sh.sh_extensions.tag == FStar_Pervasives_Native_Some)
      ite = sh.sh_extensions.v;
    else
      ite =
        KRML_EABORT(Prims_list__Extensions_extension_ *,
          "unreachable (pattern matches are exhaustive in F*)");
    return
      (
        (FStar_Pervasives_Native_option__HandshakeMessages_hrr){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .hrr_sessionID = sh.sh_sessionID,
            .hrr_cipher_suite = sh.sh_cipher_suite,
            .hrr_extensions = ite
          }
        }
      );
  }
  else
    return
      (
        (FStar_Pervasives_Native_option__HandshakeMessages_hrr){
          .tag = FStar_Pervasives_Native_None
        }
      );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hrr
TLSError_fatal__HandshakeMessages_hrr(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hrr){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hrr
HandshakeMessages_error__HandshakeMessages_hrr(Prims_string s)
{
  return
    TLSError_fatal__HandshakeMessages_hrr(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hrr
HandshakeMessages_parseHelloRetryRequest(FStar_Bytes_bytes b)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh
  scrut = HandshakeMessages_parseServerHello(b);
  if (scrut.tag == FStar_Error_Correct)
  {
    HandshakeMessages_sh sh = scrut.val.case_Correct;
    FStar_Pervasives_Native_option__HandshakeMessages_hrr
    scrut = HandshakeMessages_helloRetryRequest_of_serverHello(sh);
    if (scrut.tag == FStar_Pervasives_Native_None)
      return
        HandshakeMessages_error__HandshakeMessages_hrr("not a proper HRR (magic nonce does not match)");
    else if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      HandshakeMessages_hrr hr = scrut.v;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hrr){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = hr }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hrr){
          .tag = FStar_Error_Error,
          .val = { .case_Error = z }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg
TLSError_fatal__HandshakeMessages_hs_msg(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg
HandshakeMessages_error__HandshakeMessages_hs_msg(Prims_string s)
{
  return
    TLSError_fatal__HandshakeMessages_hs_msg(Parsers_AlertDescription_Decode_error,
      Prims_strcat("Handshake parser: ", s));
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg
HandshakeMessages_parseEmptyMessage__HandshakeMessages_hs_msg(
  HandshakeMessages_hs_msg v1,
  FStar_Bytes_bytes body
)
{
  if (FStar_UInt32_v(FStar_Bytes_len(body)) == (krml_checked_int_t)0)
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = v1 }
        }
      );
  else
    return HandshakeMessages_error__HandshakeMessages_hs_msg("non-empty body");
}

typedef struct
K___HandshakeMessages_handshakeType_FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__CipherSuite_kexAlg_s
{
  HandshakeMessages_handshakeType fst;
  FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion snd;
  FStar_Pervasives_Native_option__CipherSuite_kexAlg thd;
}
K___HandshakeMessages_handshakeType_FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__CipherSuite_kexAlg;

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg
HandshakeMessages_parseHandshakeMessage(
  FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion pv,
  FStar_Pervasives_Native_option__CipherSuite_kexAlg kex,
  HandshakeMessages_handshakeType hstype,
  FStar_Bytes_bytes body
)
{
  if
  (
    Prims_op_GreaterThanOrEqual(FStar_UInt32_v(FStar_Bytes_len(body)),
      (krml_checked_int_t)16777216)
  )
    return HandshakeMessages_error__HandshakeMessages_hs_msg("message too large");
  else
  {
    K___HandshakeMessages_handshakeType_FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__CipherSuite_kexAlg
    scrut0 = { .fst = hstype, .snd = pv, .thd = kex };
    if (scrut0.fst == HandshakeMessages_HT_hello_request)
      return
        HandshakeMessages_parseEmptyMessage__HandshakeMessages_hs_msg((
            (HandshakeMessages_hs_msg){ .tag = HandshakeMessages_HelloRequest }
          ),
          body);
    else if (scrut0.fst == HandshakeMessages_HT_server_hello)
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sh
      scrut0 = HandshakeMessages_parseServerHello(body);
      if (scrut0.tag == FStar_Error_Correct)
      {
        HandshakeMessages_sh sh = scrut0.val.case_Correct;
        FStar_Pervasives_Native_option__HandshakeMessages_hrr
        scrut = HandshakeMessages_helloRetryRequest_of_serverHello(sh);
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          HandshakeMessages_hrr hr = scrut.v;
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .tag = HandshakeMessages_HelloRetryRequest,
                    .val = { .case_HelloRetryRequest = hr }
                  }
                }
              }
            );
        }
        else if (scrut.tag == FStar_Pervasives_Native_None)
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
                .tag = FStar_Error_Correct,
                .val = {
                  .case_Correct = {
                    .tag = HandshakeMessages_ServerHello,
                    .val = { .case_ServerHello = sh }
                  }
                }
              }
            );
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
        return HandshakeMessages_error__HandshakeMessages_hs_msg("failed to parse ServerHello/HRR");
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_session_ticket
      &&
        scrut0.snd.tag
        == FStar_Pervasives_Native_Some
        && scrut0.snd.v.tag == Parsers_ProtocolVersion_TLS_1p3
    )
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket13
      scrut = HandshakeMessages_parseSessionTicket13(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_sticket13 c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_NewSessionTicket13,
                  .val = { .case_NewSessionTicket13 = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_session_ticket
      && scrut0.snd.tag == FStar_Pervasives_Native_Some
    )
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_sticket
      scrut = HandshakeMessages_parseSessionTicket(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_sticket c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_NewSessionTicket,
                  .val = { .case_NewSessionTicket = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_end_of_early_data
      &&
        scrut0.snd.tag
        == FStar_Pervasives_Native_Some
        && scrut0.snd.v.tag == Parsers_ProtocolVersion_TLS_1p3
    )
      return
        HandshakeMessages_parseEmptyMessage__HandshakeMessages_hs_msg((
            (HandshakeMessages_hs_msg){ .tag = HandshakeMessages_EndOfEarlyData }
          ),
          body);
    else if (scrut0.fst == HandshakeMessages_HT_encrypted_extensions)
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Prims_list__Extensions_extension_
      scrut = HandshakeMessages_parseEncryptedExtensions(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__Extensions_extension_ *c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_EncryptedExtensions,
                  .val = { .case_EncryptedExtensions = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_certificate
      &&
        scrut0.snd.tag
        == FStar_Pervasives_Native_Some
        && scrut0.snd.v.tag == Parsers_ProtocolVersion_TLS_1p3
    )
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt13
      scrut = HandshakeMessages_parseCertificate13(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_crt13 c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_Certificate13,
                  .val = { .case_Certificate13 = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_certificate
      && scrut0.snd.tag == FStar_Pervasives_Native_Some
    )
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_crt
      scrut = HandshakeMessages_parseCertificate(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        Prims_list__FStar_Bytes_bytes *c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_Certificate,
                  .val = { .case_Certificate = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_server_key_exchange
      &&
        scrut0.snd.tag
        == FStar_Pervasives_Native_Some
        && scrut0.thd.tag == FStar_Pervasives_Native_Some
    )
    {
      CipherSuite_kexAlg kex1 = scrut0.thd.v;
      Parsers_ProtocolVersion_protocolVersion pv1 = scrut0.snd.v;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ske
      scrut = HandshakeMessages_parseServerKeyExchange(pv1, kex1, body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_ske c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_ServerKeyExchange,
                  .val = { .case_ServerKeyExchange = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_certificate_request
      &&
        scrut0.snd.tag
        == FStar_Pervasives_Native_Some
        && scrut0.snd.v.tag == Parsers_ProtocolVersion_TLS_1p3
    )
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
      scrut = HandshakeMessages_parseCertificateRequest13(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_cr c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_CertificateRequest13,
                  .val = { .case_CertificateRequest13 = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_certificate_request
      && scrut0.snd.tag == FStar_Pervasives_Native_Some
    )
    {
      Parsers_ProtocolVersion_protocolVersion pv1 = scrut0.snd.v;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cr
      scrut = HandshakeMessages_parseCertificateRequest(pv1, body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_cr c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_CertificateRequest,
                  .val = { .case_CertificateRequest = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (scrut0.fst == HandshakeMessages_HT_server_hello_done)
      return
        HandshakeMessages_parseEmptyMessage__HandshakeMessages_hs_msg((
            (HandshakeMessages_hs_msg){ .tag = HandshakeMessages_ServerHelloDone }
          ),
          body);
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_certificate_verify
      && scrut0.snd.tag == FStar_Pervasives_Native_Some
    )
    {
      Parsers_ProtocolVersion_protocolVersion pv1 = scrut0.snd.v;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
      scrut = HandshakeMessages_parseCertificateVerify(pv1, body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_signature c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_CertificateVerify,
                  .val = { .case_CertificateVerify = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if
    (
      scrut0.fst
      == HandshakeMessages_HT_client_key_exchange
      &&
        scrut0.snd.tag
        == FStar_Pervasives_Native_Some
        && scrut0.thd.tag == FStar_Pervasives_Native_Some
    )
    {
      CipherSuite_kexAlg kex1 = scrut0.thd.v;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_cke
      scrut = HandshakeMessages_parseClientKeyExchange(kex1, body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_kex_c c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_ClientKeyExchange,
                  .val = { .case_ClientKeyExchange = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (scrut0.fst == HandshakeMessages_HT_finished)
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_fin
      scrut = HandshakeMessages_parseFinished(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        FStar_Bytes_bytes c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = { .tag = HandshakeMessages_Finished, .val = { .case_Finished = c } }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (scrut0.fst == HandshakeMessages_HT_key_update)
    {
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_bool
      scrut = HandshakeMessages_parseBoolean(body);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Error,
              .val = { .case_Error = z }
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        bool c = scrut.val.case_Correct;
        return
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_hs_msg){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = {
                  .tag = HandshakeMessages_KeyUpdate,
                  .val = { .case_KeyUpdate = c }
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
      return HandshakeMessages_error__HandshakeMessages_hs_msg("unexpected message");
  }
}

