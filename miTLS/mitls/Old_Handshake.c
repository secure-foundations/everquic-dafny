/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "Old_Handshake.h"

#define Old_HMAC_UFCMA_HMAC_Finished 0
#define Old_HMAC_UFCMA_HMAC_Binder 1

typedef uint8_t Old_HMAC_UFCMA_id_tags;

typedef struct Old_HMAC_UFCMA_id_s
{
  Old_HMAC_UFCMA_id_tags tag;
  union {
    TLSInfo_pre_finishedId *case_HMAC_Finished;
    TLSInfo_pre_binderId *case_HMAC_Binder;
  }
  val;
}
Old_HMAC_UFCMA_id;

static Spec_Hash_Definitions_hash_alg Old_HMAC_UFCMA_alg(Old_HMAC_UFCMA_id i1)
{
  if (i1.tag == Old_HMAC_UFCMA_HMAC_Finished)
  {
    TLSInfo_pre_finishedId *i2 = i1.val.case_HMAC_Finished;
    return TLSInfo_finishedId_hash(i2);
  }
  else if (i1.tag == Old_HMAC_UFCMA_HMAC_Binder)
  {
    TLSInfo_pre_binderId *i2 = i1.val.case_HMAC_Binder;
    return TLSInfo_binderId_hash(i2);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool Old_HMAC_UFCMA_authId(Old_HMAC_UFCMA_id id1)
{
  return false;
}

typedef Prims_list__Old_HMAC_UFCMA_entry *FStar_Seq_Base_seq__Old_HMAC_UFCMA_entry;

static Prims_list__Old_HMAC_UFCMA_entry *FStar_Seq_Base_empty__Old_HMAC_UFCMA_entry()
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Old_HMAC_UFCMA_entry), (uint32_t)1U);
  Prims_list__Old_HMAC_UFCMA_entry
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_HMAC_UFCMA_entry));
  buf[0U] = ((Prims_list__Old_HMAC_UFCMA_entry){ .tag = Prims_Nil });
  return buf;
}

static Old_HMAC_UFCMA_key Old_HMAC_UFCMA_gen0(Old_HMAC_UFCMA_id i1, FStar_Bytes_bytes kv)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Old_HMAC_UFCMA_entry *), (uint32_t)1U);
  Prims_list__Old_HMAC_UFCMA_entry
  **log = KRML_HOST_MALLOC(sizeof (Prims_list__Old_HMAC_UFCMA_entry *));
  log[0U] = FStar_Seq_Base_empty__Old_HMAC_UFCMA_entry();
  return ((Old_HMAC_UFCMA_key){ .kv = kv, .log = log });
}

static Old_HMAC_UFCMA_key Old_HMAC_UFCMA_coerce(Old_HMAC_UFCMA_id i1, FStar_Bytes_bytes kv)
{
  return Old_HMAC_UFCMA_gen0(i1, kv);
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_List_Tot_Base_append__Old_HMAC_UFCMA_entry(
  Prims_list__Old_HMAC_UFCMA_entry *x,
  Prims_list__Old_HMAC_UFCMA_entry *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Old_HMAC_UFCMA_entry *tl1 = x->tl;
    Old_HMAC_UFCMA_entry a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__Old_HMAC_UFCMA_entry), (uint32_t)1U);
    Prims_list__Old_HMAC_UFCMA_entry
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_HMAC_UFCMA_entry));
    buf[0U]
    =
      (
        (Prims_list__Old_HMAC_UFCMA_entry){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__Old_HMAC_UFCMA_entry(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Base_append__Old_HMAC_UFCMA_entry(
  Prims_list__Old_HMAC_UFCMA_entry *s1,
  Prims_list__Old_HMAC_UFCMA_entry *s2
)
{
  return FStar_List_Tot_Base_append__Old_HMAC_UFCMA_entry(s1, s2);
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Base_cons__Old_HMAC_UFCMA_entry(
  Old_HMAC_UFCMA_entry x,
  Prims_list__Old_HMAC_UFCMA_entry *s
)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Old_HMAC_UFCMA_entry), (uint32_t)1U);
  Prims_list__Old_HMAC_UFCMA_entry
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_HMAC_UFCMA_entry));
  buf[0U] = ((Prims_list__Old_HMAC_UFCMA_entry){ .tag = Prims_Cons, .hd = x, .tl = s });
  return buf;
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Base_create__Old_HMAC_UFCMA_entry(Prims_int len, Old_HMAC_UFCMA_entry v)
{
  if (len == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Old_HMAC_UFCMA_entry), (uint32_t)1U);
    Prims_list__Old_HMAC_UFCMA_entry
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_HMAC_UFCMA_entry));
    buf[0U] = ((Prims_list__Old_HMAC_UFCMA_entry){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__Old_HMAC_UFCMA_entry(v,
        FStar_Seq_Base_create__Old_HMAC_UFCMA_entry(Prims_op_Subtraction(len, (krml_checked_int_t)1),
          v));
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Properties_snoc__Old_HMAC_UFCMA_entry(
  Prims_list__Old_HMAC_UFCMA_entry *s,
  Old_HMAC_UFCMA_entry x
)
{
  return
    FStar_Seq_Base_append__Old_HMAC_UFCMA_entry(s,
      FStar_Seq_Base_create__Old_HMAC_UFCMA_entry((krml_checked_int_t)1, x));
}

static FStar_Bytes_bytes
Old_HMAC_UFCMA_mac(Old_HMAC_UFCMA_id i1, Old_HMAC_UFCMA_key k1, FStar_Bytes_bytes p1)
{
  Spec_Hash_Definitions_hash_alg a = Old_HMAC_UFCMA_alg(i1);
  FStar_Bytes_bytes p2 = p1;
  FStar_Bytes_bytes t = HMAC_hmac(a, k1.kv, p2);
  Old_HMAC_UFCMA_entry e = { .t = t, .p = p2 };
  Prims_list__Old_HMAC_UFCMA_entry
  *uu____0 = FStar_Seq_Properties_snoc__Old_HMAC_UFCMA_entry(k1.log[0U], e);
  k1.log[0U] = uu____0;
  return t;
}

static bool
Old_HMAC_UFCMA_matches(
  Old_HMAC_UFCMA_id i1,
  FStar_Bytes_bytes p1,
  Old_HMAC_UFCMA_entry uu____1069
)
{
  FStar_Bytes_bytes p_ = uu____1069.p;
  return __eq__FStar_Bytes_bytes(p1, p_);
}

static Prims_int
FStar_List_Tot_Base_length__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *uu___4_154)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Old_HMAC_UFCMA_entry *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__Old_HMAC_UFCMA_entry(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_int
FStar_Seq_Base_length__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *s)
{
  return FStar_List_Tot_Base_length__Old_HMAC_UFCMA_entry(s);
}

static Old_HMAC_UFCMA_entry
FStar_List_Tot_Base_hd__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *uu___0_39)
{
  if (uu___0_39->tag == Prims_Cons)
    return uu___0_39->hd;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_List_Tot_Base_tail__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *uu___1_64)
{
  if (uu___1_64->tag == Prims_Cons)
    return uu___1_64->tl;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Old_HMAC_UFCMA_entry
*(*FStar_List_Tot_Base_tl__Old_HMAC_UFCMA_entry)(Prims_list__Old_HMAC_UFCMA_entry *x0) =
  FStar_List_Tot_Base_tail__Old_HMAC_UFCMA_entry;

static Old_HMAC_UFCMA_entry
FStar_List_Tot_Base_index__Old_HMAC_UFCMA_entry(
  Prims_list__Old_HMAC_UFCMA_entry *l,
  Prims_int i
)
{
  if (i == (krml_checked_int_t)0)
    return FStar_List_Tot_Base_hd__Old_HMAC_UFCMA_entry(l);
  else
    return
      FStar_List_Tot_Base_index__Old_HMAC_UFCMA_entry(FStar_List_Tot_Base_tl__Old_HMAC_UFCMA_entry(l),
        Prims_op_Subtraction(i, (krml_checked_int_t)1));
}

static Old_HMAC_UFCMA_entry
FStar_Seq_Base_index__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *s, Prims_int i)
{
  return FStar_List_Tot_Base_index__Old_HMAC_UFCMA_entry(s, i);
}

static Old_HMAC_UFCMA_entry
FStar_Seq_Properties_head__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *s)
{
  return FStar_Seq_Base_index__Old_HMAC_UFCMA_entry(s, (krml_checked_int_t)0);
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Base_tl__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *s)
{
  return FStar_List_Tot_Base_tl__Old_HMAC_UFCMA_entry(s);
}

static Old_HMAC_UFCMA_entry
FStar_Seq_Base_hd__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *s)
{
  return FStar_List_Tot_Base_hd__Old_HMAC_UFCMA_entry(s);
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Base_slice__Old_HMAC_UFCMA_entry(
  Prims_list__Old_HMAC_UFCMA_entry *s,
  Prims_int i,
  Prims_int j
)
{
  if (Prims_op_GreaterThan(i, (krml_checked_int_t)0))
    return
      FStar_Seq_Base_slice__Old_HMAC_UFCMA_entry(FStar_Seq_Base_tl__Old_HMAC_UFCMA_entry(s),
        Prims_op_Subtraction(i, (krml_checked_int_t)1),
        Prims_op_Subtraction(j, (krml_checked_int_t)1));
  else if (j == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Old_HMAC_UFCMA_entry), (uint32_t)1U);
    Prims_list__Old_HMAC_UFCMA_entry
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_HMAC_UFCMA_entry));
    buf[0U] = ((Prims_list__Old_HMAC_UFCMA_entry){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__Old_HMAC_UFCMA_entry(FStar_Seq_Base_hd__Old_HMAC_UFCMA_entry(s),
        FStar_Seq_Base_slice__Old_HMAC_UFCMA_entry(FStar_Seq_Base_tl__Old_HMAC_UFCMA_entry(s),
          i,
          Prims_op_Subtraction(j, (krml_checked_int_t)1)));
}

static Prims_list__Old_HMAC_UFCMA_entry
*FStar_Seq_Properties_tail__Old_HMAC_UFCMA_entry(Prims_list__Old_HMAC_UFCMA_entry *s)
{
  return
    FStar_Seq_Base_slice__Old_HMAC_UFCMA_entry(s,
      (krml_checked_int_t)1,
      FStar_Seq_Base_length__Old_HMAC_UFCMA_entry(s));
}

static bool
Old_HMAC_UFCMA_log_entry_matches_p(
  Old_HMAC_UFCMA_id i1,
  Prims_list__Old_HMAC_UFCMA_entry *log,
  FStar_Bytes_bytes p1
)
{
  if (FStar_Seq_Base_length__Old_HMAC_UFCMA_entry(log) == (krml_checked_int_t)0)
    return false;
  else
    return
      Old_HMAC_UFCMA_matches(i1,
        p1,
        FStar_Seq_Properties_head__Old_HMAC_UFCMA_entry(log))
      ||
        Old_HMAC_UFCMA_log_entry_matches_p(i1,
          FStar_Seq_Properties_tail__Old_HMAC_UFCMA_entry(log),
          p1);
}

static bool
Old_HMAC_UFCMA_verify(
  Old_HMAC_UFCMA_id i1,
  Old_HMAC_UFCMA_key k1,
  FStar_Bytes_bytes p1,
  FStar_Bytes_bytes t
)
{
  bool x = HMAC_hmacVerify(Old_HMAC_UFCMA_alg(i1), k1.kv, p1, t);
  Prims_list__Old_HMAC_UFCMA_entry *log = k1.log[0U];
  return x && (!Old_HMAC_UFCMA_authId(i1) || Old_HMAC_UFCMA_log_entry_matches_p(i1, log, p1));
}

static void Old_KeySchedule_discard(bool b)
{
  
}

static void Old_KeySchedule_print(Prims_string s)
{
  Old_KeySchedule_discard(FStar_IO_debug_print_string(Prims_strcat("KS | ",
        Prims_strcat(s, "\n"))));
}

static void Old_KeySchedule_print_share(CommonDH_group_ g1, CommonDH_pre_share_ s)
{
  FStar_Bytes_bytes kb = CommonDH_serialize_raw(g1, s);
  Prims_string kh = FStar_Bytes_hex_of_bytes(kb);
  Old_KeySchedule_print(Prims_strcat("Share: ", kh));
}

typedef struct K___TLSInfo_pre_esId_TLSConstants_pskInfo_FStar_Bytes_bytes_s
{
  TLSInfo_pre_esId *fst;
  TLSConstants_pskInfo snd;
  FStar_Bytes_bytes thd;
}
K___TLSInfo_pre_esId_TLSConstants_pskInfo_FStar_Bytes_bytes;

static K___TLSInfo_pre_esId_TLSConstants_pskInfo_FStar_Bytes_bytes
Old_KeySchedule_read_psk(FStar_Bytes_bytes i1)
{
  TLSConstants_pskInfo c = PSK_psk_info(i1);
  TLSInfo_pre_esId *id1;
  if (FStar_Pervasives_Native_uu___is_Some__FStar_Bytes_bytes(c.ticket_nonce))
  {
    Prims_dtuple2__TLSInfo_logInfo_TLSInfo_pre_rmsId
    scrut = Ticket_dummy_rmsid(c.early_ae, c.early_hash);
    TLSInfo_logInfo li = scrut.fst;
    TLSInfo_pre_rmsId *rmsid = scrut.snd;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_esId), (uint32_t)1U);
    TLSInfo_pre_esId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_esId));
    buf[0U]
    =
      (
        (TLSInfo_pre_esId){
          .tag = TLSInfo_ResumptionPSK,
          .val = { .case_ResumptionPSK = { .li = li, .i = rmsid } }
        }
      );
    id1 = buf;
  }
  else
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_esId), (uint32_t)1U);
    TLSInfo_pre_esId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_esId));
    buf[0U]
    =
      (
        (TLSInfo_pre_esId){
          .tag = TLSInfo_ApplicationPSK,
          .val = { .case_ApplicationPSK = { .ha = c.early_hash, .ae = c.early_ae, .i = i1 } }
        }
      );
    id1 = buf;
  }
  return
    (
      (K___TLSInfo_pre_esId_TLSConstants_pskInfo_FStar_Bytes_bytes){
        .fst = id1,
        .snd = c,
        .thd = PSK_psk_value(i1)
      }
    );
}

typedef struct Old_KeySchedule_recordInstance_s
{
  TLSInfo_id id;
  StAE_state r;
  StAE_state w;
  K___FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes
  _3;
}
Old_KeySchedule_recordInstance;

typedef struct
K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes_s
{
  FStar_Bytes_bytes fst;
  FStar_Bytes_bytes snd;
  FStar_Pervasives_Native_option__FStar_Bytes_bytes thd;
}
K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes;

typedef struct K___Prims_string_Prims_string_s
{
  Prims_string fst;
  Prims_string snd;
}
K___Prims_string_Prims_string;

static K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
Old_KeySchedule_keygen_13(
  Spec_Hash_Definitions_hash_alg h1,
  FStar_Bytes_bytes secret1,
  EverCrypt_aead_alg ae,
  bool is_quic
)
{
  uint32_t kS = EverCrypt_aead_keyLen(ae);
  uint32_t iS = (uint32_t)12U;
  K___Prims_string_Prims_string scrut;
  if (is_quic)
    scrut = ((K___Prims_string_Prims_string){ .fst = "quic key", .snd = "quic iv" });
  else
    scrut = ((K___Prims_string_Prims_string){ .fst = "key", .snd = "iv" });
  Prims_string lk = scrut.fst;
  Prims_string liv = scrut.snd;
  FStar_Bytes_bytes kb = HKDF_expand_label(h1, secret1, lk, FStar_Bytes_empty_bytes, kS);
  FStar_Bytes_bytes ib = HKDF_expand_label(h1, secret1, liv, FStar_Bytes_empty_bytes, iS);
  FStar_Pervasives_Native_option__FStar_Bytes_bytes pn;
  if (is_quic)
    pn =
      (
        (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = HKDF_expand_label(h1, secret1, "quic hp", FStar_Bytes_empty_bytes, kS)
        }
      );
  else
    pn =
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  return
    (
      (K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes){
        .fst = kb,
        .snd = ib,
        .thd = pn
      }
    );
}

static FStar_Bytes_bytes
Old_KeySchedule_finished_13(Spec_Hash_Definitions_hash_alg h1, FStar_Bytes_bytes secret1)
{
  uint32_t sw;
  switch (h1)
  {
    case Spec_Hash_Definitions_MD5:
      {
        sw = (uint32_t)16U;
        break;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        sw = (uint32_t)20U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        sw = (uint32_t)28U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        sw = (uint32_t)32U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        sw = (uint32_t)48U;
        break;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        sw = (uint32_t)64U;
        break;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  return HKDF_expand_label(h1, secret1, "finished", FStar_Bytes_empty_bytes, sw);
}

typedef struct K___Old_KeySchedule_ks_FStar_Bytes_bytes_s
{
  Old_KeySchedule_ks fst;
  FStar_Bytes_bytes snd;
}
K___Old_KeySchedule_ks_FStar_Bytes_bytes;

static K___Old_KeySchedule_ks_FStar_Bytes_bytes
Old_KeySchedule_create(TLSConstants_role r, bool is_quic)
{
  FStar_Bytes_bytes nonce = Nonce_mkHelloRandom(r);
  Old_KeySchedule_ks_state istate;
  switch (r)
  {
    case TLSConstants_Client:
      {
        istate =
          (
            (Old_KeySchedule_ks_state){
              .tag = Old_KeySchedule_C,
              .val = {
                .case_C = { .tag = Old_KeySchedule_C_Init, .val = { .case_C_Init = nonce } }
              }
            }
          );
        break;
      }
    case TLSConstants_Server:
      {
        istate =
          (
            (Old_KeySchedule_ks_state){
              .tag = Old_KeySchedule_S,
              .val = {
                .case_S = { .tag = Old_KeySchedule_S_Init, .val = { .case_S_Init = nonce } }
              }
            }
          );
        break;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  KRML_CHECK_SIZE(sizeof (Old_KeySchedule_ks_state), (uint32_t)1U);
  Old_KeySchedule_ks_state *buf = KRML_HOST_MALLOC(sizeof (Old_KeySchedule_ks_state));
  buf[0U] = istate;
  return
    (
      (K___Old_KeySchedule_ks_FStar_Bytes_bytes){
        .fst = { .state = buf, .is_quic = is_quic },
        .snd = nonce
      }
    );
}

static CommonDH_group_
Old_KeySchedule_group_of_valid_namedGroup(Parsers_NamedGroup_namedGroup g1)
{
  FStar_Pervasives_Native_option__CommonDH_group_ x0 = CommonDH_group_of_namedGroup(g1);
  if (x0.tag == FStar_Pervasives_Native_Some)
    return x0.v;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
Old_KeySchedule_keygen(CommonDH_group_ g1)
{
  return
    (
      (Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){
        .fst = g1,
        .snd = CommonDH_keygen(g1)
      }
    );
}

static FStar_Pervasives_Native_option__CommonDH_keyShareEntry
Old_KeySchedule_serialize_share(Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ gx)
{
  CommonDH_group_ g1 = gx.fst;
  CommonDH_pre_keyshare_ gx1 = gx.snd;
  FStar_Pervasives_Native_option__Parsers_NamedGroup_namedGroup
  scrut = CommonDH_namedGroup_of_group(g1);
  if (scrut.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (scrut.tag == FStar_Pervasives_Native_Some)
    return
      (
        (FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .tag = CommonDH_Share,
            .val = { .case_Share = { .g = g1, ._1 = CommonDH_ipubshare(g1, gx1) } }
          }
        }
      );
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
*Old_KeySchedule_map_ST_keygen(Prims_list__CommonDH_group_ *l)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
    *buf =
      KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_));
    buf[0U]
    = ((Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){ .tag = Prims_Nil });
    return buf;
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__CommonDH_group_ *tl1 = l->tl;
    CommonDH_group_ hd1 = l->hd;
    Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ uu____0 = Old_KeySchedule_keygen(hd1);
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
    *buf =
      KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_));
    buf[0U]
    =
      (
        (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){
          .tag = Prims_Cons,
          .hd = uu____0,
          .tl = Old_KeySchedule_map_ST_keygen(tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__CommonDH_keyShareEntry
*FStar_List_Tot_Base_choose__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_keyShareEntry(
  FStar_Pervasives_Native_option__CommonDH_keyShareEntry
  (*f)(Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ x0),
  Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ *l
)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__CommonDH_keyShareEntry), (uint32_t)1U);
    Prims_list__CommonDH_keyShareEntry
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CommonDH_keyShareEntry));
    buf[0U] = ((Prims_list__CommonDH_keyShareEntry){ .tag = Prims_Nil });
    return buf;
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ *tl1 = l->tl;
    Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ hd1 = l->hd;
    FStar_Pervasives_Native_option__CommonDH_keyShareEntry scrut = f(hd1);
    if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      CommonDH_keyShareEntry x = scrut.v;
      KRML_CHECK_SIZE(sizeof (Prims_list__CommonDH_keyShareEntry), (uint32_t)1U);
      Prims_list__CommonDH_keyShareEntry
      *buf = KRML_HOST_MALLOC(sizeof (Prims_list__CommonDH_keyShareEntry));
      buf[0U]
      =
        (
          (Prims_list__CommonDH_keyShareEntry){
            .tag = Prims_Cons,
            .hd = x,
            .tl = FStar_List_Tot_Base_choose__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_keyShareEntry(f,
              tl1)
          }
        );
      return buf;
    }
    else if (scrut.tag == FStar_Pervasives_Native_None)
      return
        FStar_List_Tot_Base_choose__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_keyShareEntry(f,
          tl1);
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
__eq__FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup(
  FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup y,
  FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup x
)
{
  if (x.tag == FStar_Pervasives_Native_None)
    if (y.tag == FStar_Pervasives_Native_None)
      return true;
    else
      return false;
  else if (x.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__Parsers_NamedGroup_namedGroup *x_v = x.v;
    if (y.tag == FStar_Pervasives_Native_Some)
    {
      Prims_list__Parsers_NamedGroup_namedGroup *y_v = y.v;
      return true && __eq__Prims_list__Parsers_NamedGroup_namedGroup(y_v, x_v);
    }
    else
      return false;
  }
  else
    return false;
}

static FStar_Pervasives_Native_option__Prims_list__CommonDH_keyShareEntry
Old_KeySchedule_ks_client_init(
  Old_KeySchedule_ks ks,
  FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup ogl
)
{
  Prims_string ite;
  if
  (
    __eq__FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup(ogl,
      (
        (FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_None
        }
      ))
  )
    ite = "1.2";
  else
    ite = "1.3";
  Old_KeySchedule_print(Prims_strcat("ks_client_init ", ite));
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_Init)
  {
    FStar_Bytes_bytes cr = scrut.val.case_C.val.case_C_Init;
    if (ogl.tag == FStar_Pervasives_Native_None)
    {
      st[0U] =
        (
          (Old_KeySchedule_ks_state){
            .tag = Old_KeySchedule_C,
            .val = {
              .case_C = { .tag = Old_KeySchedule_C_12_Full_CH, .val = { .case_C_12_Full_CH = cr } }
            }
          }
        );
      return
        (
          (FStar_Pervasives_Native_option__Prims_list__CommonDH_keyShareEntry){
            .tag = FStar_Pervasives_Native_None
          }
        );
    }
    else if (ogl.tag == FStar_Pervasives_Native_Some)
    {
      Prims_list__Parsers_NamedGroup_namedGroup *gl = ogl.v;
      Prims_list__CommonDH_group_
      *groups =
        FStar_List_Tot_Base_map__Parsers_NamedGroup_namedGroup_CommonDH_group_(Old_KeySchedule_group_of_valid_namedGroup,
          gl);
      Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
      *gs = Old_KeySchedule_map_ST_keygen(groups);
      Prims_list__CommonDH_keyShareEntry
      *gxl =
        FStar_List_Tot_Base_choose__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_keyShareEntry(Old_KeySchedule_serialize_share,
          gs);
      KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes),
        (uint32_t)1U);
      Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
      *buf =
        KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes));
      buf[0U]
      = ((Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){ .tag = Prims_Nil });
      st[0U] =
        (
          (Old_KeySchedule_ks_state){
            .tag = Old_KeySchedule_C,
            .val = {
              .case_C = {
                .tag = Old_KeySchedule_C_13_wait_SH,
                .val = { .case_C_13_wait_SH = { .cr = cr, .esl = buf, .gs = gs } }
              }
            }
          }
        );
      return
        (
          (FStar_Pervasives_Native_option__Prims_list__CommonDH_keyShareEntry){
            .tag = FStar_Pervasives_Native_Some,
            .v = gxl
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct K___TLSInfo_binderLabel_Prims_string_s
{
  TLSInfo_binderLabel fst;
  Prims_string snd;
}
K___TLSInfo_binderLabel_Prims_string;

static K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
Old_KeySchedule_mk_binder(FStar_Bytes_bytes pskid, Ticket_ticket t)
{
  TLSInfo_logInfo ite0;
  if (t.tag == Ticket_Ticket13)
    ite0 = t.val.case_Ticket13.li;
  else
    ite0 = KRML_EABORT(TLSInfo_logInfo, "unreachable (pattern matches are exhaustive in F*)");
  TLSInfo_pre_rmsId *ite;
  if (t.tag == Ticket_Ticket13)
    ite = t.val.case_Ticket13.rmsId;
  else
    ite = KRML_EABORT(TLSInfo_pre_rmsId *, "unreachable (pattern matches are exhaustive in F*)");
  KRML_CHECK_SIZE(sizeof (TLSInfo_pre_esId), (uint32_t)1U);
  TLSInfo_pre_esId *i1 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_esId));
  i1[0U]
  =
    (
      (TLSInfo_pre_esId){
        .tag = TLSInfo_ResumptionPSK,
        .val = { .case_ResumptionPSK = { .li = ite0, .i = ite } }
      }
    );
  FStar_Pervasives_Native_option__TLSConstants_pskInfo x0 = Ticket_ticket_pskinfo(t);
  TLSConstants_pskInfo pski;
  if (x0.tag == FStar_Pervasives_Native_Some)
    pski = x0.v;
  else
    pski = KRML_EABORT(TLSConstants_pskInfo, "unreachable (pattern matches are exhaustive in F*)");
  FStar_Bytes_bytes psk;
  if (t.tag == Ticket_Ticket13)
    psk = t.val.case_Ticket13.rms;
  else
    psk = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  Spec_Hash_Definitions_hash_alg h1 = pski.early_hash;
  Old_KeySchedule_print(Prims_strcat("Loaded pre-shared key ",
      Prims_strcat(FStar_Bytes_print_bytes(pskid), Prims_strcat(": ", FStar_Bytes_print_bytes(psk)))));
  FStar_Bytes_bytes es = HMAC_hmac(h1, Hashing_Spec_zeroHash(h1), psk);
  Old_KeySchedule_print(Prims_strcat("Early secret: ", FStar_Bytes_print_bytes(es)));
  K___TLSInfo_binderLabel_Prims_string scrut;
  if (TLSInfo_uu___is_ApplicationPSK(i1))
    scrut =
      ((K___TLSInfo_binderLabel_Prims_string){ .fst = TLSInfo_ExtBinder, .snd = "ext binder" });
  else
    scrut =
      ((K___TLSInfo_binderLabel_Prims_string){ .fst = TLSInfo_ResBinder, .snd = "res binder" });
  TLSInfo_binderLabel ll = scrut.fst;
  Prims_string lb = scrut.snd;
  KRML_CHECK_SIZE(sizeof (TLSInfo_pre_binderId), (uint32_t)1U);
  TLSInfo_pre_binderId *bId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_binderId));
  bId[0U] = ((TLSInfo_pre_binderId){ ._0 = i1, ._1 = ll });
  FStar_Bytes_bytes bk = HKDF_derive_secret(h1, es, lb, Hashing_Spec_emptyHash(h1));
  Old_KeySchedule_print(Prims_strcat("Binder key[",
      Prims_strcat(lb, Prims_strcat("]: ", FStar_Bytes_print_bytes(bk)))));
  FStar_Bytes_bytes bk1 = Old_KeySchedule_finished_13(h1, bk);
  Old_KeySchedule_print(Prims_strcat("Binder Finished key: ", FStar_Bytes_print_bytes(bk1)));
  Old_HMAC_UFCMA_key
  bk2 =
    Old_HMAC_UFCMA_coerce((
        (Old_HMAC_UFCMA_id){ .tag = Old_HMAC_UFCMA_HMAC_Binder, .val = { .case_HMAC_Binder = bId } }
      ),
      bk1);
  return
    (
      (K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
        .fst = { .fst = bId, .snd = bk2 },
        .snd = { .fst = i1, .snd = es }
      }
    );
}

static Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
*FStar_List_Tot_Base_rev_acc__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key___Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(
  Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
  *l,
  Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
  *acc
)
{
  if (l->tag == Prims_Nil)
    return acc;
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *tl1 = l->tl;
    K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    hd1 = l->hd;
    KRML_CHECK_SIZE(sizeof (
        Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
      ),
      (uint32_t)1U);
    Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *buf =
      KRML_HOST_MALLOC(sizeof (
          Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
        ));
    buf[0U]
    =
      (
        (Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = hd1,
          .tl = acc
        }
      );
    return
      FStar_List_Tot_Base_rev_acc__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key___Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(tl1,
        buf);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
*FStar_List_Tot_Base_rev__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key___Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(
  Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
  *l
)
{
  KRML_CHECK_SIZE(sizeof (
      Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    ),
    (uint32_t)1U);
  Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
  *buf =
    KRML_HOST_MALLOC(sizeof (
        Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
      ));
  buf[0U]
  =
    (
      (Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
        .tag = Prims_Nil
      }
    );
  return
    FStar_List_Tot_Base_rev_acc__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key___Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(l,
      buf);
}

static Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
*Old_KeySchedule_tickets13(
  Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
  *acc,
  Prims_list__K___FStar_Bytes_bytes_Ticket_ticket *l
)
{
  if (l->tag == Prims_Nil)
    return
      FStar_List_Tot_Base_rev__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key___Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(acc);
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_Ticket_ticket *r = l->tl;
    Ticket_ticket t = l->hd.snd;
    FStar_Bytes_bytes pskid = l->hd.fst;
    Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *ite;
    if (Ticket_uu___is_Ticket13(t))
    {
      KRML_CHECK_SIZE(sizeof (
          Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
        ),
        (uint32_t)1U);
      Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
      *buf =
        KRML_HOST_MALLOC(sizeof (
            Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
          ));
      buf[0U]
      =
        (
          (Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
            .tag = Prims_Cons,
            .hd = Old_KeySchedule_mk_binder(pskid, t),
            .tl = acc
          }
        );
      ite = buf;
    }
    else
      ite = acc;
    return Old_KeySchedule_tickets13(ite, r);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes_s
{
  Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key *fst;
  Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *snd;
}
K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes;

static K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
FStar_List_Tot_Base_split__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(
  Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
  *l
)
{
  if (l->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
    *buf0 =
      KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key));
    buf0[0U]
    = ((Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes));
    buf[0U]
    = ((Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){ .tag = Prims_Nil });
    return
      (
        (K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
          .fst = buf0,
          .snd = buf
        }
      );
  }
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *tl1 = l->tl;
    Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes hd2 = l->hd.snd;
    Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key hd1 = l->hd.fst;
    K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    scrut =
      FStar_List_Tot_Base_split__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(tl1);
    Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key *tl11 = scrut.fst;
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *tl2 = scrut.snd;
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
    *buf0 =
      KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key));
    buf0[0U]
    =
      (
        (Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key){
          .tag = Prims_Cons,
          .hd = hd1,
          .tl = tl11
        }
      );
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes));
    buf[0U]
    =
      (
        (Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = hd2,
          .tl = tl2
        }
      );
    return
      (
        (K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
          .fst = buf0,
          .snd = buf
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
*Old_KeySchedule_ks_client_13_get_binder_keys(
  Old_KeySchedule_ks ks,
  Prims_list__K___FStar_Bytes_bytes_Ticket_ticket *l
)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_wait_SH)
  {
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
    *gs = scrut.val.case_C.val.case_C_13_wait_SH.gs;
    FStar_Bytes_bytes cr = scrut.val.case_C.val.case_C_13_wait_SH.cr;
    KRML_CHECK_SIZE(sizeof (
        Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
      ),
      (uint32_t)1U);
    Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *buf =
      KRML_HOST_MALLOC(sizeof (
          Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
        ));
    buf[0U]
    =
      (
        (Prims_list__K___Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
          .tag = Prims_Nil
        }
      );
    K___Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    scrut =
      FStar_List_Tot_Base_split__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(Old_KeySchedule_tickets13(buf,
          l));
    Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key *bkl = scrut.fst;
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *esl = scrut.snd;
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_C,
          .val = {
            .case_C = {
              .tag = Old_KeySchedule_C_13_wait_SH,
              .val = { .case_C_13_wait_SH = { .cr = cr, .esl = esl, .gs = gs } }
            }
          }
        }
      );
    return bkl;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static CommonDH_pre_share_
Old_KeySchedule_ks_client_13_hello_retry(Old_KeySchedule_ks ks, CommonDH_group_ g1)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_wait_SH)
  {
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *esl = scrut.val.case_C.val.case_C_13_wait_SH.esl;
    FStar_Bytes_bytes cr = scrut.val.case_C.val.case_C_13_wait_SH.cr;
    CommonDH_pre_keyshare_ s = CommonDH_keygen(g1);
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
    *buf =
      KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_));
    buf[0U]
    = ((Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_),
      (uint32_t)1U);
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
    *buf0 =
      KRML_HOST_MALLOC(sizeof (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_));
    buf0[0U]
    =
      (
        (Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){
          .tag = Prims_Cons,
          .hd = { .fst = g1, .snd = s },
          .tl = buf
        }
      );
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_C,
          .val = {
            .case_C = {
              .tag = Old_KeySchedule_C_13_wait_SH,
              .val = { .case_C_13_wait_SH = { .cr = cr, .esl = esl, .gs = buf0 } }
            }
          }
        }
      );
    return CommonDH_ipubshare(g1, s);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance_s
{
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes fst;
  Old_KeySchedule_recordInstance snd;
}
K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance;

static K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance
Old_KeySchedule_ks_client_13_ch(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_client_13_ch log=", FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  bool is_quic = ks.is_quic;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if
  (
    scrut0.tag
    == Old_KeySchedule_C
    &&
      scrut0.val.case_C.tag
      == Old_KeySchedule_C_13_wait_SH
      && scrut0.val.case_C.val.case_C_13_wait_SH.esl->tag == Prims_Cons
  )
  {
    FStar_Bytes_bytes es = scrut0.val.case_C.val.case_C_13_wait_SH.esl->hd.snd;
    TLSInfo_pre_esId *i1 = scrut0.val.case_C.val.case_C_13_wait_SH.esl->hd.fst;
    FStar_Bytes_bytes cr = scrut0.val.case_C.val.case_C_13_wait_SH.cr;
    Spec_Hash_Definitions_hash_alg h1 = TLSInfo_esId_hash(i1);
    EverCrypt_aead_alg ae = TLSInfo_esId_ae(i1);
    TLSInfo_logInfo
    li =
      {
        .tag = TLSInfo_LogInfo_CH0,
        .val = {
          .case_LogInfo_CH0 = {
            .li_ch0_cr = cr,
            .li_ch0_ed_psk = FStar_Bytes_empty_bytes,
            .li_ch0_ed_ae = ae,
            .li_ch0_ed_hash = h1
          }
        }
      };
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
    TLSInfo_pre_secretId *buf0 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
    buf0[0U]
    = ((TLSInfo_pre_secretId){ .tag = TLSInfo_EarlySecretID, .val = { .case_EarlySecretID = i1 } });
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf1 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf1[0U] = TLSInfo_ClientEarlyTrafficSecret;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = buf0, ._1 = buf1, ._2 = log2 });
    FStar_Bytes_bytes ets = HKDF_derive_secret(h1, es, "c e traffic", log2);
    Old_KeySchedule_print(Prims_strcat("Client early traffic secret:     ",
        FStar_Bytes_print_bytes(ets)));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_exportId), (uint32_t)1U);
    TLSInfo_pre_exportId *expId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_exportId));
    expId[0U]
    =
      (
        (TLSInfo_pre_exportId){
          .tag = TLSInfo_EarlyExportID,
          .val = { .case_EarlyExportID = { ._0 = i1, ._1 = log2 } }
        }
      );
    FStar_Bytes_bytes early_export = HKDF_derive_secret(h1, es, "e exp master", log2);
    Old_KeySchedule_print(Prims_strcat("Early exporter master secret:    ",
        FStar_Bytes_print_bytes(early_export)));
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    exporter0 = { ._1 = li, ._2 = expId, ._3 = early_export };
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut = Old_KeySchedule_keygen_13(h1, ets, ae, is_quic);
    FStar_Bytes_bytes ck = scrut.fst;
    FStar_Bytes_bytes civ = scrut.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes pn = scrut.thd;
    Old_KeySchedule_print(Prims_strcat("Client 0-RTT key:                ",
        Prims_strcat(FStar_Bytes_print_bytes(ck),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(civ)))));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
    TLSInfo_pre_keyId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
    buf[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = expandId });
    TLSInfo_id id1 = { .tag = TLSInfo_ID13, .val = { .case_ID13 = buf } };
    FStar_Bytes_bytes ckv = ck;
    FStar_Bytes_bytes civ1 = civ;
    StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(ckv, civ1));
    StAE_state r = StAE_genReader(id1, rw);
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ts;
    if (pn.tag == FStar_Pervasives_Native_None)
      ts =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (pn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn1 = pn.v;
      ts =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn1, .snd = ets }
          }
        );
    }
    else
      ts =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    Old_KeySchedule_recordInstance
    early_d = { .id = id1, .r = r, .w = rw, ._3 = { .fst = ts, .snd = ts } };
    return
      (
        (K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance){
          .fst = exporter0,
          .snd = early_d
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static CommonDH_pre_share_
Old_KeySchedule_ks_server_12_init_dh(
  Old_KeySchedule_ks ks,
  FStar_Bytes_bytes cr,
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_cipherSuite_ cs,
  bool ems,
  CommonDH_group_ g1
)
{
  Old_KeySchedule_print("ks_server_12_init_dh");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_Init)
  {
    FStar_Bytes_bytes sr = scrut.val.case_S.val.case_S_Init;
    if (cs.tag == CipherSuite_CipherSuite)
    {
      CommonDH_pre_keyshare_ our_share = CommonDH_keygen(g1);
      Old_KeySchedule_print_share(g1, CommonDH_ipubshare(g1, our_share));
      FStar_Bytes_bytes csr = FStar_Bytes_append(cr, sr);
      st[0U] =
        (
          (Old_KeySchedule_ks_state){
            .tag = Old_KeySchedule_S,
            .val = {
              .case_S = {
                .tag = Old_KeySchedule_S_12_wait_CKE_DH,
                .val = {
                  .case_S_12_wait_CKE_DH = {
                    .csr = csr,
                    .alpha = { .fst = pv, .snd = cs, .thd = ems },
                    .our_share = { .fst = g1, .snd = our_share }
                  }
                }
              }
            }
          }
        );
      return CommonDH_ipubshare(g1, our_share);
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key v;
}
FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key;

typedef struct
K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_s
{
  FStar_Pervasives_Native_option__CommonDH_keyShareEntry fst;
  FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key snd;
}
K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key;

typedef struct
K___TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_s
{
  TLSInfo_pre_esId *fst;
  FStar_Bytes_bytes snd;
  FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key thd;
}
K___TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key;

typedef struct K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg_s
{
  TLSInfo_pre_esId *fst;
  FStar_Bytes_bytes snd;
  Spec_Hash_Definitions_hash_alg thd;
}
K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg;

typedef struct
K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_TLSInfo_pre_hsId_FStar_Bytes_bytes_s
{
  FStar_Pervasives_Native_option__CommonDH_keyShareEntry fst;
  TLSInfo_pre_hsId *snd;
  FStar_Bytes_bytes thd;
}
K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_TLSInfo_pre_hsId_FStar_Bytes_bytes;

static K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
Old_KeySchedule_ks_server_13_init(
  Old_KeySchedule_ks ks,
  FStar_Bytes_bytes cr,
  CipherSuite_cipherSuite_ cs,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes pskid,
  FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ g_gx
)
{
  Old_KeySchedule_print("ks_server_init");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if (scrut0.tag == Old_KeySchedule_S && scrut0.val.case_S.tag == Old_KeySchedule_S_Init)
  {
    FStar_Bytes_bytes sr = scrut0.val.case_S.val.case_S_Init;
    if (cs.tag == CipherSuite_CipherSuite13)
    {
      Spec_Hash_Definitions_hash_alg h1 = cs.val.case_CipherSuite13._1;
      EverCrypt_aead_alg ae = cs.val.case_CipherSuite13._0;
      K___TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
      scrut0;
      if (pskid.tag == FStar_Pervasives_Native_Some)
      {
        FStar_Bytes_bytes id1 = pskid.v;
        Old_KeySchedule_print(Prims_strcat("Using negotiated PSK identity: ",
            FStar_Bytes_print_bytes(id1)));
        FStar_Pervasives_Native_option__Ticket_ticket scrut1 = Ticket_check_ticket(false, id1);
        K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg uu____0;
        if (scrut1.tag == FStar_Pervasives_Native_Some && scrut1.v.tag == Ticket_Ticket13)
        {
          FStar_Bytes_bytes rms = scrut1.v.val.case_Ticket13.rms;
          TLSInfo_pre_rmsId *rmsId = scrut1.v.val.case_Ticket13.rmsId;
          TLSInfo_logInfo li = scrut1.v.val.case_Ticket13.li;
          CipherSuite_cipherSuite_ cs1 = scrut1.v.val.case_Ticket13.cs;
          Old_KeySchedule_print(Prims_strcat("Ticket RMS: ", FStar_Bytes_print_bytes(rms)));
          KRML_CHECK_SIZE(sizeof (TLSInfo_pre_esId), (uint32_t)1U);
          TLSInfo_pre_esId *i1 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_esId));
          i1[0U]
          =
            (
              (TLSInfo_pre_esId){
                .tag = TLSInfo_ResumptionPSK,
                .val = { .case_ResumptionPSK = { .li = li, .i = rmsId } }
              }
            );
          if (cs1.tag == CipherSuite_CipherSuite13)
          {
            Spec_Hash_Definitions_hash_alg h2 = cs1.val.case_CipherSuite13._1;
            K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = FStar_Bytes_split(id1, (uint32_t)12U);
            FStar_Bytes_bytes nonce = scrut.fst;
            FStar_Bytes_bytes psk = HKDF_derive_secret(h2, rms, "resumption", nonce);
            uu____0 =
              (
                (K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg){
                  .fst = i1,
                  .snd = psk,
                  .thd = h2
                }
              );
          }
          else
            uu____0 =
              KRML_EABORT(K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg,
                "unreachable (pattern matches are exhaustive in F*)");
        }
        else if (scrut1.tag == FStar_Pervasives_Native_None)
        {
          K___TLSInfo_pre_esId_TLSConstants_pskInfo_FStar_Bytes_bytes
          scrut = Old_KeySchedule_read_psk(id1);
          TLSInfo_pre_esId *i1 = scrut.fst;
          TLSConstants_pskInfo pski = scrut.snd;
          FStar_Bytes_bytes psk = scrut.thd;
          uu____0 =
            (
              (K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg){
                .fst = i1,
                .snd = psk,
                .thd = pski.early_hash
              }
            );
        }
        else
          uu____0 =
            KRML_EABORT(K___TLSInfo_pre_esId_FStar_Bytes_bytes_Spec_Hash_Definitions_hash_alg,
              "unreachable (pattern matches are exhaustive in F*)");
        TLSInfo_pre_esId *i1 = uu____0.fst;
        FStar_Bytes_bytes psk = uu____0.snd;
        Spec_Hash_Definitions_hash_alg h2 = uu____0.thd;
        Old_KeySchedule_print(Prims_strcat("Pre-shared key: ", FStar_Bytes_print_bytes(psk)));
        FStar_Bytes_bytes es = HMAC_hmac(h2, Hashing_Spec_zeroHash(h2), psk);
        K___TLSInfo_binderLabel_Prims_string scrut;
        if (TLSInfo_uu___is_ApplicationPSK(i1))
          scrut =
            (
              (K___TLSInfo_binderLabel_Prims_string){
                .fst = TLSInfo_ExtBinder,
                .snd = "ext binder"
              }
            );
        else
          scrut =
            (
              (K___TLSInfo_binderLabel_Prims_string){
                .fst = TLSInfo_ResBinder,
                .snd = "res binder"
              }
            );
        TLSInfo_binderLabel ll = scrut.fst;
        Prims_string lb = scrut.snd;
        KRML_CHECK_SIZE(sizeof (TLSInfo_pre_binderId), (uint32_t)1U);
        TLSInfo_pre_binderId *bId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_binderId));
        bId[0U] = ((TLSInfo_pre_binderId){ ._0 = i1, ._1 = ll });
        FStar_Bytes_bytes bk = HKDF_derive_secret(h2, es, lb, Hashing_Spec_emptyHash(h2));
        Old_KeySchedule_print(Prims_strcat("binder key:                      ",
            FStar_Bytes_print_bytes(bk)));
        FStar_Bytes_bytes bk1 = Old_KeySchedule_finished_13(h2, bk);
        Old_KeySchedule_print(Prims_strcat("binder Finished key:             ",
            FStar_Bytes_print_bytes(bk1)));
        Old_HMAC_UFCMA_key
        bk2 =
          Old_HMAC_UFCMA_coerce((
              (Old_HMAC_UFCMA_id){
                .tag = Old_HMAC_UFCMA_HMAC_Binder,
                .val = { .case_HMAC_Binder = bId }
              }
            ),
            bk1);
        scrut0 =
          (
            (K___TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key){
              .fst = i1,
              .snd = es,
              .thd = { .tag = FStar_Pervasives_Native_Some, .v = { .fst = bId, .snd = bk2 } }
            }
          );
      }
      else if (pskid.tag == FStar_Pervasives_Native_None)
      {
        Old_KeySchedule_print("No PSK selected.");
        KRML_CHECK_SIZE(sizeof (TLSInfo_pre_esId), (uint32_t)1U);
        TLSInfo_pre_esId *esId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_esId));
        esId[0U] = ((TLSInfo_pre_esId){ .tag = TLSInfo_NoPSK, .val = { .case_NoPSK = h1 } });
        FStar_Bytes_bytes es = HMAC_hmac(h1, Hashing_Spec_zeroHash(h1), Hashing_Spec_zeroHash(h1));
        scrut0 =
          (
            (K___TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key){
              .fst = esId,
              .snd = es,
              .thd = { .tag = FStar_Pervasives_Native_None }
            }
          );
      }
      else
        scrut0 =
          KRML_EABORT(K___TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key,
            "unreachable (pattern matches are exhaustive in F*)");
      TLSInfo_pre_esId *esId = scrut0.fst;
      FStar_Bytes_bytes es = scrut0.snd;
      FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
      bk = scrut0.thd;
      Old_KeySchedule_print(Prims_strcat("Computed early secret:           ",
          FStar_Bytes_print_bytes(es)));
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
      TLSInfo_pre_secretId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
      buf[0U]
      =
        (
          (TLSInfo_pre_secretId){
            .tag = TLSInfo_EarlySecretID,
            .val = { .case_EarlySecretID = esId }
          }
        );
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_saltId), (uint32_t)1U);
      TLSInfo_pre_saltId *saltId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_saltId));
      saltId[0U] = ((TLSInfo_pre_saltId){ ._0 = buf });
      FStar_Bytes_bytes salt = HKDF_derive_secret(h1, es, "derived", Hashing_Spec_emptyHash(h1));
      Old_KeySchedule_print(Prims_strcat("Handshake salt:                  ",
          FStar_Bytes_print_bytes(salt)));
      K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_TLSInfo_pre_hsId_FStar_Bytes_bytes
      scrut1;
      if (g_gx.tag == FStar_Pervasives_Native_Some)
      {
        CommonDH_pre_share_ gx = g_gx.v.snd;
        CommonDH_group_ g1 = g_gx.v.fst;
        K___CommonDH_pre_share__FStar_Bytes_bytes scrut = CommonDH_dh_responder(g1, gx);
        CommonDH_pre_share_ gy = scrut.fst;
        FStar_Bytes_bytes gxy = scrut.snd;
        Old_KeySchedule_print(Prims_strcat("DH shared secret: ", FStar_Bytes_print_bytes(gxy)));
        KRML_CHECK_SIZE(sizeof (TLSInfo_pre_hsId), (uint32_t)1U);
        TLSInfo_pre_hsId *hsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_hsId));
        hsId[0U]
        =
          (
            (TLSInfo_pre_hsId){
              .tag = TLSInfo_HSID_DHE,
              .val = { .case_HSID_DHE = { ._0 = saltId, .g = g1, .si = gx, .sr = gy } }
            }
          );
        FStar_Bytes_bytes hs = HMAC_hmac(h1, salt, gxy);
        scrut1 =
          (
            (K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_TLSInfo_pre_hsId_FStar_Bytes_bytes){
              .fst = {
                .tag = FStar_Pervasives_Native_Some,
                .v = { .tag = CommonDH_Share, .val = { .case_Share = { .g = g1, ._1 = gy } } }
              },
              .snd = hsId,
              .thd = hs
            }
          );
      }
      else if (g_gx.tag == FStar_Pervasives_Native_None)
      {
        KRML_CHECK_SIZE(sizeof (TLSInfo_pre_hsId), (uint32_t)1U);
        TLSInfo_pre_hsId *hsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_hsId));
        hsId[0U]
        = ((TLSInfo_pre_hsId){ .tag = TLSInfo_HSID_PSK, .val = { .case_HSID_PSK = saltId } });
        FStar_Bytes_bytes hs = HMAC_hmac(h1, salt, Hashing_Spec_zeroHash(h1));
        scrut1 =
          (
            (K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_TLSInfo_pre_hsId_FStar_Bytes_bytes){
              .fst = { .tag = FStar_Pervasives_Native_None },
              .snd = hsId,
              .thd = hs
            }
          );
      }
      else
        scrut1 =
          KRML_EABORT(K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_TLSInfo_pre_hsId_FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
      FStar_Pervasives_Native_option__CommonDH_keyShareEntry gy = scrut1.fst;
      TLSInfo_pre_hsId *hsId = scrut1.snd;
      FStar_Bytes_bytes hs = scrut1.thd;
      FStar_Pervasives_Native_option__CommonDH_keyShareEntry gy1 = gy;
      Old_KeySchedule_print(Prims_strcat("Handshake secret:                ",
          FStar_Bytes_print_bytes(hs)));
      st[0U] =
        (
          (Old_KeySchedule_ks_state){
            .tag = Old_KeySchedule_S,
            .val = {
              .case_S = {
                .tag = Old_KeySchedule_S_13_wait_SH,
                .val = {
                  .case_S_13_wait_SH = {
                    .alpha = { .fst = ae, .snd = h1 }, .cr = cr, .sr = sr,
                    .es = { .fst = esId, .snd = es }, .hs = { .fst = hsId, .snd = hs }
                  }
                }
              }
            }
          }
        );
      return
        (
          (K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key){
            .fst = gy1,
            .snd = bk
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance
Old_KeySchedule_ks_server_13_0rtt_key(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print("ks_server_13_0rtt_key");
  Old_KeySchedule_ks_state *st = ks.state;
  bool is_quic = ks.is_quic;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if (scrut0.tag == Old_KeySchedule_S && scrut0.val.case_S.tag == Old_KeySchedule_S_13_wait_SH)
  {
    FStar_Bytes_bytes es = scrut0.val.case_S.val.case_S_13_wait_SH.es.snd;
    TLSInfo_pre_esId *esId = scrut0.val.case_S.val.case_S_13_wait_SH.es.fst;
    FStar_Bytes_bytes cr = scrut0.val.case_S.val.case_S_13_wait_SH.cr;
    Spec_Hash_Definitions_hash_alg h1 = scrut0.val.case_S.val.case_S_13_wait_SH.alpha.snd;
    EverCrypt_aead_alg ae = scrut0.val.case_S.val.case_S_13_wait_SH.alpha.fst;
    TLSInfo_logInfo
    li =
      {
        .tag = TLSInfo_LogInfo_CH0,
        .val = {
          .case_LogInfo_CH0 = {
            .li_ch0_cr = cr,
            .li_ch0_ed_psk = FStar_Bytes_empty_bytes,
            .li_ch0_ed_ae = ae,
            .li_ch0_ed_hash = h1
          }
        }
      };
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
    TLSInfo_pre_secretId *buf0 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
    buf0[0U]
    =
      (
        (TLSInfo_pre_secretId){
          .tag = TLSInfo_EarlySecretID,
          .val = { .case_EarlySecretID = esId }
        }
      );
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf1 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf1[0U] = TLSInfo_ClientEarlyTrafficSecret;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = buf0, ._1 = buf1, ._2 = log2 });
    FStar_Bytes_bytes ets = HKDF_derive_secret(h1, es, "c e traffic", log2);
    Old_KeySchedule_print(Prims_strcat("Client early traffic secret:     ",
        FStar_Bytes_print_bytes(ets)));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_exportId), (uint32_t)1U);
    TLSInfo_pre_exportId *expId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_exportId));
    expId[0U]
    =
      (
        (TLSInfo_pre_exportId){
          .tag = TLSInfo_EarlyExportID,
          .val = { .case_EarlyExportID = { ._0 = esId, ._1 = log2 } }
        }
      );
    FStar_Bytes_bytes early_export = HKDF_derive_secret(h1, es, "e exp master", log2);
    Old_KeySchedule_print(Prims_strcat("Early exporter master secret:    ",
        FStar_Bytes_print_bytes(early_export)));
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut = Old_KeySchedule_keygen_13(h1, ets, ae, is_quic);
    FStar_Bytes_bytes ck = scrut.fst;
    FStar_Bytes_bytes civ = scrut.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes pn = scrut.thd;
    Old_KeySchedule_print(Prims_strcat("Client 0-RTT key:                ",
        Prims_strcat(FStar_Bytes_print_bytes(ck),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(civ)))));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
    TLSInfo_pre_keyId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
    buf[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = expandId });
    TLSInfo_id id1 = { .tag = TLSInfo_ID13, .val = { .case_ID13 = buf } };
    FStar_Bytes_bytes ckv = ck;
    FStar_Bytes_bytes civ1 = civ;
    StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(ckv, civ1));
    StAE_state r = StAE_genReader(id1, rw);
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes ts;
    if (pn.tag == FStar_Pervasives_Native_None)
      ts =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (pn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn1 = pn.v;
      ts =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn1, .snd = ets }
          }
        );
    }
    else
      ts =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    Old_KeySchedule_recordInstance
    early_d = { .id = id1, .r = r, .w = rw, ._3 = { .fst = ts, .snd = ts } };
    return
      (
        (K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance){
          .fst = { ._1 = li, ._2 = expId, ._3 = early_export },
          .snd = early_d
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_KeySchedule_recordInstance
Old_KeySchedule_ks_server_13_sh(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_server_13_sh, hashed log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  bool is_quic = ks.is_quic;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if (scrut0.tag == Old_KeySchedule_S && scrut0.val.case_S.tag == Old_KeySchedule_S_13_wait_SH)
  {
    FStar_Bytes_bytes hs = scrut0.val.case_S.val.case_S_13_wait_SH.hs.snd;
    TLSInfo_pre_hsId *hsId = scrut0.val.case_S.val.case_S_13_wait_SH.hs.fst;
    FStar_Bytes_bytes sr = scrut0.val.case_S.val.case_S_13_wait_SH.sr;
    FStar_Bytes_bytes cr = scrut0.val.case_S.val.case_S_13_wait_SH.cr;
    Spec_Hash_Definitions_hash_alg h1 = scrut0.val.case_S.val.case_S_13_wait_SH.alpha.snd;
    EverCrypt_aead_alg ae = scrut0.val.case_S.val.case_S_13_wait_SH.alpha.fst;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
    TLSInfo_pre_secretId *secretId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
    secretId[0U]
    =
      (
        (TLSInfo_pre_secretId){
          .tag = TLSInfo_HandshakeSecretID,
          .val = { .case_HandshakeSecretID = hsId }
        }
      );
    TLSInfo_logInfo
    li =
      {
        .tag = TLSInfo_LogInfo_SH,
        .val = {
          .case_LogInfo_SH = {
            .li_sh_cr = cr, .li_sh_sr = sr, .li_sh_ae = ae, .li_sh_hash = h1,
            .li_sh_psk = { .tag = FStar_Pervasives_Native_None }
          }
        }
      };
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf0 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf0[0U] = TLSInfo_ClientHandshakeTrafficSecret;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *c_expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    c_expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = secretId, ._1 = buf0, ._2 = log2 });
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf1 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf1[0U] = TLSInfo_ServerHandshakeTrafficSecret;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *s_expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    s_expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = secretId, ._1 = buf1, ._2 = log2 });
    FStar_Bytes_bytes cts = HKDF_derive_secret(h1, hs, "c hs traffic", log2);
    Old_KeySchedule_print(Prims_strcat("handshake traffic secret[C]:     ",
        FStar_Bytes_print_bytes(cts)));
    FStar_Bytes_bytes sts = HKDF_derive_secret(h1, hs, "s hs traffic", log2);
    Old_KeySchedule_print(Prims_strcat("handshake traffic secret[S]:     ",
        FStar_Bytes_print_bytes(sts)));
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut0 = Old_KeySchedule_keygen_13(h1, cts, ae, is_quic);
    FStar_Bytes_bytes ck = scrut0.fst;
    FStar_Bytes_bytes civ = scrut0.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes cpn = scrut0.thd;
    Old_KeySchedule_print(Prims_strcat("handshake key[C]:                ",
        Prims_strcat(FStar_Bytes_print_bytes(ck),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(civ)))));
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut = Old_KeySchedule_keygen_13(h1, sts, ae, is_quic);
    FStar_Bytes_bytes sk = scrut.fst;
    FStar_Bytes_bytes siv = scrut.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes spn = scrut.thd;
    Old_KeySchedule_print(Prims_strcat("handshake key[S]: ",
        Prims_strcat(FStar_Bytes_print_bytes(sk),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(siv)))));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
    TLSInfo_pre_keyId *buf2 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
    buf2[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = c_expandId });
    TLSInfo_id id1 = { .tag = TLSInfo_ID13, .val = { .case_ID13 = buf2 } };
    FStar_Bytes_bytes ckv = ck;
    FStar_Bytes_bytes civ1 = civ;
    FStar_Bytes_bytes skv = sk;
    FStar_Bytes_bytes siv1 = siv;
    StAE_state w = StAE_coerce(id1, FStar_Bytes_append(skv, siv1));
    StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(ckv, civ1));
    StAE_state r = StAE_genReader(id1, rw);
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_finishedId), (uint32_t)1U);
    TLSInfo_pre_finishedId *cfkId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_finishedId));
    cfkId[0U] = ((TLSInfo_pre_finishedId){ .li = li, ._1 = c_expandId });
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_finishedId), (uint32_t)1U);
    TLSInfo_pre_finishedId *sfkId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_finishedId));
    sfkId[0U] = ((TLSInfo_pre_finishedId){ .li = li, ._1 = s_expandId });
    FStar_Bytes_bytes cfk1 = Old_KeySchedule_finished_13(h1, cts);
    Old_KeySchedule_print(Prims_strcat("finished key[C]:                 ",
        FStar_Bytes_print_bytes(cfk1)));
    FStar_Bytes_bytes sfk1 = Old_KeySchedule_finished_13(h1, sts);
    Old_KeySchedule_print(Prims_strcat("finished key[S]:                 ",
        FStar_Bytes_print_bytes(sfk1)));
    Old_HMAC_UFCMA_key
    cfk11 =
      Old_HMAC_UFCMA_coerce((
          (Old_HMAC_UFCMA_id){
            .tag = Old_HMAC_UFCMA_HMAC_Finished,
            .val = { .case_HMAC_Finished = cfkId }
          }
        ),
        cfk1);
    Old_HMAC_UFCMA_key
    sfk11 =
      Old_HMAC_UFCMA_coerce((
          (Old_HMAC_UFCMA_id){
            .tag = Old_HMAC_UFCMA_HMAC_Finished,
            .val = { .case_HMAC_Finished = sfkId }
          }
        ),
        sfk1);
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
    TLSInfo_pre_secretId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
    buf[0U]
    =
      (
        (TLSInfo_pre_secretId){
          .tag = TLSInfo_HandshakeSecretID,
          .val = { .case_HandshakeSecretID = hsId }
        }
      );
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_saltId), (uint32_t)1U);
    TLSInfo_pre_saltId *saltId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_saltId));
    saltId[0U] = ((TLSInfo_pre_saltId){ ._0 = buf });
    FStar_Bytes_bytes salt = HKDF_derive_secret(h1, hs, "derived", Hashing_Spec_emptyHash(h1));
    Old_KeySchedule_print(Prims_strcat("Application salt:                ",
        FStar_Bytes_print_bytes(salt)));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_asId), (uint32_t)1U);
    TLSInfo_pre_asId *amsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_asId));
    amsId[0U] = ((TLSInfo_pre_asId){ ._0 = saltId });
    FStar_Bytes_bytes ams = HMAC_hmac(h1, salt, Hashing_Spec_zeroHash(h1));
    Old_KeySchedule_print(Prims_strcat("Application secret:              ",
        FStar_Bytes_print_bytes(ams)));
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_S,
          .val = {
            .case_S = {
              .tag = Old_KeySchedule_S_13_wait_SF,
              .val = {
                .case_S_13_wait_SF = {
                  .alpha = { .fst = ae, .snd = h1 },
                  ._1 = { .fst = cfkId, .snd = cfk11 },
                  ._2 = { .fst = sfkId, .snd = sfk11 },
                  ._3 = { .fst = amsId, .snd = ams }
                }
              }
            }
          }
        }
      );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes cts1;
    if (cpn.tag == FStar_Pervasives_Native_None)
      cts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (cpn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn = cpn.v;
      cts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn, .snd = cts }
          }
        );
    }
    else
      cts1 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes sts1;
    if (spn.tag == FStar_Pervasives_Native_None)
      sts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (spn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn = spn.v;
      sts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn, .snd = sts }
          }
        );
    }
    else
      sts1 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    return
      (
        (Old_KeySchedule_recordInstance){
          .id = id1,
          .r = r,
          .w = w,
          ._3 = { .fst = cts1, .snd = sts1 }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
Old_KeySchedule_ks_server_13_server_finished(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_13_wait_SF)
    return scrut.val.case_S.val.case_S_13_wait_SF._2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
Old_KeySchedule_ks_server_13_client_finished(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_13_wait_CF)
    return scrut.val.case_S.val.case_S_13_wait_CF._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes Old_KeySchedule_ks_12_finished_key(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  FStar_Bytes_bytes ms;
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_12_has_MS)
    ms = scrut.val.case_C.val.case_C_12_has_MS.ms;
  else if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_12_has_MS)
    ms = scrut.val.case_S.val.case_S_12_has_MS.ms;
  else
    ms = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  return TLSPRF_coerce(ms);
}

typedef struct K___TLSInfo_msId_FStar_Bytes_bytes_s
{
  TLSInfo_msId fst;
  FStar_Bytes_bytes snd;
}
K___TLSInfo_msId_FStar_Bytes_bytes;

static K___TLSInfo_msId_FStar_Bytes_bytes Old_KeySchedule_ks_12_ms(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_12_has_MS)
  {
    FStar_Bytes_bytes ms = scrut.val.case_C.val.case_C_12_has_MS.ms;
    TLSInfo_msId msId = scrut.val.case_C.val.case_C_12_has_MS.id;
    return ((K___TLSInfo_msId_FStar_Bytes_bytes){ .fst = msId, .snd = ms });
  }
  else if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_12_has_MS)
  {
    FStar_Bytes_bytes ms = scrut.val.case_S.val.case_S_12_has_MS.ms;
    TLSInfo_msId msId = scrut.val.case_S.val.case_S_12_has_MS.id;
    return ((K___TLSInfo_msId_FStar_Bytes_bytes){ .fst = msId, .snd = ms });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___TLSConstants_role_FStar_Bytes_bytes_K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes_s
{
  TLSConstants_role fst;
  FStar_Bytes_bytes snd;
  K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool thd;
  TLSInfo_msId f3;
  FStar_Bytes_bytes f4;
}
K___TLSConstants_role_FStar_Bytes_bytes_K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes;

static Old_KeySchedule_recordInstance Old_KeySchedule_ks_12_record_key(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_print("ks_12_record_key");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  K___TLSConstants_role_FStar_Bytes_bytes_K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes
  scrut1;
  if (scrut0.tag == Old_KeySchedule_C && scrut0.val.case_C.tag == Old_KeySchedule_C_12_has_MS)
  {
    FStar_Bytes_bytes ms = scrut0.val.case_C.val.case_C_12_has_MS.ms;
    TLSInfo_msId msId = scrut0.val.case_C.val.case_C_12_has_MS.id;
    K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool
    alpha = scrut0.val.case_C.val.case_C_12_has_MS.alpha;
    FStar_Bytes_bytes csr = scrut0.val.case_C.val.case_C_12_has_MS.csr;
    scrut1 =
      (
        (K___TLSConstants_role_FStar_Bytes_bytes_K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes){
          .fst = TLSConstants_Client,
          .snd = csr,
          .thd = alpha,
          .f3 = msId,
          .f4 = ms
        }
      );
  }
  else if
  (scrut0.tag == Old_KeySchedule_S && scrut0.val.case_S.tag == Old_KeySchedule_S_12_has_MS)
  {
    FStar_Bytes_bytes ms = scrut0.val.case_S.val.case_S_12_has_MS.ms;
    TLSInfo_msId msId = scrut0.val.case_S.val.case_S_12_has_MS.id;
    K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool
    alpha = scrut0.val.case_S.val.case_S_12_has_MS.alpha;
    FStar_Bytes_bytes csr = scrut0.val.case_S.val.case_S_12_has_MS.csr;
    scrut1 =
      (
        (K___TLSConstants_role_FStar_Bytes_bytes_K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes){
          .fst = TLSConstants_Server,
          .snd = csr,
          .thd = alpha,
          .f3 = msId,
          .f4 = ms
        }
      );
  }
  else
    scrut1 =
      KRML_EABORT(K___TLSConstants_role_FStar_Bytes_bytes_K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes,
        "unreachable (pattern matches are exhaustive in F*)");
  TLSConstants_role role = scrut1.fst;
  FStar_Bytes_bytes csr = scrut1.snd;
  K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool alpha = scrut1.thd;
  TLSInfo_msId msId = scrut1.f3;
  FStar_Bytes_bytes ms = scrut1.f4;
  K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut2 = FStar_Bytes_split(csr, (uint32_t)32U);
  FStar_Bytes_bytes cr = scrut2.fst;
  FStar_Bytes_bytes sr = scrut2.snd;
  Parsers_ProtocolVersion_protocolVersion pv = alpha.fst;
  CipherSuite_cipherSuite_ cs = alpha.snd;
  TLSConstants_prePrfAlg kdf1 = TLSInfo_kdfAlg(pv, cs);
  CipherSuite_aeAlg ae = TLSConstants_get_aeAlg(cs);
  TLSInfo_id
  id1 =
    {
      .tag = TLSInfo_ID12,
      .val = {
        .case_ID12 = {
          .pv = pv, .msId = msId, .kdfAlg = kdf1, .aeAlg = ae, .cr = cr, .sr = sr, .writer = role
        }
      }
    };
  if (ae.tag == CipherSuite_AEAD)
  {
    EverCrypt_aead_alg alg1 = ae.val.case_AEAD._0;
    uint32_t klen = EverCrypt_aead_keyLen(alg1);
    uint32_t slen = FStar_UInt32_uint_to_t(AEADProvider_salt_length(id1));
    FStar_Bytes_bytes
    expand1 = TLSPRF_kdf(kdf1, ms, FStar_Bytes_append(sr, cr), klen + klen + slen + slen);
    Old_KeySchedule_print(Prims_strcat("keystring (CK, CIV, SK, SIV) = ",
        FStar_Bytes_print_bytes(expand1)));
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(expand1, klen);
    FStar_Bytes_bytes k1 = scrut0.fst;
    FStar_Bytes_bytes expand2 = scrut0.snd;
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut1 = FStar_Bytes_split(expand2, klen);
    FStar_Bytes_bytes k2 = scrut1.fst;
    FStar_Bytes_bytes expand3 = scrut1.snd;
    K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut2 = FStar_Bytes_split(expand3, slen);
    FStar_Bytes_bytes iv1 = scrut2.fst;
    FStar_Bytes_bytes iv2 = scrut2.snd;
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes scrut;
    switch (role)
    {
      case TLSConstants_Client:
        {
          scrut =
            (
              (K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes){
                .fst = k1,
                .snd = iv1,
                .thd = k2,
                .f3 = iv2
              }
            );
          break;
        }
      case TLSConstants_Server:
        {
          scrut =
            (
              (K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes){
                .fst = k2,
                .snd = iv2,
                .thd = k1,
                .f3 = iv1
              }
            );
          break;
        }
      default:
        {
          KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
    FStar_Bytes_bytes wk = scrut.fst;
    FStar_Bytes_bytes wiv = scrut.snd;
    FStar_Bytes_bytes rk = scrut.thd;
    FStar_Bytes_bytes riv = scrut.f3;
    StAE_state w = StAE_coerce(id1, FStar_Bytes_append(wk, wiv));
    StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(rk, riv));
    StAE_state r = StAE_genReader(id1, rw);
    return
      (
        (Old_KeySchedule_recordInstance){
          .id = id1,
          .r = r,
          .w = w,
          ._3 = {
            .fst = { .tag = FStar_Pervasives_Native_None },
            .snd = { .tag = FStar_Pervasives_Native_None }
          }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_KeySchedule_recordInstance
Old_KeySchedule_ks_client_12_resume(
  Old_KeySchedule_ks ks,
  FStar_Bytes_bytes sr,
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_cipherSuite_ cs,
  bool ems,
  TLSInfo_msId msId,
  FStar_Bytes_bytes ms
)
{
  Old_KeySchedule_print("ks_client_12_resume");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  FStar_Bytes_bytes cr;
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_12_Full_CH)
    cr = scrut.val.case_C.val.case_C_12_Full_CH;
  else if
  (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_wait_SH)
    cr = scrut.val.case_C.val.case_C_13_wait_SH.cr;
  else
    cr = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  Old_KeySchedule_print(Prims_strcat("Recall MS: ", FStar_Bytes_print_bytes(ms)));
  st[0U] =
    (
      (Old_KeySchedule_ks_state){
        .tag = Old_KeySchedule_C,
        .val = {
          .case_C = {
            .tag = Old_KeySchedule_C_12_has_MS,
            .val = {
              .case_C_12_has_MS = {
                .csr = FStar_Bytes_append(cr, sr),
                .alpha = { .fst = pv, .snd = cs, .thd = ems },
                .id = msId,
                .ms = ms
              }
            }
          }
        }
      }
    );
  return Old_KeySchedule_ks_12_record_key(ks);
}

static Old_KeySchedule_recordInstance
Old_KeySchedule_ks_server_12_resume(
  Old_KeySchedule_ks ks,
  FStar_Bytes_bytes cr,
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_cipherSuite_ cs,
  bool ems,
  TLSInfo_msId msId,
  FStar_Bytes_bytes ms
)
{
  Old_KeySchedule_print("ks_server_12_resume");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_Init)
  {
    FStar_Bytes_bytes sr = scrut.val.case_S.val.case_S_Init;
    Old_KeySchedule_print(Prims_strcat("Recall MS: ", FStar_Bytes_print_bytes(ms)));
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_S,
          .val = {
            .case_S = {
              .tag = Old_KeySchedule_S_12_has_MS,
              .val = {
                .case_S_12_has_MS = {
                  .csr = FStar_Bytes_append(cr, sr),
                  .alpha = { .fst = pv, .snd = cs, .thd = ems },
                  .id = msId,
                  .ms = ms
                }
              }
            }
          }
        }
      );
    return Old_KeySchedule_ks_12_record_key(ks);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_KeySchedule_recordInstance
Old_KeySchedule_ks_server_12_cke_dh(
  Old_KeySchedule_ks ks,
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ gy,
  FStar_Bytes_bytes hashed_log
)
{
  Old_KeySchedule_print("ks_server_12_cke_dh");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if
  (scrut0.tag == Old_KeySchedule_S && scrut0.val.case_S.tag == Old_KeySchedule_S_12_wait_CKE_DH)
  {
    CommonDH_pre_keyshare_ gx = scrut0.val.case_S.val.case_S_12_wait_CKE_DH.our_share.snd;
    CommonDH_group_ g1 = scrut0.val.case_S.val.case_S_12_wait_CKE_DH.our_share.fst;
    K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool
    alpha = scrut0.val.case_S.val.case_S_12_wait_CKE_DH.alpha;
    FStar_Bytes_bytes csr = scrut0.val.case_S.val.case_S_12_wait_CKE_DH.csr;
    Parsers_ProtocolVersion_protocolVersion pv = alpha.fst;
    CipherSuite_cipherSuite_ cs = alpha.snd;
    bool ems = alpha.thd;
    CommonDH_group_ uu____0 = gy.fst;
    CommonDH_pre_share_ gy1 = gy.snd;
    Old_KeySchedule_print_share(uu____0, gy1);
    FStar_Bytes_bytes pmsb = CommonDH_dh_initiator(g1, gx, gy1);
    Old_KeySchedule_print(Prims_strcat("PMS: ", FStar_Bytes_print_bytes(pmsb)));
    PMS_pms
    pmsId =
      {
        .tag = PMS_DHPMS,
        .val = {
          .case_DHPMS = {
            .g = g1,
            .gx = CommonDH_ipubshare(g1, gx),
            ._2 = gy1,
            ._3 = { .tag = PMS_ConcreteDHPMS, .val = { .case_ConcreteDHPMS = pmsb } }
          }
        }
      };
    TLSConstants_prePrfAlg kef = TLSInfo_kefAlg(pv, cs, ems);
    K___TLSInfo_msId_FStar_Bytes_bytes scrut;
    if (ems)
    {
      FStar_Bytes_bytes
      ms =
        TLSPRF_prf((
            (K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite_){
              .fst = pv,
              .snd = cs
            }
          ),
          pmsb,
          FStar_Bytes_utf8_encode("extended master secret"),
          hashed_log,
          (uint32_t)48U);
      Old_KeySchedule_print(Prims_strcat("extended master secret:", FStar_Bytes_print_bytes(ms)));
      TLSInfo_msId
      msId =
        {
          .tag = TLSInfo_ExtendedMS,
          .val = { .case_ExtendedMS = { ._0 = pmsId, ._1 = hashed_log, ._2 = kef } }
        };
      scrut = ((K___TLSInfo_msId_FStar_Bytes_bytes){ .fst = msId, .snd = ms });
    }
    else
    {
      FStar_Bytes_bytes ms = TLSPRF_extract(kef, pmsb, csr, (uint32_t)48U);
      Old_KeySchedule_print(Prims_strcat("master secret:", FStar_Bytes_print_bytes(ms)));
      TLSInfo_msId
      msId =
        {
          .tag = TLSInfo_StandardMS,
          .val = { .case_StandardMS = { ._0 = pmsId, ._1 = csr, ._2 = kef } }
        };
      scrut = ((K___TLSInfo_msId_FStar_Bytes_bytes){ .fst = msId, .snd = ms });
    }
    TLSInfo_msId msId = scrut.fst;
    FStar_Bytes_bytes ms = scrut.snd;
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_S,
          .val = {
            .case_S = {
              .tag = Old_KeySchedule_S_12_has_MS,
              .val = { .case_S_12_has_MS = { .csr = csr, .alpha = alpha, .id = msId, .ms = ms } }
            }
          }
        }
      );
    return Old_KeySchedule_ks_12_record_key(ks);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
Old_KeySchedule_group_matches(
  CommonDH_group_ g1,
  Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ gx
)
{
  CommonDH_group_ g_ = gx.fst;
  return __eq__CommonDH_group_(g1, g_);
}

typedef struct
FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes v;
}
FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes;

static FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
FStar_List_Tot_Base_nth__Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(
  Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *l,
  Prims_int n
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *tl1 = l->tl;
    Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes hd1 = l->hd;
    if (n == (krml_checked_int_t)0)
      return
        (
          (FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return
        FStar_List_Tot_Base_nth__Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(tl1,
          Prims_op_Subtraction(n, (krml_checked_int_t)1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare__s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ v;
}
FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_;

static FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
List_Helpers_find_aux__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_group_(
  CommonDH_group_ env,
  bool (*f)(CommonDH_group_ x0, Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ x1),
  Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ *l
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ *tl1 = l->tl;
    Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_ hd1 = l->hd;
    if (f(env, hd1))
      return
        (
          (FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return
        List_Helpers_find_aux__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_group_(env,
          f,
          tl1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_int_s
{
  Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *fst;
  FStar_Pervasives_Native_option__Prims_int snd;
}
K___Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_int;

static Old_KeySchedule_recordInstance
Old_KeySchedule_ks_client_13_sh(
  Old_KeySchedule_ks ks,
  FStar_Bytes_bytes sr,
  CipherSuite_cipherSuite_ cs,
  FStar_Bytes_bytes log1,
  FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ gy,
  FStar_Pervasives_Native_option__Prims_int accept_psk
)
{
  Old_KeySchedule_print(Prims_strcat("ks_client_13_sh hashed_log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  bool is_quic = ks.is_quic;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if (scrut0.tag == Old_KeySchedule_C && scrut0.val.case_C.tag == Old_KeySchedule_C_13_wait_SH)
  {
    Prims_list__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
    *gc = scrut0.val.case_C.val.case_C_13_wait_SH.gs;
    Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
    *esl = scrut0.val.case_C.val.case_C_13_wait_SH.esl;
    FStar_Bytes_bytes cr = scrut0.val.case_C.val.case_C_13_wait_SH.cr;
    if (cs.tag == CipherSuite_CipherSuite13)
    {
      Spec_Hash_Definitions_hash_alg h1 = cs.val.case_CipherSuite13._1;
      EverCrypt_aead_alg ae = cs.val.case_CipherSuite13._0;
      K___Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes_FStar_Pervasives_Native_option__Prims_int
      scrut0 = { .fst = esl, .snd = accept_psk };
      Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes uu____0;
      if (scrut0.snd.tag == FStar_Pervasives_Native_Some)
      {
        Prims_int n1 = scrut0.snd.v;
        Prims_list__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes *l = scrut0.fst;
        FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes
        uu____1 = FStar_List_Tot_Base_nth__Prims_dtuple2_TLSInfo_pre_esId_FStar_Bytes_bytes(l, n1);
        if (uu____1.tag == FStar_Pervasives_Native_Some)
        {
          FStar_Bytes_bytes es = uu____1.v.snd;
          TLSInfo_pre_esId *i1 = uu____1.v.fst;
          Old_KeySchedule_print(Prims_strcat("recallPSK early secret:          ",
              FStar_Bytes_print_bytes(es)));
          uu____0 = ((Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){ .fst = i1, .snd = es });
        }
        else
          uu____0 =
            KRML_EABORT(Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes,
              "unreachable (pattern matches are exhaustive in F*)");
      }
      else if (scrut0.snd.tag == FStar_Pervasives_Native_None)
      {
        FStar_Bytes_bytes es = HMAC_hmac(h1, Hashing_Spec_zeroHash(h1), Hashing_Spec_zeroHash(h1));
        Old_KeySchedule_print(Prims_strcat("no PSK negotiated. Early secret: ",
            FStar_Bytes_print_bytes(es)));
        KRML_CHECK_SIZE(sizeof (TLSInfo_pre_esId), (uint32_t)1U);
        TLSInfo_pre_esId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_esId));
        buf[0U] = ((TLSInfo_pre_esId){ .tag = TLSInfo_NoPSK, .val = { .case_NoPSK = h1 } });
        uu____0 = ((Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes){ .fst = buf, .snd = es });
      }
      else
        uu____0 =
          KRML_EABORT(Prims_dtuple2__TLSInfo_pre_esId_FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
      TLSInfo_pre_esId *esId = uu____0.fst;
      FStar_Bytes_bytes es = uu____0.snd;
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
      TLSInfo_pre_secretId *buf0 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
      buf0[0U]
      =
        (
          (TLSInfo_pre_secretId){
            .tag = TLSInfo_EarlySecretID,
            .val = { .case_EarlySecretID = esId }
          }
        );
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_saltId), (uint32_t)1U);
      TLSInfo_pre_saltId *saltId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_saltId));
      saltId[0U] = ((TLSInfo_pre_saltId){ ._0 = buf0 });
      FStar_Bytes_bytes salt = HKDF_derive_secret(h1, es, "derived", Hashing_Spec_emptyHash(h1));
      Old_KeySchedule_print(Prims_strcat("handshake salt:                  ",
          FStar_Bytes_print_bytes(salt)));
      Prims_dtuple2__TLSInfo_pre_hsId_FStar_Bytes_bytes uu____2;
      if (gy.tag == FStar_Pervasives_Native_Some)
      {
        CommonDH_pre_share_ gy1 = gy.v.snd;
        CommonDH_group_ g1 = gy.v.fst;
        FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_keyshare_
        scrut =
          List_Helpers_find_aux__Prims_dtuple2_CommonDH_group__CommonDH_pre_keyshare__CommonDH_group_(g1,
            Old_KeySchedule_group_matches,
            gc);
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          CommonDH_pre_keyshare_ gx = scrut.v.snd;
          CommonDH_group_ uu____3 = scrut.v.fst;
          FStar_Bytes_bytes gxy = CommonDH_dh_initiator(g1, gx, gy1);
          Old_KeySchedule_print(Prims_strcat("DH shared secret: ", FStar_Bytes_print_bytes(gxy)));
          KRML_CHECK_SIZE(sizeof (TLSInfo_pre_hsId), (uint32_t)1U);
          TLSInfo_pre_hsId *hsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_hsId));
          hsId[0U]
          =
            (
              (TLSInfo_pre_hsId){
                .tag = TLSInfo_HSID_DHE,
                .val = {
                  .case_HSID_DHE = {
                    ._0 = saltId,
                    .g = g1,
                    .si = CommonDH_ipubshare(uu____3, gx),
                    .sr = gy1
                  }
                }
              }
            );
          FStar_Bytes_bytes hs = HMAC_hmac(h1, salt, gxy);
          uu____2 = ((Prims_dtuple2__TLSInfo_pre_hsId_FStar_Bytes_bytes){ .fst = hsId, .snd = hs });
        }
        else
          uu____2 =
            KRML_EABORT(Prims_dtuple2__TLSInfo_pre_hsId_FStar_Bytes_bytes,
              "unreachable (pattern matches are exhaustive in F*)");
      }
      else if (gy.tag == FStar_Pervasives_Native_None)
      {
        KRML_CHECK_SIZE(sizeof (TLSInfo_pre_hsId), (uint32_t)1U);
        TLSInfo_pre_hsId *hsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_hsId));
        hsId[0U]
        = ((TLSInfo_pre_hsId){ .tag = TLSInfo_HSID_PSK, .val = { .case_HSID_PSK = saltId } });
        FStar_Bytes_bytes hs = HMAC_hmac(h1, salt, Hashing_Spec_zeroHash(h1));
        uu____2 = ((Prims_dtuple2__TLSInfo_pre_hsId_FStar_Bytes_bytes){ .fst = hsId, .snd = hs });
      }
      else
        uu____2 =
          KRML_EABORT(Prims_dtuple2__TLSInfo_pre_hsId_FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
      TLSInfo_pre_hsId *hsId = uu____2.fst;
      FStar_Bytes_bytes hs = uu____2.snd;
      Old_KeySchedule_print(Prims_strcat("handshake secret:                ",
          FStar_Bytes_print_bytes(hs)));
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
      TLSInfo_pre_secretId *secretId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
      secretId[0U]
      =
        (
          (TLSInfo_pre_secretId){
            .tag = TLSInfo_HandshakeSecretID,
            .val = { .case_HandshakeSecretID = hsId }
          }
        );
      TLSInfo_logInfo
      li =
        {
          .tag = TLSInfo_LogInfo_SH,
          .val = {
            .case_LogInfo_SH = {
              .li_sh_cr = cr, .li_sh_sr = sr, .li_sh_ae = ae, .li_sh_hash = h1,
              .li_sh_psk = { .tag = FStar_Pervasives_Native_None }
            }
          }
        };
      FStar_Bytes_bytes log2 = log1;
      KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
      TLSInfo_expandTag *buf1 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
      buf1[0U] = TLSInfo_ClientHandshakeTrafficSecret;
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
      TLSInfo_pre_expandId *c_expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
      c_expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = secretId, ._1 = buf1, ._2 = log2 });
      KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
      TLSInfo_expandTag *buf2 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
      buf2[0U] = TLSInfo_ServerHandshakeTrafficSecret;
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
      TLSInfo_pre_expandId *s_expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
      s_expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = secretId, ._1 = buf2, ._2 = log2 });
      FStar_Bytes_bytes cts = HKDF_derive_secret(h1, hs, "c hs traffic", log2);
      Old_KeySchedule_print(Prims_strcat("handshake traffic secret[C]:     ",
          FStar_Bytes_print_bytes(cts)));
      FStar_Bytes_bytes sts = HKDF_derive_secret(h1, hs, "s hs traffic", log2);
      Old_KeySchedule_print(Prims_strcat("handshake traffic secret[S]:     ",
          FStar_Bytes_print_bytes(sts)));
      K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
      scrut1 = Old_KeySchedule_keygen_13(h1, cts, ae, is_quic);
      FStar_Bytes_bytes ck = scrut1.fst;
      FStar_Bytes_bytes civ = scrut1.snd;
      FStar_Pervasives_Native_option__FStar_Bytes_bytes cpn = scrut1.thd;
      Old_KeySchedule_print(Prims_strcat("handshake key[C]:                ",
          Prims_strcat(FStar_Bytes_print_bytes(ck),
            Prims_strcat(", IV=", FStar_Bytes_print_bytes(civ)))));
      K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
      scrut = Old_KeySchedule_keygen_13(h1, sts, ae, is_quic);
      FStar_Bytes_bytes sk = scrut.fst;
      FStar_Bytes_bytes siv = scrut.snd;
      FStar_Pervasives_Native_option__FStar_Bytes_bytes spn = scrut.thd;
      Old_KeySchedule_print(Prims_strcat("handshake key[S]:                ",
          Prims_strcat(FStar_Bytes_print_bytes(sk),
            Prims_strcat(", IV=", FStar_Bytes_print_bytes(siv)))));
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_finishedId), (uint32_t)1U);
      TLSInfo_pre_finishedId *cfkId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_finishedId));
      cfkId[0U] = ((TLSInfo_pre_finishedId){ .li = li, ._1 = c_expandId });
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_finishedId), (uint32_t)1U);
      TLSInfo_pre_finishedId *sfkId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_finishedId));
      sfkId[0U] = ((TLSInfo_pre_finishedId){ .li = li, ._1 = s_expandId });
      FStar_Bytes_bytes cfk1 = Old_KeySchedule_finished_13(h1, cts);
      Old_KeySchedule_print(Prims_strcat("finished key[C]: ", FStar_Bytes_print_bytes(cfk1)));
      FStar_Bytes_bytes sfk1 = Old_KeySchedule_finished_13(h1, sts);
      Old_KeySchedule_print(Prims_strcat("finished key[S]: ", FStar_Bytes_print_bytes(sfk1)));
      Old_HMAC_UFCMA_key
      cfk11 =
        Old_HMAC_UFCMA_coerce((
            (Old_HMAC_UFCMA_id){
              .tag = Old_HMAC_UFCMA_HMAC_Finished,
              .val = { .case_HMAC_Finished = cfkId }
            }
          ),
          cfk1);
      Old_HMAC_UFCMA_key
      sfk11 =
        Old_HMAC_UFCMA_coerce((
            (Old_HMAC_UFCMA_id){
              .tag = Old_HMAC_UFCMA_HMAC_Finished,
              .val = { .case_HMAC_Finished = sfkId }
            }
          ),
          sfk1);
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
      TLSInfo_pre_secretId *buf3 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
      buf3[0U]
      =
        (
          (TLSInfo_pre_secretId){
            .tag = TLSInfo_HandshakeSecretID,
            .val = { .case_HandshakeSecretID = hsId }
          }
        );
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_saltId), (uint32_t)1U);
      TLSInfo_pre_saltId *saltId1 = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_saltId));
      saltId1[0U] = ((TLSInfo_pre_saltId){ ._0 = buf3 });
      FStar_Bytes_bytes salt1 = HKDF_derive_secret(h1, hs, "derived", Hashing_Spec_emptyHash(h1));
      Old_KeySchedule_print(Prims_strcat("application salt:                ",
          FStar_Bytes_print_bytes(salt1)));
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_asId), (uint32_t)1U);
      TLSInfo_pre_asId *asId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_asId));
      asId[0U] = ((TLSInfo_pre_asId){ ._0 = saltId1 });
      FStar_Bytes_bytes ams = HMAC_hmac(h1, salt1, Hashing_Spec_zeroHash(h1));
      Old_KeySchedule_print(Prims_strcat("application secret:              ",
          FStar_Bytes_print_bytes(ams)));
      KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
      TLSInfo_pre_keyId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
      buf[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = c_expandId });
      TLSInfo_id id1 = { .tag = TLSInfo_ID13, .val = { .case_ID13 = buf } };
      FStar_Bytes_bytes ckv = ck;
      FStar_Bytes_bytes civ1 = civ;
      FStar_Bytes_bytes skv = sk;
      FStar_Bytes_bytes siv1 = siv;
      StAE_state w = StAE_coerce(id1, FStar_Bytes_append(ckv, civ1));
      StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(skv, siv1));
      StAE_state r = StAE_genReader(id1, rw);
      st[0U] =
        (
          (Old_KeySchedule_ks_state){
            .tag = Old_KeySchedule_C,
            .val = {
              .case_C = {
                .tag = Old_KeySchedule_C_13_wait_SF,
                .val = {
                  .case_C_13_wait_SF = {
                    .alpha = { .fst = ae, .snd = h1 },
                    ._1 = { .fst = cfkId, .snd = cfk11 },
                    ._2 = { .fst = sfkId, .snd = sfk11 },
                    ._3 = { .fst = asId, .snd = ams }
                  }
                }
              }
            }
          }
        );
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes cts1;
      if (cpn.tag == FStar_Pervasives_Native_None)
        cts1 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (cpn.tag == FStar_Pervasives_Native_Some)
      {
        FStar_Bytes_bytes pn = cpn.v;
        cts1 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = pn, .snd = cts }
            }
          );
      }
      else
        cts1 =
          KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
      FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes sts1;
      if (spn.tag == FStar_Pervasives_Native_None)
        sts1 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_None
            }
          );
      else if (spn.tag == FStar_Pervasives_Native_Some)
      {
        FStar_Bytes_bytes pn = spn.v;
        sts1 =
          (
            (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = pn, .snd = sts }
            }
          );
      }
      else
        sts1 =
          KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
      return
        (
          (Old_KeySchedule_recordInstance){
            .id = id1,
            .r = r,
            .w = w,
            ._3 = { .fst = cts1, .snd = sts1 }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static TLSInfo_pre_finishedId
*Prims___proj__Mkdtuple2__item___1__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key(
  Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key pair
)
{
  return pair.fst;
}

static TLSInfo_pre_finishedId
*FStar_Pervasives_dfst__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key(
  Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key t
)
{
  return Prims___proj__Mkdtuple2__item___1__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key(t);
}

typedef struct
K___Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_s
{
  Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key fst;
  Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key snd;
  Old_KeySchedule_recordInstance thd;
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes f3;
}
K___Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes;

static K___Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
Old_KeySchedule_ks_client_13_sf(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_client_13_sf hashed_log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  bool is_quic = ks.is_quic;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if (scrut0.tag == Old_KeySchedule_C && scrut0.val.case_C.tag == Old_KeySchedule_C_13_wait_SF)
  {
    FStar_Bytes_bytes ams = scrut0.val.case_C.val.case_C_13_wait_SF._3.snd;
    TLSInfo_pre_asId *asId = scrut0.val.case_C.val.case_C_13_wait_SF._3.fst;
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
    sfk = scrut0.val.case_C.val.case_C_13_wait_SF._2;
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
    cfk = scrut0.val.case_C.val.case_C_13_wait_SF._1;
    K___EverCrypt_aead_alg_Spec_Hash_Definitions_hash_alg
    alpha = scrut0.val.case_C.val.case_C_13_wait_SF.alpha;
    EverCrypt_aead_alg ae = alpha.fst;
    Spec_Hash_Definitions_hash_alg h1 = alpha.snd;
    TLSInfo_pre_finishedId
    *scrut0 = FStar_Pervasives_dfst__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key(cfk);
    TLSInfo_logInfo li = scrut0->li;
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
    TLSInfo_pre_secretId *secretId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
    secretId[0U]
    =
      (
        (TLSInfo_pre_secretId){
          .tag = TLSInfo_ApplicationSecretID,
          .val = { .case_ApplicationSecretID = asId }
        }
      );
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf0 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf0[0U] = TLSInfo_ClientApplicationTrafficSecret;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *c_expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    c_expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = secretId, ._1 = buf0, ._2 = log2 });
    FStar_Bytes_bytes cts = HKDF_derive_secret(h1, ams, "c ap traffic", log2);
    Old_KeySchedule_print(Prims_strcat("application traffic secret[C]:   ",
        FStar_Bytes_print_bytes(cts)));
    FStar_Bytes_bytes sts = HKDF_derive_secret(h1, ams, "s ap traffic", log2);
    Old_KeySchedule_print(Prims_strcat("application traffic secret[S]:   ",
        FStar_Bytes_print_bytes(sts)));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_exportId), (uint32_t)1U);
    TLSInfo_pre_exportId *emsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_exportId));
    emsId[0U]
    =
      (
        (TLSInfo_pre_exportId){
          .tag = TLSInfo_ExportID,
          .val = { .case_ExportID = { ._0 = asId, ._1 = log2 } }
        }
      );
    FStar_Bytes_bytes ems = HKDF_derive_secret(h1, ams, "exp master", log2);
    Old_KeySchedule_print(Prims_strcat("exporter master secret:          ",
        FStar_Bytes_print_bytes(ems)));
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    exporter1 = { ._1 = li, ._2 = emsId, ._3 = ems };
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut1 = Old_KeySchedule_keygen_13(h1, cts, ae, is_quic);
    FStar_Bytes_bytes ck = scrut1.fst;
    FStar_Bytes_bytes civ = scrut1.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes cpn = scrut1.thd;
    Old_KeySchedule_print(Prims_strcat("application key[C]:              ",
        Prims_strcat(FStar_Bytes_print_bytes(ck),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(civ)))));
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut = Old_KeySchedule_keygen_13(h1, sts, ae, is_quic);
    FStar_Bytes_bytes sk = scrut.fst;
    FStar_Bytes_bytes siv = scrut.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes spn = scrut.thd;
    Old_KeySchedule_print(Prims_strcat("application key[S]:              ",
        Prims_strcat(FStar_Bytes_print_bytes(sk),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(siv)))));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
    TLSInfo_pre_keyId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
    buf[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = c_expandId });
    TLSInfo_id id1 = { .tag = TLSInfo_ID13, .val = { .case_ID13 = buf } };
    FStar_Bytes_bytes ckv = ck;
    FStar_Bytes_bytes civ1 = civ;
    StAE_state w = StAE_coerce(id1, FStar_Bytes_append(ckv, civ1));
    FStar_Bytes_bytes skv = sk;
    FStar_Bytes_bytes siv1 = siv;
    StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(skv, siv1));
    StAE_state r = StAE_genReader(id1, rw);
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_C,
          .val = {
            .case_C = {
              .tag = Old_KeySchedule_C_13_wait_CF,
              .val = {
                .case_C_13_wait_CF = {
                  .alpha = alpha,
                  ._1 = cfk,
                  ._2 = { .fst = asId, .snd = ams },
                  ._3 = { ._1 = li, ._2 = c_expandId, ._3 = { .fst = cts, .snd = sts } }
                }
              }
            }
          }
        }
      );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes cts1;
    if (cpn.tag == FStar_Pervasives_Native_None)
      cts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (cpn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn = cpn.v;
      cts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn, .snd = cts }
          }
        );
    }
    else
      cts1 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes sts1;
    if (spn.tag == FStar_Pervasives_Native_None)
      sts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (spn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn = spn.v;
      sts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn, .snd = sts }
          }
        );
    }
    else
      sts1 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    return
      (
        (K___Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes){
          .fst = sfk,
          .snd = cfk,
          .thd = { .id = id1, .r = r, .w = w, ._3 = { .fst = cts1, .snd = sts1 } },
          .f3 = exporter1
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_s
{
  Old_KeySchedule_recordInstance fst;
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes snd;
}
K___Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes;

static K___Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
Old_KeySchedule_ks_server_13_sf(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_server_13_sf hashed_log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  bool is_quic = ks.is_quic;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  if (scrut0.tag == Old_KeySchedule_S && scrut0.val.case_S.tag == Old_KeySchedule_S_13_wait_SF)
  {
    FStar_Bytes_bytes ams = scrut0.val.case_S.val.case_S_13_wait_SF._3.snd;
    TLSInfo_pre_asId *asId = scrut0.val.case_S.val.case_S_13_wait_SF._3.fst;
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
    cfk = scrut0.val.case_S.val.case_S_13_wait_SF._1;
    K___EverCrypt_aead_alg_Spec_Hash_Definitions_hash_alg
    alpha = scrut0.val.case_S.val.case_S_13_wait_SF.alpha;
    TLSInfo_pre_finishedId
    *scrut0 = FStar_Pervasives_dfst__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key(cfk);
    TLSInfo_logInfo li = scrut0->li;
    EverCrypt_aead_alg ae = alpha.fst;
    Spec_Hash_Definitions_hash_alg h1 = alpha.snd;
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_secretId), (uint32_t)1U);
    TLSInfo_pre_secretId *secretId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_secretId));
    secretId[0U]
    =
      (
        (TLSInfo_pre_secretId){
          .tag = TLSInfo_ApplicationSecretID,
          .val = { .case_ApplicationSecretID = asId }
        }
      );
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf0 = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf0[0U] = TLSInfo_ClientApplicationTrafficSecret;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *c_expandId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    c_expandId[0U] = ((TLSInfo_pre_expandId){ ._0 = secretId, ._1 = buf0, ._2 = log2 });
    FStar_Bytes_bytes cts = HKDF_derive_secret(h1, ams, "c ap traffic", log2);
    Old_KeySchedule_print(Prims_strcat("application traffic secret[C]:   ",
        FStar_Bytes_print_bytes(cts)));
    FStar_Bytes_bytes sts = HKDF_derive_secret(h1, ams, "s ap traffic", log2);
    Old_KeySchedule_print(Prims_strcat("application traffic secret[S]:   ",
        FStar_Bytes_print_bytes(sts)));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_exportId), (uint32_t)1U);
    TLSInfo_pre_exportId *emsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_exportId));
    emsId[0U]
    =
      (
        (TLSInfo_pre_exportId){
          .tag = TLSInfo_ExportID,
          .val = { .case_ExportID = { ._0 = asId, ._1 = log2 } }
        }
      );
    FStar_Bytes_bytes ems = HKDF_derive_secret(h1, ams, "exp master", log2);
    Old_KeySchedule_print(Prims_strcat("exporter master secret:          ",
        FStar_Bytes_print_bytes(ems)));
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    exporter1 = { ._1 = li, ._2 = emsId, ._3 = ems };
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut1 = Old_KeySchedule_keygen_13(h1, cts, ae, is_quic);
    FStar_Bytes_bytes ck = scrut1.fst;
    FStar_Bytes_bytes civ = scrut1.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes cpn = scrut1.thd;
    Old_KeySchedule_print(Prims_strcat("application key[C]:              ",
        Prims_strcat(FStar_Bytes_print_bytes(ck),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(civ)))));
    K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__FStar_Bytes_bytes
    scrut = Old_KeySchedule_keygen_13(h1, sts, ae, is_quic);
    FStar_Bytes_bytes sk = scrut.fst;
    FStar_Bytes_bytes siv = scrut.snd;
    FStar_Pervasives_Native_option__FStar_Bytes_bytes spn = scrut.thd;
    Old_KeySchedule_print(Prims_strcat("application key[S]:              ",
        Prims_strcat(FStar_Bytes_print_bytes(sk),
          Prims_strcat(", IV=", FStar_Bytes_print_bytes(siv)))));
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
    TLSInfo_pre_keyId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
    buf[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = c_expandId });
    TLSInfo_id id1 = { .tag = TLSInfo_ID13, .val = { .case_ID13 = buf } };
    FStar_Bytes_bytes skv = sk;
    FStar_Bytes_bytes siv1 = siv;
    StAE_state w = StAE_coerce(id1, FStar_Bytes_append(skv, siv1));
    FStar_Bytes_bytes ckv = ck;
    FStar_Bytes_bytes civ1 = civ;
    StAE_state rw = StAE_coerce(id1, FStar_Bytes_append(ckv, civ1));
    StAE_state r = StAE_genReader(id1, rw);
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_S,
          .val = {
            .case_S = {
              .tag = Old_KeySchedule_S_13_wait_CF,
              .val = {
                .case_S_13_wait_CF = {
                  .alpha = alpha,
                  ._1 = cfk,
                  ._2 = { .fst = asId, .snd = ams },
                  ._3 = { ._1 = li, ._2 = c_expandId, ._3 = { .fst = cts, .snd = sts } }
                }
              }
            }
          }
        }
      );
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes cts1;
    if (cpn.tag == FStar_Pervasives_Native_None)
      cts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (cpn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn = cpn.v;
      cts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn, .snd = cts }
          }
        );
    }
    else
      cts1 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes sts1;
    if (spn.tag == FStar_Pervasives_Native_None)
      sts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_None
          }
        );
    else if (spn.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes pn = spn.v;
      sts1 =
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .fst = pn, .snd = sts }
          }
        );
    }
    else
      sts1 =
        KRML_EABORT(FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes,
          "unreachable (pattern matches are exhaustive in F*)");
    return
      (
        (K___Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes){
          .fst = { .id = id1, .r = r, .w = w, ._3 = { .fst = cts1, .snd = sts1 } },
          .snd = exporter1
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static void Old_KeySchedule_ks_server_13_cf(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_server_13_cf hashed_log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_13_wait_CF)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    rekey_info = scrut.val.case_S.val.case_S_13_wait_CF._3;
    FStar_Bytes_bytes ams = scrut.val.case_S.val.case_S_13_wait_CF._2.snd;
    TLSInfo_pre_asId *asId = scrut.val.case_S.val.case_S_13_wait_CF._2.fst;
    K___EverCrypt_aead_alg_Spec_Hash_Definitions_hash_alg
    alpha = scrut.val.case_S.val.case_S_13_wait_CF.alpha;
    Spec_Hash_Definitions_hash_alg h1 = alpha.snd;
    TLSInfo_logInfo li = rekey_info._1;
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_rmsId), (uint32_t)1U);
    TLSInfo_pre_rmsId *rmsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_rmsId));
    rmsId[0U] = ((TLSInfo_pre_rmsId){ ._0 = asId, ._1 = log2 });
    FStar_Bytes_bytes rms = HKDF_derive_secret(h1, ams, "res master", log2);
    Old_KeySchedule_print(Prims_strcat("resumption master secret:        ",
        FStar_Bytes_print_bytes(rms)));
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_S,
          .val = {
            .case_S = {
              .tag = Old_KeySchedule_S_13_postHS,
              .val = {
                .case_S_13_postHS = {
                  .alpha = alpha,
                  ._1 = rekey_info,
                  ._2 = { ._1 = li, ._2 = rmsId, ._3 = rms }
                }
              }
            }
          }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_rmsId_FStar_Bytes_bytes
Old_KeySchedule_ks_server_13_rms(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_13_postHS)
    return scrut.val.case_S.val.case_S_13_postHS._2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static void Old_KeySchedule_ks_client_13_cf(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_client_13_cf hashed_log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_wait_CF)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    rekey_info = scrut.val.case_C.val.case_C_13_wait_CF._3;
    FStar_Bytes_bytes ams = scrut.val.case_C.val.case_C_13_wait_CF._2.snd;
    TLSInfo_pre_asId *asId = scrut.val.case_C.val.case_C_13_wait_CF._2.fst;
    K___EverCrypt_aead_alg_Spec_Hash_Definitions_hash_alg
    alpha = scrut.val.case_C.val.case_C_13_wait_CF.alpha;
    Spec_Hash_Definitions_hash_alg h1 = alpha.snd;
    TLSInfo_logInfo li = rekey_info._1;
    FStar_Bytes_bytes log2 = log1;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_rmsId), (uint32_t)1U);
    TLSInfo_pre_rmsId *rmsId = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_rmsId));
    rmsId[0U] = ((TLSInfo_pre_rmsId){ ._0 = asId, ._1 = log2 });
    FStar_Bytes_bytes rms = HKDF_derive_secret(h1, ams, "res master", log2);
    Old_KeySchedule_print(Prims_strcat("resumption master secret:        ",
        FStar_Bytes_print_bytes(rms)));
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_C,
          .val = {
            .case_C = {
              .tag = Old_KeySchedule_C_13_postHS,
              .val = {
                .case_C_13_postHS = {
                  .alpha = alpha,
                  ._1 = rekey_info,
                  ._2 = { ._1 = li, ._2 = rmsId, ._3 = rms }
                }
              }
            }
          }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes
Old_KeySchedule_ks_client_13_rms_psk(Old_KeySchedule_ks ks, FStar_Bytes_bytes nonce)
{
  Old_KeySchedule_print("ks_client_13_rms");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_postHS)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_rmsId_FStar_Bytes_bytes
    rmsi = scrut.val.case_C.val.case_C_13_postHS._2;
    TLSInfo_logInfo li = rmsi._1;
    TLSInfo_pre_rmsId *rmsId = rmsi._2;
    FStar_Bytes_bytes rms = rmsi._3;
    Old_KeySchedule_print(Prims_strcat("Recall RMS: ", FStar_Bytes_hex_of_bytes(rms)));
    return HKDF_derive_secret(TLSInfo_rmsId_hash(li, rmsId), rms, "resumption", nonce);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
  v;
}
FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes;

static FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets
Old_KeySchedule_ks_13_rekey_secrets(Old_KeySchedule_ks ks)
{
  Old_KeySchedule_print("ks_13_get_rekey");
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
  ori;
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_postHS)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    ri = scrut.val.case_C.val.case_C_13_postHS._1;
    ori =
      (
        (FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = ri
        }
      );
  }
  else if
  (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_13_wait_CF)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    ri = scrut.val.case_C.val.case_C_13_wait_CF._3;
    ori =
      (
        (FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = ri
        }
      );
  }
  else if (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_13_postHS)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    ri = scrut.val.case_S.val.case_S_13_postHS._1;
    ori =
      (
        (FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = ri
        }
      );
  }
  else if
  (scrut.tag == Old_KeySchedule_S && scrut.val.case_S.tag == Old_KeySchedule_S_13_wait_CF)
  {
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes
    ri = scrut.val.case_S.val.case_S_13_wait_CF._3;
    ori =
      (
        (FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = ri
        }
      );
  }
  else
    ori =
      (
        (FStar_Pervasives_Native_option__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_expandId_K___FStar_Bytes_bytes_FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_None
        }
      );
  if (ori.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (ori.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes srs = ori.v._3.snd;
    FStar_Bytes_bytes crs = ori.v._3.fst;
    TLSInfo_logInfo li = ori.v._1;
    return
      (
        (FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .rekey_aead = TLSInfo_logInfo_ae(li),
            .rekey_hash = TLSInfo_logInfo_hash(li),
            .rekey_client = crs,
            .rekey_server = srs
          }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static CommonDH_group_
Prims___proj__Mkdtuple2__item___1__CommonDH_group__CommonDH_pre_share_(
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ pair
)
{
  return pair.fst;
}

static CommonDH_group_
FStar_Pervasives_dfst__CommonDH_group__CommonDH_pre_share_(
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ t
)
{
  return Prims___proj__Mkdtuple2__item___1__CommonDH_group__CommonDH_pre_share_(t);
}

static CommonDH_pre_share_
Old_KeySchedule_ks_client_12_full_dh(
  Old_KeySchedule_ks ks,
  FStar_Bytes_bytes sr,
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_cipherSuite_ cs,
  bool ems,
  Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ uu____16534
)
{
  CommonDH_group_ g1 = uu____16534.fst;
  CommonDH_pre_share_ gx = uu____16534.snd;
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut0 = st[0U];
  FStar_Bytes_bytes cr;
  if (scrut0.tag == Old_KeySchedule_C && scrut0.val.case_C.tag == Old_KeySchedule_C_12_Full_CH)
    cr = scrut0.val.case_C.val.case_C_12_Full_CH;
  else if
  (scrut0.tag == Old_KeySchedule_C && scrut0.val.case_C.tag == Old_KeySchedule_C_12_Resume_CH)
    cr = scrut0.val.case_C.val.case_C_12_Resume_CH.cr;
  else if
  (scrut0.tag == Old_KeySchedule_C && scrut0.val.case_C.tag == Old_KeySchedule_C_13_wait_SH)
    cr = scrut0.val.case_C.val.case_C_13_wait_SH.cr;
  else
    cr = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  FStar_Bytes_bytes csr = FStar_Bytes_append(cr, sr);
  K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool
  alpha = { .fst = pv, .snd = cs, .thd = ems };
  K___CommonDH_pre_share__FStar_Bytes_bytes scrut = CommonDH_dh_responder(g1, gx);
  CommonDH_pre_share_ gy = scrut.fst;
  FStar_Bytes_bytes pmsb = scrut.snd;
  Old_KeySchedule_print_share(g1, gx);
  Old_KeySchedule_print_share(FStar_Pervasives_dfst__CommonDH_group__CommonDH_pre_share_((
        (Prims_dtuple2__CommonDH_group__CommonDH_pre_share_){ .fst = g1, .snd = gx }
      )),
    gy);
  Old_KeySchedule_print(Prims_strcat("PMS: ", FStar_Bytes_print_bytes(pmsb)));
  PMS_pms
  dhpmsId =
    {
      .tag = PMS_DHPMS,
      .val = {
        .case_DHPMS = {
          .g = g1,
          .gx = gx,
          ._2 = gy,
          ._3 = { .tag = PMS_ConcreteDHPMS, .val = { .case_ConcreteDHPMS = pmsb } }
        }
      }
    };
  Old_KeySchedule_ks_client_state ns;
  if (ems)
    ns =
      (
        (Old_KeySchedule_ks_client_state){
          .tag = Old_KeySchedule_C_12_wait_MS,
          .val = { .case_C_12_wait_MS = { .csr = csr, .alpha = alpha, .id = dhpmsId, .pms = pmsb } }
        }
      );
  else
  {
    TLSConstants_prePrfAlg kef = TLSInfo_kefAlg(pv, cs, false);
    FStar_Bytes_bytes ms = TLSPRF_extract(kef, pmsb, csr, (uint32_t)48U);
    Old_KeySchedule_print(Prims_strcat("master secret: ", FStar_Bytes_print_bytes(ms)));
    TLSInfo_msId
    msId =
      {
        .tag = TLSInfo_StandardMS,
        .val = { .case_StandardMS = { ._0 = dhpmsId, ._1 = csr, ._2 = kef } }
      };
    ns =
      (
        (Old_KeySchedule_ks_client_state){
          .tag = Old_KeySchedule_C_12_has_MS,
          .val = { .case_C_12_has_MS = { .csr = csr, .alpha = alpha, .id = msId, .ms = ms } }
        }
      );
  }
  st[0U] = ((Old_KeySchedule_ks_state){ .tag = Old_KeySchedule_C, .val = { .case_C = ns } });
  return gy;
}

typedef struct K___FStar_Bytes_bytes_Old_KeySchedule_recordInstance_s
{
  FStar_Bytes_bytes fst;
  Old_KeySchedule_recordInstance snd;
}
K___FStar_Bytes_bytes_Old_KeySchedule_recordInstance;

static K___FStar_Bytes_bytes_Old_KeySchedule_recordInstance
Old_KeySchedule_ks_client_12_set_session_hash(Old_KeySchedule_ks ks, FStar_Bytes_bytes log1)
{
  Old_KeySchedule_print(Prims_strcat("ks_client_12_set_session_hash hashed_log = ",
      FStar_Bytes_print_bytes(log1)));
  Old_KeySchedule_ks_state *st = ks.state;
  Old_KeySchedule_ks_state scrut = st[0U];
  FStar_Bytes_bytes ms0;
  if (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_12_has_MS)
  {
    FStar_Bytes_bytes ms = scrut.val.case_C.val.case_C_12_has_MS.ms;
    Old_KeySchedule_print(Prims_strcat("master secret:", FStar_Bytes_print_bytes(ms)));
    ms0 = ms;
  }
  else if
  (scrut.tag == Old_KeySchedule_C && scrut.val.case_C.tag == Old_KeySchedule_C_12_wait_MS)
  {
    FStar_Bytes_bytes pms = scrut.val.case_C.val.case_C_12_wait_MS.pms;
    PMS_pms pmsId = scrut.val.case_C.val.case_C_12_wait_MS.id;
    K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool
    alpha = scrut.val.case_C.val.case_C_12_wait_MS.alpha;
    FStar_Bytes_bytes csr = scrut.val.case_C.val.case_C_12_wait_MS.csr;
    Parsers_ProtocolVersion_protocolVersion pv = alpha.fst;
    CipherSuite_cipherSuite_ cs = alpha.snd;
    bool ems = alpha.thd;
    TLSConstants_prePrfAlg kef = TLSInfo_kefAlg(pv, cs, ems);
    Spec_Hash_Definitions_hash_alg h1 = TLSConstants_verifyDataHashAlg_of_ciphersuite(cs);
    K___TLSInfo_msId_FStar_Bytes_bytes scrut;
    if (ems)
    {
      FStar_Bytes_bytes
      ms =
        TLSPRF_prf((
            (K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite_){
              .fst = pv,
              .snd = cs
            }
          ),
          pms,
          FStar_Bytes_utf8_encode("extended master secret"),
          log1,
          (uint32_t)48U);
      Old_KeySchedule_print(Prims_strcat("extended master secret:", FStar_Bytes_print_bytes(ms)));
      TLSInfo_msId
      msId =
        {
          .tag = TLSInfo_ExtendedMS,
          .val = { .case_ExtendedMS = { ._0 = pmsId, ._1 = log1, ._2 = kef } }
        };
      scrut = ((K___TLSInfo_msId_FStar_Bytes_bytes){ .fst = msId, .snd = ms });
    }
    else
    {
      FStar_Bytes_bytes ms = TLSPRF_extract(kef, pms, csr, (uint32_t)48U);
      Old_KeySchedule_print(Prims_strcat("master secret:", FStar_Bytes_print_bytes(ms)));
      TLSInfo_msId
      msId =
        {
          .tag = TLSInfo_StandardMS,
          .val = { .case_StandardMS = { ._0 = pmsId, ._1 = csr, ._2 = kef } }
        };
      scrut = ((K___TLSInfo_msId_FStar_Bytes_bytes){ .fst = msId, .snd = ms });
    }
    TLSInfo_msId msId = scrut.fst;
    FStar_Bytes_bytes ms = scrut.snd;
    st[0U] =
      (
        (Old_KeySchedule_ks_state){
          .tag = Old_KeySchedule_C,
          .val = {
            .case_C = {
              .tag = Old_KeySchedule_C_12_has_MS,
              .val = { .case_C_12_has_MS = { .csr = csr, .alpha = alpha, .id = msId, .ms = ms } }
            }
          }
        }
      );
    ms0 = ms;
  }
  else
    ms0 = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  Old_KeySchedule_recordInstance appk = Old_KeySchedule_ks_12_record_key(ks);
  return
    (
      (K___FStar_Bytes_bytes_Old_KeySchedule_recordInstance){
        .fst = TLSPRF_coerce(ms0),
        .snd = appk
      }
    );
}

static void Old_Epochs_discard(bool uu____23)
{
  
}

static void Old_Epochs_print(Prims_string s)
{
  Old_Epochs_discard(FStar_IO_debug_print_string(Prims_strcat("EPO| ", Prims_strcat(s, "\n"))));
}

TLSInfo_id Old_Epochs_epoch_id(FStar_Bytes_bytes n1, Old_Epochs_epoch e)
{
  return e.i;
}

StAE_state Old_Epochs_writer_epoch(FStar_Bytes_bytes n1, Old_Epochs_epoch e)
{
  return e.w;
}

StAE_state Old_Epochs_reader_epoch(FStar_Bytes_bytes n1, Old_Epochs_epoch e)
{
  return e.r;
}

K___FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes
Old_Epochs_pn_epoch(FStar_Bytes_bytes n1, Old_Epochs_epoch e)
{
  return e._4;
}

typedef Prims_list__Old_Epochs_epoch *FStar_Seq_Base_seq__Old_Epochs_epoch;

typedef Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Seq_Base_seq__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes;

static Prims_list__Old_Epochs_epoch *FStar_Seq_Base_empty__Old_Epochs_epoch()
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Old_Epochs_epoch), (uint32_t)1U);
  Prims_list__Old_Epochs_epoch *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_Epochs_epoch));
  buf[0U] = ((Prims_list__Old_Epochs_epoch){ .tag = Prims_Nil });
  return buf;
}

static Prims_list__Old_Epochs_epoch
**FStar_Monotonic_Seq_alloc_mref_iseq__Old_Epochs_epoch___(Prims_list__Old_Epochs_epoch *init1)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Old_Epochs_epoch *), (uint32_t)1U);
  Prims_list__Old_Epochs_epoch **buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_Epochs_epoch *));
  buf[0U] = init1;
  return buf;
}

typedef struct
FStar_Pervasives_dtuple3___FStar_Seq_Base_seq__Old_Epochs_epoch___Prims_int___Prims_int__s
{
  Prims_list__Old_Epochs_epoch **_1;
  Prims_int *_2;
  Prims_int *_3;
}
FStar_Pervasives_dtuple3___FStar_Seq_Base_seq__Old_Epochs_epoch___Prims_int___Prims_int_;

static FStar_Pervasives_dtuple3___FStar_Seq_Base_seq__Old_Epochs_epoch___Prims_int___Prims_int_
Old_Epochs_alloc_log_and_ctrs__Old_Epochs_epoch___()
{
  Prims_list__Old_Epochs_epoch *init1 = FStar_Seq_Base_empty__Old_Epochs_epoch();
  Prims_list__Old_Epochs_epoch
  **is = FStar_Monotonic_Seq_alloc_mref_iseq__Old_Epochs_epoch___(init1);
  KRML_CHECK_SIZE(sizeof (Prims_int), (uint32_t)1U);
  Prims_int *c11 = KRML_HOST_MALLOC(sizeof (Prims_int));
  c11[0U] = (krml_checked_int_t)-1;
  KRML_CHECK_SIZE(sizeof (Prims_int), (uint32_t)1U);
  Prims_int *c21 = KRML_HOST_MALLOC(sizeof (Prims_int));
  c21[0U] = (krml_checked_int_t)-1;
  return
    (
      (FStar_Pervasives_dtuple3___FStar_Seq_Base_seq__Old_Epochs_epoch___Prims_int___Prims_int_){
        ._1 = is,
        ._2 = c11,
        ._3 = c21
      }
    );
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
**FStar_Monotonic_Seq_alloc_mref_iseq__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes___(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *init1
)
{
  KRML_CHECK_SIZE(sizeof (
      Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *
    ),
    (uint32_t)1U);
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  **buf =
    KRML_HOST_MALLOC(sizeof (
        Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *
      ));
  buf[0U] = init1;
  return buf;
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Seq_Base_empty__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  
)
{
  KRML_CHECK_SIZE(sizeof (
      Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    ),
    (uint32_t)1U);
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *buf =
    KRML_HOST_MALLOC(sizeof (
        Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
      ));
  buf[0U]
  =
    (
      (Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes){
        .tag = Prims_Nil
      }
    );
  return buf;
}

static Old_Epochs_epochs Old_Epochs_create(FStar_Bytes_bytes n1)
{
  FStar_Pervasives_dtuple3___FStar_Seq_Base_seq__Old_Epochs_epoch___Prims_int___Prims_int_
  scrut = Old_Epochs_alloc_log_and_ctrs__Old_Epochs_epoch___();
  Prims_list__Old_Epochs_epoch **esref = scrut._1;
  Prims_int *c11 = scrut._2;
  Prims_int *c21 = scrut._3;
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  **xkr =
    FStar_Monotonic_Seq_alloc_mref_iseq__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes___(FStar_Seq_Base_empty__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes());
  return ((Old_Epochs_epochs){ .es = esref, .read = c11, .write = c21, .exporter = xkr });
}

static Prims_int
FStar_List_Tot_Base_length__Old_Epochs_epoch(Prims_list__Old_Epochs_epoch *uu___4_154)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__Old_Epochs_epoch *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__Old_Epochs_epoch(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_int FStar_Seq_Base_length__Old_Epochs_epoch(Prims_list__Old_Epochs_epoch *s)
{
  return FStar_List_Tot_Base_length__Old_Epochs_epoch(s);
}

static Prims_list__Old_Epochs_epoch
*FStar_List_Tot_Base_append__Old_Epochs_epoch(
  Prims_list__Old_Epochs_epoch *x,
  Prims_list__Old_Epochs_epoch *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Old_Epochs_epoch *tl1 = x->tl;
    Old_Epochs_epoch a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__Old_Epochs_epoch), (uint32_t)1U);
    Prims_list__Old_Epochs_epoch *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_Epochs_epoch));
    buf[0U]
    =
      (
        (Prims_list__Old_Epochs_epoch){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__Old_Epochs_epoch(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Old_Epochs_epoch
*FStar_Seq_Base_append__Old_Epochs_epoch(
  Prims_list__Old_Epochs_epoch *s1,
  Prims_list__Old_Epochs_epoch *s2
)
{
  return FStar_List_Tot_Base_append__Old_Epochs_epoch(s1, s2);
}

static Prims_list__Old_Epochs_epoch
*FStar_Seq_Base_cons__Old_Epochs_epoch(Old_Epochs_epoch x, Prims_list__Old_Epochs_epoch *s)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__Old_Epochs_epoch), (uint32_t)1U);
  Prims_list__Old_Epochs_epoch *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_Epochs_epoch));
  buf[0U] = ((Prims_list__Old_Epochs_epoch){ .tag = Prims_Cons, .hd = x, .tl = s });
  return buf;
}

static Prims_list__Old_Epochs_epoch
*FStar_Seq_Base_create__Old_Epochs_epoch(Prims_int len, Old_Epochs_epoch v)
{
  if (len == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Old_Epochs_epoch), (uint32_t)1U);
    Prims_list__Old_Epochs_epoch *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Old_Epochs_epoch));
    buf[0U] = ((Prims_list__Old_Epochs_epoch){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__Old_Epochs_epoch(v,
        FStar_Seq_Base_create__Old_Epochs_epoch(Prims_op_Subtraction(len, (krml_checked_int_t)1), v));
}

static Prims_list__Old_Epochs_epoch
*FStar_Seq_Properties_snoc__Old_Epochs_epoch(
  Prims_list__Old_Epochs_epoch *s,
  Old_Epochs_epoch x
)
{
  return
    FStar_Seq_Base_append__Old_Epochs_epoch(s,
      FStar_Seq_Base_create__Old_Epochs_epoch((krml_checked_int_t)1, x));
}

static void
FStar_Monotonic_Seq_i_write_at_end__Old_Epochs_epoch___(
  Prims_list__Old_Epochs_epoch **r,
  Old_Epochs_epoch x
)
{
  Prims_list__Old_Epochs_epoch *s0 = r[0U];
  Prims_int n = FStar_Seq_Base_length__Old_Epochs_epoch(s0);
  r[0U] = FStar_Seq_Properties_snoc__Old_Epochs_epoch(s0, x);
}

static void
Old_Epochs_add_epoch(FStar_Bytes_bytes n1, Old_Epochs_epochs uu____54450, Old_Epochs_epoch e)
{
  Prims_list__Old_Epochs_epoch **es = uu____54450.es;
  FStar_Monotonic_Seq_i_write_at_end__Old_Epochs_epoch___(es, e);
}

Prims_list__Old_Epochs_epoch
**Old_Epochs_get_epochs(FStar_Bytes_bytes n1, Old_Epochs_epochs es)
{
  return es.es;
}

static Prims_int *Old_Epochs_ctr(FStar_Bytes_bytes n1, Old_Epochs_epochs e, TLSConstants_rw rw)
{
  switch (rw)
  {
    case TLSConstants_Reader:
      {
        return e.read;
      }
    case TLSConstants_Writer:
      {
        return e.write;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static Prims_string Old_Epochs_string_of_es(FStar_Bytes_bytes n1, Old_Epochs_epochs es)
{
  Prims_int r1 = Old_Epochs_ctr(n1, es, TLSConstants_Reader)[0U];
  Prims_int w = Old_Epochs_ctr(n1, es, TLSConstants_Writer)[0U];
  return Prims_strcat(Prims_string_of_int(r1), Prims_strcat("/", Prims_string_of_int(w)));
}

static void
Old_Epochs_incr_epoch_ctr__Old_Epochs_epoch___(
  Prims_list__Old_Epochs_epoch **is,
  Prims_int *ctr1
)
{
  Prims_int cur = ctr1[0U];
  ctr1[0U] = Prims_op_Addition(cur, (krml_checked_int_t)1);
}

static void Old_Epochs_incr_reader(FStar_Bytes_bytes n1, Old_Epochs_epochs es)
{
  Old_Epochs_incr_epoch_ctr__Old_Epochs_epoch___(es.es, es.read);
  Old_Epochs_print(Prims_strcat("reader++ ", Old_Epochs_string_of_es(n1, es)));
}

void Old_Epochs_incr_writer(FStar_Bytes_bytes n1, Old_Epochs_epochs es)
{
  Old_Epochs_incr_epoch_ctr__Old_Epochs_epoch___(es.es, es.write);
  Old_Epochs_print(Prims_strcat("writer++ ", Old_Epochs_string_of_es(n1, es)));
}

static Prims_int
Old_Epochs_get_ctr(FStar_Bytes_bytes n1, Old_Epochs_epochs es, TLSConstants_rw rw)
{
  Prims_int n2 = Old_Epochs_ctr(n1, es, rw)[0U];
  return n2;
}

static Prims_int Old_Epochs_get_reader(FStar_Bytes_bytes n1, Old_Epochs_epochs es)
{
  return Old_Epochs_get_ctr(n1, es, TLSConstants_Reader);
}

static Prims_int Old_Epochs_get_writer(FStar_Bytes_bytes n1, Old_Epochs_epochs es)
{
  return Old_Epochs_get_ctr(n1, es, TLSConstants_Writer);
}

Prims_list__Old_Epochs_epoch
*FStar_Monotonic_Seq_i_read__Old_Epochs_epoch___(Prims_list__Old_Epochs_epoch **m)
{
  return m[0U];
}

static Old_Epochs_epoch
FStar_List_Tot_Base_hd__Old_Epochs_epoch(Prims_list__Old_Epochs_epoch *uu___0_39)
{
  if (uu___0_39->tag == Prims_Cons)
    return uu___0_39->hd;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Old_Epochs_epoch
*FStar_List_Tot_Base_tail__Old_Epochs_epoch(Prims_list__Old_Epochs_epoch *uu___1_64)
{
  if (uu___1_64->tag == Prims_Cons)
    return uu___1_64->tl;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__Old_Epochs_epoch
*(*FStar_List_Tot_Base_tl__Old_Epochs_epoch)(Prims_list__Old_Epochs_epoch *x0) =
  FStar_List_Tot_Base_tail__Old_Epochs_epoch;

static Old_Epochs_epoch
FStar_List_Tot_Base_index__Old_Epochs_epoch(Prims_list__Old_Epochs_epoch *l, Prims_int i)
{
  if (i == (krml_checked_int_t)0)
    return FStar_List_Tot_Base_hd__Old_Epochs_epoch(l);
  else
    return
      FStar_List_Tot_Base_index__Old_Epochs_epoch(FStar_List_Tot_Base_tl__Old_Epochs_epoch(l),
        Prims_op_Subtraction(i, (krml_checked_int_t)1));
}

Old_Epochs_epoch
FStar_Seq_Base_index__Old_Epochs_epoch(Prims_list__Old_Epochs_epoch *s, Prims_int i)
{
  return FStar_List_Tot_Base_index__Old_Epochs_epoch(s, i);
}

Old_Epochs_epoch
Old_Epochs_get_current_epoch(FStar_Bytes_bytes n1, Old_Epochs_epochs e, TLSConstants_rw rw)
{
  Prims_int j1 = Old_Epochs_get_ctr(n1, e, rw);
  Prims_list__Old_Epochs_epoch *epochs = FStar_Monotonic_Seq_i_read__Old_Epochs_epoch___(e.es);
  return FStar_Seq_Base_index__Old_Epochs_epoch(epochs, j1);
}

static Old_Epochs_epoch
Old_Epochs_recordInstanceToEpoch(
  FStar_Bytes_bytes n1,
  Negotiation_handshake hs,
  Old_KeySchedule_recordInstance ri
)
{
  TLSInfo_id i1 = ri.id;
  StAE_state rd = ri.r;
  StAE_state wr = ri.w;
  K___FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes
  pn = ri._3;
  return ((Old_Epochs_epoch){ .i = i1, .h = hs, .r = rd, .w = wr, ._4 = pn });
}

static void Old_Handshake_discard(bool uu____17)
{
  
}

static void Old_Handshake_print(Prims_string s)
{
  Old_Handshake_discard(FStar_IO_debug_print_string(Prims_strcat("HS | ", Prims_strcat(s, "\n"))));
}

bool Old_Handshake_uu___is_C_Idle(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Idle)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_C_Wait_ServerHello(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_ServerHello)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_C_Wait_Finished1(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_Finished1)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_C_Sent_EOED(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Sent_EOED)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__C_Sent_EOED__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Sent_EOED)
    return projectee.val.case_C_Sent_EOED._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__HandshakeMessages_cr
Old_Handshake___proj__C_Sent_EOED__item___1(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Sent_EOED)
    return projectee.val.case_C_Sent_EOED._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
Old_Handshake___proj__C_Sent_EOED__item___2(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Sent_EOED)
    return projectee.val.case_C_Sent_EOED._2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_C_Wait_CCS1(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_CCS1)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__C_Wait_CCS1__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_CCS1)
    return projectee.val.case_C_Wait_CCS1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_C_Wait_R_Finished1(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_R_Finished1)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__C_Wait_R_Finished1__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_R_Finished1)
    return projectee.val.case_C_Wait_R_Finished1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_C_Wait_ServerHelloDone(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_ServerHelloDone)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_C_Wait_CCS2(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_CCS2)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__C_Wait_CCS2__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_CCS2)
    return projectee.val.case_C_Wait_CCS2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_C_Wait_Finished2(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_Finished2)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__C_Wait_Finished2__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Wait_Finished2)
    return projectee.val.case_C_Wait_Finished2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_C_Complete(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_C_Complete)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_S_Idle(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Idle)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_S_Sent_ServerHello(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Sent_ServerHello)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_S_Wait_EOED(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_EOED)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_S_Wait_Finished2(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_Finished2)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__S_Wait_Finished2__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_Finished2)
    return projectee.val.case_S_Wait_Finished2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_S_Wait_CCS1(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_CCS1)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_S_Wait_Finished1(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_Finished1)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__S_Wait_Finished1__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_Finished1)
    return projectee.val.case_S_Wait_Finished1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_S_Wait_CCS2(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_CCS2)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__S_Wait_CCS2__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_CCS2)
    return projectee.val.case_S_Wait_CCS2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_S_Wait_CF2(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_CF2)
    return true;
  else
    return false;
}

FStar_Bytes_bytes
Old_Handshake___proj__S_Wait_CF2__item___0(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Wait_CF2)
    return projectee.val.case_S_Wait_CF2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_S_Complete(Old_Handshake_machineState projectee)
{
  if (projectee.tag == Old_Handshake_S_Complete)
    return true;
  else
    return false;
}

bool Old_Handshake_uu___is_HS(Old_Handshake_hs_ projectee)
{
  return true;
}

TLSConstants_role Old_Handshake___proj__HS__item__r(Old_Handshake_hs_ projectee)
{
  return projectee.r;
}

Negotiation_t Old_Handshake___proj__HS__item__nego(Old_Handshake_hs_ projectee)
{
  return projectee.nego;
}

HandshakeLog_state *Old_Handshake___proj__HS__item__log(Old_Handshake_hs_ projectee)
{
  return projectee.log;
}

Old_KeySchedule_ks Old_Handshake___proj__HS__item__ks(Old_Handshake_hs_ projectee)
{
  return projectee.ks;
}

Old_Epochs_epochs Old_Handshake___proj__HS__item__epochs(Old_Handshake_hs_ projectee)
{
  return projectee.epochs;
}

Old_Handshake_machineState *Old_Handshake___proj__HS__item__state(Old_Handshake_hs_ projectee)
{
  return projectee.state;
}

FStar_Bytes_bytes Old_Handshake_nonce(Old_Handshake_hs_ s)
{
  return Negotiation_nonce(s.r, s.nego);
}

TLSConstants_role Old_Handshake_role_of(Old_Handshake_hs_ s)
{
  return s.r;
}

FStar_Bytes_bytes Old_Handshake_random_of(Old_Handshake_hs_ s)
{
  return Old_Handshake_nonce(s);
}

TLSConstants_config Old_Handshake_config_of(Old_Handshake_hs_ s)
{
  return Negotiation_local_config(s.r, s.nego);
}

Parsers_ProtocolVersion_protocolVersion Old_Handshake_version_of(Old_Handshake_hs_ s)
{
  return Negotiation_version(s.r, s.nego);
}

Negotiation_mode Old_Handshake_get_mode(Old_Handshake_hs_ s)
{
  return Negotiation_getMode(s.r, s.nego);
}

bool Old_Handshake_is_server_hrr(Old_Handshake_hs_ s)
{
  return Negotiation_is_server_hrr(s.r, s.nego);
}

bool Old_Handshake_is_0rtt_offered(Old_Handshake_hs_ s)
{
  Negotiation_mode mode = Old_Handshake_get_mode(s);
  return Negotiation_zeroRTToffer(mode.n_offer);
}

bool Old_Handshake_is_post_handshake(Old_Handshake_hs_ s)
{
  Old_Handshake_machineState scrut = s.state[0U];
  if (scrut.tag == Old_Handshake_C_Complete)
    return true;
  else if (scrut.tag == Old_Handshake_S_Complete)
    return true;
  else
    return false;
}

Old_Epochs_epochs Old_Handshake_epochs_of(Old_Handshake_hs_ s)
{
  return s.epochs;
}

Prims_list__Old_Epochs_epoch **Old_Handshake_es_of(Old_Handshake_hs_ s)
{
  FStar_Bytes_bytes x1 = Old_Handshake_random_of(s);
  Old_Epochs_epochs x2 = Old_Handshake_epochs_of(s);
  return x2.es;
}

Prims_int Old_Handshake_i(Old_Handshake_hs_ s, TLSConstants_rw rw)
{
  switch (rw)
  {
    case TLSConstants_Reader:
      {
        return Old_Epochs_get_reader(Old_Handshake_random_of(s), Old_Handshake_epochs_of(s));
      }
    case TLSConstants_Writer:
      {
        return Old_Epochs_get_writer(Old_Handshake_random_of(s), Old_Handshake_epochs_of(s));
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static void Old_Handshake_register(Old_Handshake_hs_ hs, Old_KeySchedule_recordInstance keys)
{
  Negotiation_handshake
  h1 =
    { .tag = Negotiation_Fresh, .val = { .case_Fresh = { .tag = FStar_Pervasives_Native_None } } };
  Old_Epochs_epoch ep = Old_Epochs_recordInstanceToEpoch(Old_Handshake_nonce(hs), h1, keys);
  Old_Epochs_add_epoch(Negotiation_nonce(hs.r, hs.nego), hs.epochs, ep);
}

static Prims_int
FStar_List_Tot_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *uu___4_154
)
{
  if (uu___4_154->tag == Prims_Nil)
    return (krml_checked_int_t)0;
  else if (uu___4_154->tag == Prims_Cons)
  {
    Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    *tl1 = uu___4_154->tl;
    return
      Prims_op_Addition((krml_checked_int_t)1,
        FStar_List_Tot_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(tl1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_int
FStar_Seq_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *s
)
{
  return
    FStar_List_Tot_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(s);
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_List_Tot_Base_append__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *x,
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *y
)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    *tl1 = x->tl;
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes a = x->hd;
    KRML_CHECK_SIZE(sizeof (
        Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
      ),
      (uint32_t)1U);
    Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    *buf =
      KRML_HOST_MALLOC(sizeof (
          Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
        ));
    buf[0U]
    =
      (
        (Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(tl1,
            y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Seq_Base_append__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *s1,
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *s2
)
{
  return
    FStar_List_Tot_Base_append__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(s1,
      s2);
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Seq_Base_cons__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes x,
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *s
)
{
  KRML_CHECK_SIZE(sizeof (
      Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    ),
    (uint32_t)1U);
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *buf =
    KRML_HOST_MALLOC(sizeof (
        Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
      ));
  buf[0U]
  =
    (
      (Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = x,
        .tl = s
      }
    );
  return buf;
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Seq_Base_create__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_int len,
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes v
)
{
  if (len == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (
        Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
      ),
      (uint32_t)1U);
    Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    *buf =
      KRML_HOST_MALLOC(sizeof (
          Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
        ));
    buf[0U]
    =
      (
        (Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes){
          .tag = Prims_Nil
        }
      );
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(v,
        FStar_Seq_Base_create__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(Prims_op_Subtraction(len,
            (krml_checked_int_t)1),
          v));
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Seq_Properties_snoc__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes *s,
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes x
)
{
  return
    FStar_Seq_Base_append__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(s,
      FStar_Seq_Base_create__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes((krml_checked_int_t)1,
        x));
}

static void
FStar_Monotonic_Seq_i_write_at_end__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes___(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  **r,
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes x
)
{
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  *s0 = r[0U];
  Prims_int
  n =
    FStar_Seq_Base_length__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(s0);
  r[0U] =
    FStar_Seq_Properties_snoc__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes(s0,
      x);
}

static void
Old_Handshake_export(
  Old_Handshake_hs_ hs,
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes xk
)
{
  Old_Handshake_print("exporting a key");
  FStar_Bytes_bytes x1 = Negotiation_nonce(hs.r, hs.nego);
  Old_Epochs_epochs x2 = hs.epochs;
  FStar_Monotonic_Seq_i_write_at_end__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes___(x2.exporter,
    xk);
}

static Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*FStar_Monotonic_Seq_i_read__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes___(
  Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
  **m
)
{
  return m[0U];
}

Prims_list__FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
*Old_Handshake_xkeys_of(Old_Handshake_hs_ hs)
{
  FStar_Bytes_bytes x1 = Negotiation_nonce(hs.r, hs.nego);
  Old_Epochs_epochs x2 = hs.epochs;
  return
    FStar_Monotonic_Seq_i_read__FStar_Pervasives_dtuple3_TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes___(x2.exporter);
}

bool Old_Handshake_uu___is_InAck(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InAck)
    return true;
  else
    return false;
}

bool Old_Handshake___proj__InAck__item__next_keys(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InAck)
    return projectee.val.case_InAck.next_keys;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake___proj__InAck__item__complete(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InAck)
    return projectee.val.case_InAck.complete;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_InQuery(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InQuery)
    return true;
  else
    return false;
}

Prims_list__FStar_Bytes_bytes
*Old_Handshake___proj__InQuery__item___0(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InQuery)
    return projectee.val.case_InQuery._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake___proj__InQuery__item___1(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InQuery)
    return projectee.val.case_InQuery._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_uu___is_InError(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InError)
    return true;
  else
    return false;
}

K___Parsers_Alert_alert_Prims_string
Old_Handshake___proj__InError__item___0(Old_Handshake_incoming projectee)
{
  if (projectee.tag == Old_Handshake_InError)
    return projectee.val.case_InError;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Old_Handshake_in_next_keys(Old_Handshake_incoming r)
{
  if (Old_Handshake_uu___is_InAck(r))
    if (r.tag == Old_Handshake_InAck)
      return r.val.case_InAck.next_keys;
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  else
    return false;
}

bool Old_Handshake_in_complete(Old_Handshake_incoming r)
{
  if (Old_Handshake_uu___is_InAck(r))
    if (r.tag == Old_Handshake_InAck)
      return r.val.case_InAck.complete;
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  else
    return false;
}

static FStar_Bytes_bytes
Old_Handshake_compute_binder(
  Old_Handshake_hs_ hs,
  Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key bkey
)
{
  TLSInfo_pre_binderId *bid = bkey.fst;
  Old_HMAC_UFCMA_key bk = bkey.snd;
  FStar_Bytes_bytes digest_CH0 = HandshakeLog_hash_tag(TLSInfo_binderId_hash(bid), hs.log);
  return
    Old_HMAC_UFCMA_mac((
        (Old_HMAC_UFCMA_id){ .tag = Old_HMAC_UFCMA_HMAC_Binder, .val = { .case_HMAC_Binder = bid } }
      ),
      bk,
      digest_CH0);
}

static bool
Old_Handshake_verify_binder(
  Old_Handshake_hs_ hs,
  Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key bkey,
  FStar_Bytes_bytes tag,
  Prims_int tlen
)
{
  TLSInfo_pre_binderId *bid = bkey.fst;
  Old_HMAC_UFCMA_key bk = bkey.snd;
  FStar_Bytes_bytes
  digest_CH0 = HandshakeLog_hash_tag_truncated(TLSInfo_binderId_hash(bid), hs.log, tlen);
  return
    Old_HMAC_UFCMA_verify((
        (Old_HMAC_UFCMA_id){ .tag = Old_HMAC_UFCMA_HMAC_Binder, .val = { .case_HMAC_Binder = bid } }
      ),
      bk,
      digest_CH0,
      tag);
}

static Prims_list__FStar_Bytes_bytes
*Old_Handshake_map_ST2__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_FStar_Bytes_bytes_Old_Handshake_hs_(
  Old_Handshake_hs_ env,
  FStar_Bytes_bytes
  (*f)(Old_Handshake_hs_ x0, Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key x1),
  Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key *x
)
{
  if (x->tag == Prims_Nil)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
    return buf;
  }
  else if (x->tag == Prims_Cons)
  {
    Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key *tl1 = x->tl;
    Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key a = x->hd;
    FStar_Bytes_bytes uu____0 = f(env, a);
    KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
    Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
    buf[0U]
    =
      (
        (Prims_list__FStar_Bytes_bytes){
          .tag = Prims_Cons,
          .hd = uu____0,
          .tl = Old_Handshake_map_ST2__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_FStar_Bytes_bytes_Old_Handshake_hs_(env,
            f,
            tl1)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static void Old_Handshake_client_Binders(Old_Handshake_hs_ hs, HandshakeMessages_ch offer)
{
  K___FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Ticket_ticket_Prims_list__K___FStar_Bytes_bytes_Ticket_ticket
  scrut = Negotiation_resume(hs.r, hs.nego);
  if (!(scrut.snd->tag == Prims_Nil))
  {
    Prims_list__K___FStar_Bytes_bytes_Ticket_ticket *pskl = scrut.snd;
    Prims_list__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
    *binderKeys = Old_KeySchedule_ks_client_13_get_binder_keys(hs.ks, pskl);
    Prims_list__FStar_Bytes_bytes
    *binders =
      Old_Handshake_map_ST2__Prims_dtuple2_TLSInfo_pre_binderId_Old_HMAC_UFCMA_key_FStar_Bytes_bytes_Old_Handshake_hs_(hs,
        Old_Handshake_compute_binder,
        binderKeys);
    HandshakeLog_send(hs.log,
      (
        (HandshakeMessages_hs_msg){
          .tag = HandshakeMessages_Binders,
          .val = { .case_Binders = binders }
        }
      ));
    if
    (
      FStar_Pervasives_Native_uu___is_Some__FStar_Pervasives_Native_option_uint32_t(Negotiation_find_early_data(offer))
    )
    {
      Old_Handshake_print("setting up 0RTT");
      if (binderKeys->tag == Prims_Cons)
      {
        TLSInfo_pre_binderId *bid = binderKeys->hd.fst;
        Spec_Hash_Definitions_hash_alg ha = TLSInfo_binderId_hash(bid);
        FStar_Bytes_bytes digest_CH = HandshakeLog_hash_tag(ha, hs.log);
        K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance
        scrut = Old_KeySchedule_ks_client_13_ch(hs.ks, digest_CH);
        FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
        early_exporter_secret = scrut.fst;
        Old_KeySchedule_recordInstance edk = scrut.snd;
        Old_Handshake_export(hs, early_exporter_secret);
        Old_Handshake_register(hs, edk);
        HandshakeLog_send_signals(hs.log,
          (
            (FStar_Pervasives_Native_option__K___bool_bool_bool){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = true, .snd = false, .thd = false }
            }
          ),
          false);
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
Old_Handshake_client_ClientHello(Old_Handshake_hs_ hs, TLSInfo_id i1)
{
  Parsers_ProtocolVersion_protocolVersion scrut = Old_Handshake_config_of(hs).max_version;
  FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup groups;
  if (scrut.tag == Parsers_ProtocolVersion_TLS_1p3)
  {
    Old_Handshake_print("offering ClientHello 1.3");
    groups =
      (
        (FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_Some,
          .v = Old_Handshake_config_of(hs).offer_shares
        }
      );
  }
  else
  {
    Old_Handshake_print("offering ClientHello 1.2");
    groups =
      (
        (FStar_Pervasives_Native_option__Prims_list__Parsers_NamedGroup_namedGroup){
          .tag = FStar_Pervasives_Native_None
        }
      );
  }
  FStar_Pervasives_Native_option__Prims_list__CommonDH_keyShareEntry
  shares = Old_KeySchedule_ks_client_init(hs.ks, groups);
  HandshakeMessages_ch offer = Negotiation_client_ClientHello(hs.nego, shares);
  HandshakeLog_send(hs.log,
    (
      (HandshakeMessages_hs_msg){
        .tag = HandshakeMessages_ClientHello,
        .val = { .case_ClientHello = offer }
      }
    ));
  Old_Handshake_client_Binders(hs, offer);
  hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Wait_ServerHello });
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___){ .tag = FStar_Error_Correct }
    );
}

static Old_Handshake_incoming
Old_Handshake_client_HelloRetryRequest(Old_Handshake_hs_ hs, HandshakeMessages_hrr hrr)
{
  Old_Handshake_print("client_HelloRetryRequest");
  FStar_Pervasives_Native_option__CommonDH_group_ scrut = Negotiation_group_of_hrr(hrr);
  FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ s0;
  if (scrut.tag == FStar_Pervasives_Native_None)
  {
    Old_Handshake_print("Server did not specify a group in HRR, re-using the previous choice");
    s0 =
      (
        (FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  }
  else if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    CommonDH_group_ g1 = scrut.v;
    CommonDH_pre_share_ s = Old_KeySchedule_ks_client_13_hello_retry(hs.ks, g1);
    s0 =
      (
        (FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = g1, .snd = s }
        }
      );
  }
  else
    s0 =
      KRML_EABORT(FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_,
        "unreachable (pattern matches are exhaustive in F*)");
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_ch
  scrut0 = Negotiation_client_HelloRetryRequest(hs.nego, hrr, s0);
  if (scrut0.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
    return
      ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
  }
  else if (scrut0.tag == FStar_Error_Correct)
  {
    HandshakeMessages_ch ch = scrut0.val.case_Correct;
    HandshakeLog_send(hs.log,
      (
        (HandshakeMessages_hs_msg){
          .tag = HandshakeMessages_ClientHello,
          .val = { .case_ClientHello = ch }
        }
      ));
    Old_Handshake_client_Binders(hs, ch);
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_client_ServerHello(Old_Handshake_hs_ s, HandshakeMessages_sh sh)
{
  Old_Handshake_print("client_ServerHello");
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Negotiation_mode
  scrut = Negotiation_client_ServerHello(s.nego, sh);
  if (scrut.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
    return
      ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
  }
  else if (scrut.tag == FStar_Error_Correct)
  {
    Negotiation_mode mode = scrut.val.case_Correct;
    Parsers_ProtocolVersion_protocolVersion pv = mode.n_protocol_version;
    TLSConstants_config cfg = Negotiation_local_config(s.r, s.nego);
    Spec_Hash_Definitions_hash_alg ha = Negotiation_hashAlg(mode);
    CipherSuite_kexAlg ka = Negotiation_kexAlg(mode);
    HandshakeLog_setParams(s.log,
      pv,
      ha,
      (
        (FStar_Pervasives_Native_option__CipherSuite_kexAlg){
          .tag = FStar_Pervasives_Native_Some,
          .v = ka
        }
      ),
      ((FStar_Pervasives_Native_option__CommonDH_group_){ .tag = FStar_Pervasives_Native_None }));
    if (pv.tag == Parsers_ProtocolVersion_TLS_1p3)
    {
      Old_Handshake_print("Running TLS 1.3");
      FStar_Bytes_bytes digest = HandshakeLog_hash_tag(ha, s.log);
      Old_KeySchedule_recordInstance
      hs_keys =
        Old_KeySchedule_ks_client_13_sh(s.ks,
          mode.n_server_random,
          mode.n_cipher_suite,
          digest,
          mode.n_server_share,
          mode.n_pski);
      Old_Handshake_register(s, hs_keys);
      if (Negotiation_zeroRTToffer(mode.n_offer))
      {
        Old_Epochs_incr_reader(Negotiation_nonce(s.r, s.nego), s.epochs);
        if (mode.n_pski.tag == FStar_Pervasives_Native_None)
        {
          Old_Handshake_print("0-RTT rejected early (no PSK was selected)");
          HandshakeLog_send_signals(s.log,
            (
              (FStar_Pervasives_Native_option__K___bool_bool_bool){
                .tag = FStar_Pervasives_Native_Some,
                .v = { .fst = false, .snd = false, .thd = true }
              }
            ),
            false);
        }
        else if (mode.n_pski.tag == FStar_Pervasives_Native_Some)
        {
          Old_Handshake_print("0RTT potentially accepted (wait for EE to confirm)");
          if (cfg.is_quic)
            HandshakeLog_send_signals(s.log,
              (
                (FStar_Pervasives_Native_option__K___bool_bool_bool){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = { .fst = false, .snd = false, .thd = false }
                }
              ),
              false);
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
        HandshakeLog_send_signals(s.log,
          (
            (FStar_Pervasives_Native_option__K___bool_bool_bool){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = false, .snd = false, .thd = false }
            }
          ),
          false);
      s.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Wait_Finished1 });
      Old_Epochs_incr_reader(Negotiation_nonce(s.r, s.nego), s.epochs);
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InAck,
            .val = { .case_InAck = { .next_keys = true, .complete = false } }
          }
        );
    }
    else
    {
      Old_Handshake_print("Running classic TLS");
      Old_Handshake_print(Prims_strcat("Offered SID=",
          Prims_strcat(FStar_Bytes_print_bytes(mode.n_offer.ch_sessionID),
            Prims_strcat(" Server SID=", FStar_Bytes_print_bytes(mode.n_sessionID)))));
      if (Negotiation_resume_12(mode))
      {
        Old_Handshake_print("Server accepted our 1.2 ticket.");
        FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_Ticket_ticket
        scrut =
          FStar_Pervasives_Native_fst__FStar_Pervasives_Native_option_FStar_Bytes_bytes___Ticket_ticket_Prims_list_FStar_Bytes_bytes___Ticket_ticket(Negotiation_resume(s.r,
              s.nego));
        if (scrut.tag == FStar_Pervasives_Native_Some && scrut.v.snd.tag == Ticket_Ticket12)
        {
          FStar_Bytes_bytes ms = scrut.v.snd.val.case_Ticket12.ms;
          TLSInfo_msId msId = scrut.v.snd.val.case_Ticket12.msId;
          bool ems = scrut.v.snd.val.case_Ticket12.ems;
          CipherSuite_cipherSuite_ cs = scrut.v.snd.val.case_Ticket12.cs;
          Parsers_ProtocolVersion_protocolVersion pv1 = scrut.v.snd.val.case_Ticket12.pv;
          Parsers_ProtocolVersion_protocolVersion pv_ = mode.n_protocol_version;
          CipherSuite_cipherSuite_ cs_ = mode.n_cipher_suite;
          FStar_Bytes_bytes sr = mode.n_server_random;
          if
          (
            __eq__Parsers_ProtocolVersion_protocolVersion(pv1,
              pv_)
            && __eq__CipherSuite_cipherSuite_(cs, cs_)
          )
          {
            Old_KeySchedule_recordInstance
            adk = Old_KeySchedule_ks_client_12_resume(s.ks, sr, pv1, cs, ems, msId, ms);
            FStar_Bytes_bytes digestSH = HandshakeLog_hash_tag(ha, s.log);
            Old_Handshake_register(s, adk);
            s.state[0U] =
              (
                (Old_Handshake_machineState){
                  .tag = Old_Handshake_C_Wait_CCS1,
                  .val = { .case_C_Wait_CCS1 = digestSH }
                }
              );
            return
              (
                (Old_Handshake_incoming){
                  .tag = Old_Handshake_InAck,
                  .val = { .case_InAck = { .next_keys = false, .complete = false } }
                }
              );
          }
          else
            return
              (
                (Old_Handshake_incoming){
                  .tag = Old_Handshake_InError,
                  .val = {
                    .case_InError = {
                      .fst = TLSError_fatalAlert(Parsers_AlertDescription_Handshake_failure),
                      .snd = "inconsistent protocol version or ciphersuite during resumption"
                    }
                  }
                }
              );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        s.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Wait_ServerHelloDone });
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = false, .complete = false } }
            }
          );
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_client_ServerHelloDone(
  Old_Handshake_hs_ hs,
  Prims_list__FStar_Bytes_bytes *c,
  HandshakeMessages_ske ske,
  FStar_Pervasives_Native_option__HandshakeMessages_cr ocr
)
{
  Old_Handshake_print("processing ...ServerHelloDone");
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Negotiation_mode
  scrut0 = Negotiation_client_ServerKeyExchange(hs.nego, c, ske, ocr);
  if (scrut0.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
    return
      ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
  }
  else if (scrut0.tag == FStar_Error_Correct)
  {
    Negotiation_mode mode = scrut0.val.case_Correct;
    if (!(ocr.tag == FStar_Pervasives_Native_None))
      if (ocr.tag == FStar_Pervasives_Native_Some)
      {
        Old_Handshake_print("processing certificate request (TODO)");
        KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
        Prims_list__FStar_Bytes_bytes
        *cc = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
        cc[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
        HandshakeLog_send(hs.log,
          (
            (HandshakeMessages_hs_msg){
              .tag = HandshakeMessages_Certificate,
              .val = { .case_Certificate = cc }
            }
          ));
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_
    x0 = mode.n_server_share;
    Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ gy;
    if (x0.tag == FStar_Pervasives_Native_Some)
      gy = x0.v;
    else
      gy =
        KRML_EABORT(Prims_dtuple2__CommonDH_group__CommonDH_pre_share_,
          "unreachable (pattern matches are exhaustive in F*)");
    CommonDH_pre_share_
    gx =
      Old_KeySchedule_ks_client_12_full_dh(hs.ks,
        mode.n_server_random,
        mode.n_protocol_version,
        mode.n_cipher_suite,
        Negotiation_emsFlag(mode),
        gy);
    CommonDH_group_ g1 = gy.fst;
    HandshakeMessages_hs_msg
    msg =
      {
        .tag = HandshakeMessages_ClientKeyExchange,
        .val = { .case_ClientKeyExchange = HandshakeMessages_kex_c_of_dh_key(g1, gx) }
      };
    Spec_Hash_Definitions_hash_alg
    ha = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode.n_cipher_suite);
    FStar_Bytes_bytes digestClientKeyExchange = HandshakeLog_send_tag(ha, hs.log, msg);
    K___FStar_Bytes_bytes_Old_KeySchedule_recordInstance
    scrut = Old_KeySchedule_ks_client_12_set_session_hash(hs.ks, digestClientKeyExchange);
    FStar_Bytes_bytes cfin_key = scrut.fst;
    Old_KeySchedule_recordInstance app_keys = scrut.snd;
    Old_Handshake_register(hs, app_keys);
    Old_Handshake_print(Prims_strcat("digest is ",
        FStar_Bytes_print_bytes(digestClientKeyExchange)));
    FStar_Bytes_bytes
    cvd = TLSPRF_finished12(ha, cfin_key, TLSConstants_Client, digestClientKeyExchange);
    FStar_Bytes_bytes
    digestClientFinished =
      HandshakeLog_send_CCS_tag(ha,
        hs.log,
        (
          (HandshakeMessages_hs_msg){
            .tag = HandshakeMessages_Finished,
            .val = { .case_Finished = cvd }
          }
        ),
        false);
    hs.state[0U] =
      (
        (Old_Handshake_machineState){
          .tag = Old_Handshake_C_Wait_CCS2,
          .val = { .case_C_Wait_CCS2 = digestClientFinished }
        }
      );
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static void
Old_Handshake_client_ClientFinished_13(
  Old_Handshake_hs_ hs,
  FStar_Bytes_bytes digestServerFinished,
  FStar_Pervasives_Native_option__HandshakeMessages_cr ocr,
  Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key cfin_key,
  bool reject_0rtt
)
{
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  Spec_Hash_Definitions_hash_alg
  ha = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode.n_cipher_suite);
  FStar_Bytes_bytes digest;
  if (ocr.tag == FStar_Pervasives_Native_Some)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_),
      (uint32_t)1U);
    Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
    *buf =
      KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_));
    buf[0U]
    = ((Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_){ .tag = Prims_Nil });
    digest =
      HandshakeLog_send_tag(ha,
        hs.log,
        (
          (HandshakeMessages_hs_msg){
            .tag = HandshakeMessages_Certificate13,
            .val = {
              .case_Certificate13 = {
                .crt_request_context = FStar_Bytes_empty_bytes,
                .crt_chain13 = buf
              }
            }
          }
        ));
  }
  else if (ocr.tag == FStar_Pervasives_Native_None)
    digest = digestServerFinished;
  else
    digest = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
  TLSInfo_pre_finishedId *finId = cfin_key.fst;
  Old_HMAC_UFCMA_key cfin_key1 = cfin_key.snd;
  FStar_Bytes_bytes
  cvd =
    Old_HMAC_UFCMA_mac((
        (Old_HMAC_UFCMA_id){
          .tag = Old_HMAC_UFCMA_HMAC_Finished,
          .val = { .case_HMAC_Finished = finId }
        }
      ),
      cfin_key1,
      digest);
  FStar_Bytes_bytes
  digest_CF =
    HandshakeLog_send_tag(ha,
      hs.log,
      (
        (HandshakeMessages_hs_msg){
          .tag = HandshakeMessages_Finished,
          .val = { .case_Finished = cvd }
        }
      ));
  Old_KeySchedule_ks_client_13_cf(hs.ks, digest_CF);
  Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
  HandshakeLog_send_signals(hs.log,
    (
      (FStar_Pervasives_Native_option__K___bool_bool_bool){
        .tag = FStar_Pervasives_Native_Some,
        .v = { .fst = true, .snd = false, .thd = reject_0rtt }
      }
    ),
    true);
  hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Complete });
}

typedef struct FStar_Pervasives_Native_option__HandshakeMessages_crt13_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  HandshakeMessages_crt13 v;
}
FStar_Pervasives_Native_option__HandshakeMessages_crt13;

static Old_Handshake_incoming
Old_Handshake_client_ServerFinished_13(
  Old_Handshake_hs_ hs,
  Prims_list__Extensions_extension_ *ee,
  FStar_Pervasives_Native_option__HandshakeMessages_cr ocr,
  FStar_Pervasives_Native_option__HandshakeMessages_crt13 oc,
  FStar_Pervasives_Native_option__HandshakeMessages_signature ocv,
  FStar_Bytes_bytes svd,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes digestCert,
  FStar_Bytes_bytes digestCertVerify,
  FStar_Bytes_bytes digestServerFinished
)
{
  FStar_Pervasives_Native_option__Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
  oc1;
  if (oc.tag == FStar_Pervasives_Native_None)
    oc1 =
      (
        (FStar_Pervasives_Native_option__Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (oc.tag == FStar_Pervasives_Native_Some)
  {
    HandshakeMessages_crt13 c = oc.v;
    oc1 =
      (
        (FStar_Pervasives_Native_option__Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_Some,
          .v = c.crt_chain13
        }
      );
  }
  else
    oc1 =
      KRML_EABORT(FStar_Pervasives_Native_option__Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_,
        "unreachable (pattern matches are exhaustive in F*)");
  TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Negotiation_mode
  scrut0 = Negotiation_clientComplete_13(hs.nego, ee, ocr, oc1, ocv, digestCert);
  if (scrut0.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
    return
      ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
  }
  else if (scrut0.tag == FStar_Error_Correct)
  {
    Negotiation_mode mode = scrut0.val.case_Correct;
    K___Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key_Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    scrut = Old_KeySchedule_ks_client_13_sf(hs.ks, digestServerFinished);
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key sfin_key = scrut.fst;
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key cfin_key = scrut.snd;
    Old_KeySchedule_recordInstance app_keys = scrut.thd;
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    exporter_master_secret = scrut.f3;
    TLSInfo_pre_finishedId *finId = sfin_key.fst;
    Old_HMAC_UFCMA_key sfin_key1 = sfin_key.snd;
    if
    (
      !Old_HMAC_UFCMA_verify((
          (Old_HMAC_UFCMA_id){
            .tag = Old_HMAC_UFCMA_HMAC_Finished,
            .val = { .case_HMAC_Finished = finId }
          }
        ),
        sfin_key1,
        digestCertVerify,
        svd)
    )
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InError,
            .val = {
              .case_InError = {
                .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
                .snd = Prims_strcat("Finished MAC did not verify: expected digest ",
                  FStar_Bytes_print_bytes(digestCertVerify))
              }
            }
          }
        );
    else
    {
      Old_Handshake_export(hs, exporter_master_secret);
      Old_Handshake_register(hs, app_keys);
      if (Negotiation_zeroRTT(mode) && !cfg.is_quic)
      {
        Old_Handshake_print("Early data accepted; emitting EOED.");
        Spec_Hash_Definitions_hash_alg ha = Negotiation_hashAlg(mode);
        FStar_Bytes_bytes
        digestEOED =
          HandshakeLog_send_tag(ha,
            hs.log,
            ((HandshakeMessages_hs_msg){ .tag = HandshakeMessages_EndOfEarlyData }));
        HandshakeLog_send_signals(hs.log,
          (
            (FStar_Pervasives_Native_option__K___bool_bool_bool){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = false, .snd = false, .thd = false }
            }
          ),
          false);
        hs.state[0U] =
          (
            (Old_Handshake_machineState){
              .tag = Old_Handshake_C_Sent_EOED,
              .val = { .case_C_Sent_EOED = { ._0 = digestEOED, ._1 = ocr, ._2 = cfin_key } }
            }
          );
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = false, .complete = false } }
            }
          );
      }
      else
      {
        bool reject_0rtt;
        if (Negotiation_zeroRTToffer(mode.n_offer))
          if (Negotiation_zeroRTT(mode))
          {
            Old_Handshake_print("Early data accepted (QUIC)");
            reject_0rtt = false;
          }
          else
          {
            Old_Handshake_print("Early data rejected (QUIC)");
            reject_0rtt = true;
          }
        else
          reject_0rtt = false;
        Old_Handshake_client_ClientFinished_13(hs,
          digestServerFinished,
          ocr,
          cfin_key,
          reject_0rtt);
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = true, .complete = false } }
            }
          );
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_string Old_Handshake_iutf8(FStar_Bytes_bytes m)
{
  FStar_Pervasives_Native_option__Prims_string scrut = FStar_Bytes_iutf8_opt(m);
  if (scrut.tag == FStar_Pervasives_Native_None)
  {
    Old_Handshake_print("Not a utf8 encoding of a string");
    return Old_Handshake_iutf8(m);
  }
  else if (scrut.tag == FStar_Pervasives_Native_Some)
    return scrut.v;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct FStar_Pervasives_Native_option__HandshakeMessages_sticket_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  HandshakeMessages_sticket v;
}
FStar_Pervasives_Native_option__HandshakeMessages_sticket;

typedef struct K___FStar_Pervasives_Native_option__HandshakeMessages_sticket_bool_s
{
  FStar_Pervasives_Native_option__HandshakeMessages_sticket fst;
  bool snd;
}
K___FStar_Pervasives_Native_option__HandshakeMessages_sticket_bool;

static Old_Handshake_incoming
Old_Handshake_client_NewSessionTicket_12(
  Old_Handshake_hs_ hs,
  bool resume1,
  FStar_Bytes_bytes digest,
  FStar_Pervasives_Native_option__HandshakeMessages_sticket ost
)
{
  Prims_string ite0;
  if (resume1)
    ite0 = "resumption";
  else
    ite0 = "full handshake";
  Prims_string ite;
  if (ost.tag == FStar_Pervasives_Native_None)
    ite = "No ticket sent.";
  else if (ost.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes t = ost.v.sticket_ticket;
    ite = Prims_strcat("Ticket: ", FStar_Bytes_print_bytes(t));
  }
  else
    ite = KRML_EABORT(Prims_string, "unreachable (pattern matches are exhaustive in F*)");
  Old_Handshake_print(Prims_strcat("Processing server CCS (",
      Prims_strcat(ite0, Prims_strcat("). ", ite))));
  Old_Handshake_machineState ite1;
  if (resume1)
    ite1 =
      (
        (Old_Handshake_machineState){
          .tag = Old_Handshake_C_Wait_R_Finished1,
          .val = { .case_C_Wait_R_Finished1 = digest }
        }
      );
  else
    ite1 =
      (
        (Old_Handshake_machineState){
          .tag = Old_Handshake_C_Wait_Finished2,
          .val = { .case_C_Wait_Finished2 = digest }
        }
      );
  hs.state[0U] = ite1;
  Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  K___FStar_Pervasives_Native_option__HandshakeMessages_sticket_bool
  scrut0 = { .fst = ost, .snd = Negotiation_sendticket_12(mode) };
  if (scrut0.fst.tag == FStar_Pervasives_Native_Some && scrut0.snd == true)
  {
    FStar_Bytes_bytes tid = scrut0.fst.v.sticket_ticket;
    TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
    Prims_string sni = Old_Handshake_iutf8(Negotiation_get_sni(mode.n_offer));
    K___TLSInfo_msId_FStar_Bytes_bytes scrut = Old_KeySchedule_ks_12_ms(hs.ks);
    FStar_Bytes_bytes ms = scrut.snd;
    Parsers_ProtocolVersion_protocolVersion pv = mode.n_protocol_version;
    CipherSuite_cipherSuite_ cs = mode.n_cipher_suite;
    TLSConstants_ticket_cb tcb = cfg.ticket_callback;
    tcb.new_ticket(tcb.ticket_context,
      sni,
      tid,
      (
        (TLSConstants_ticketInfo){
          .tag = TLSConstants_TicketInfo_12,
          .val = {
            .case_TicketInfo_12 = { .fst = pv, .snd = cs, .thd = Negotiation_emsFlag(mode) }
          }
        }
      ),
      ms);
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = true, .complete = false } }
        }
      );
  }
  else if (scrut0.fst.tag == FStar_Pervasives_Native_None && scrut0.snd == false)
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = true, .complete = false } }
        }
      );
  else if (scrut0.fst.tag == FStar_Pervasives_Native_Some && scrut0.snd == false)
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Unexpected_message),
              .snd = "unexpected NewSessionTicket message"
            }
          }
        }
      );
  else if (scrut0.fst.tag == FStar_Pervasives_Native_None && scrut0.snd == true)
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Unexpected_message),
              .snd = "missing expected NewSessionTicket message"
            }
          }
        }
      );
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_client_NewSessionTicket_13(
  Old_Handshake_hs_ hs,
  HandshakeMessages_sticket13 st13
)
{
  FStar_Bytes_bytes tid = st13.ticket13_ticket;
  Old_Handshake_print(Prims_strcat("Received ticket: ", FStar_Bytes_hex_of_bytes(tid)));
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  if (mode.n_cipher_suite.tag == CipherSuite_CipherSuite13)
  {
    Spec_Hash_Definitions_hash_alg h1 = mode.n_cipher_suite.val.case_CipherSuite13._1;
    EverCrypt_aead_alg ae = mode.n_cipher_suite.val.case_CipherSuite13._0;
    Prims_list__Extensions_extension_ *t_ext = st13.ticket13_extensions;
    FStar_Pervasives_Native_option__Extensions_extension_
    ed =
      FStar_List_Tot_Base_find__Extensions_extension_(Extensions_uu___is_E_early_data____,
        t_ext);
    uint32_t now1 = FStar_UInt32_uint_to_t(FStar_Date_secondsFromDawn());
    TLSConstants_pskInfo
    pskInfo =
      {
        .ticket_nonce = { .tag = FStar_Pervasives_Native_Some, .v = st13.ticket13_nonce },
        .time_created = now1, .ticket_age_add = st13.ticket13_age_add,
        .allow_early_data = FStar_Pervasives_Native_uu___is_Some__Extensions_extension_(ed),
        .allow_dhe_resumption = true, .allow_psk_resumption = true, .early_ae = ae, .early_hash = h1,
        .identities = { .fst = FStar_Bytes_empty_bytes, .snd = FStar_Bytes_empty_bytes }
      };
    FStar_Bytes_bytes psk = Old_KeySchedule_ks_client_13_rms_psk(hs.ks, st13.ticket13_nonce);
    Prims_string sni = Old_Handshake_iutf8(Negotiation_get_sni(mode.n_offer));
    TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
    bool valid_ed;
    if (cfg.is_quic)
      if (ed.tag == FStar_Pervasives_Native_None)
        valid_ed = true;
      else if
      (
        ed.tag
        == FStar_Pervasives_Native_Some
        &&
          ed.v.tag
          == Extensions_E_early_data
          && ed.v.val.case_E_early_data.tag == FStar_Pervasives_Native_Some
      )
      {
        uint32_t x = ed.v.val.case_E_early_data.v;
        valid_ed = x == (uint32_t)0xffffffffU;
      }
      else
        valid_ed = false;
    else
      valid_ed = true;
    if (valid_ed)
    {
      TLSConstants_ticket_cb tcb = cfg.ticket_callback;
      tcb.new_ticket(tcb.ticket_context,
        sni,
        tid,
        (
          (TLSConstants_ticketInfo){
            .tag = TLSConstants_TicketInfo_13,
            .val = { .case_TicketInfo_13 = pskInfo }
          }
        ),
        psk);
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InAck,
            .val = { .case_InAck = { .next_keys = false, .complete = false } }
          }
        );
    }
    else
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InError,
            .val = {
              .case_InError = {
                .fst = TLSError_fatalAlert(Parsers_AlertDescription_Illegal_parameter),
                .snd = "QUIC tickets must allow 0xFFFFFFFF bytes of early data"
              }
            }
          }
        );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_client_ServerFinished(
  Old_Handshake_hs_ hs,
  FStar_Bytes_bytes f,
  FStar_Bytes_bytes digestClientFinished
)
{
  FStar_Bytes_bytes sfin_key = Old_KeySchedule_ks_12_finished_key(hs.ks);
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  Spec_Hash_Definitions_hash_alg
  ha = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode.n_cipher_suite);
  FStar_Bytes_bytes
  expected_svd = TLSPRF_finished12(ha, sfin_key, TLSConstants_Server, digestClientFinished);
  if (__eq__FStar_Bytes_bytes(f, expected_svd))
  {
    hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Complete });
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = true } }
        }
      );
  }
  else
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = Prims_strcat("Finished MAC did not verify: expected digest ",
                FStar_Bytes_print_bytes(digestClientFinished))
            }
          }
        }
      );
}

static Old_Handshake_incoming
Old_Handshake_client_R_ServerFinished(
  Old_Handshake_hs_ hs,
  FStar_Bytes_bytes f,
  FStar_Bytes_bytes digestNewSessionTicket,
  FStar_Bytes_bytes digestServerFinished
)
{
  Old_Handshake_print("client_R_ServerFinished");
  FStar_Bytes_bytes sfin_key = Old_KeySchedule_ks_12_finished_key(hs.ks);
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  Spec_Hash_Definitions_hash_alg
  ha = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode.n_cipher_suite);
  FStar_Bytes_bytes
  expected_svd = TLSPRF_finished12(ha, sfin_key, TLSConstants_Server, digestNewSessionTicket);
  if (__eq__FStar_Bytes_bytes(f, expected_svd))
  {
    FStar_Bytes_bytes
    cvd = TLSPRF_finished12(ha, sfin_key, TLSConstants_Client, digestServerFinished);
    FStar_Bytes_bytes
    uu____0 =
      HandshakeLog_send_CCS_tag(ha,
        hs.log,
        (
          (HandshakeMessages_hs_msg){
            .tag = HandshakeMessages_Finished,
            .val = { .case_Finished = cvd }
          }
        ),
        true);
    hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Complete });
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  }
  else
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = Prims_strcat("Finished MAC did not verify: expected digest ",
                FStar_Bytes_print_bytes(digestNewSessionTicket))
            }
          }
        }
      );
}

static Old_Handshake_incoming Old_Handshake_server_ServerHelloDone(Old_Handshake_hs_ hs)
{
  Old_Handshake_print("Sending ...ServerHelloDone");
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  if (mode.n_server_cert.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
    *chain = mode.n_server_cert.v.fst;
    FStar_Pervasives_Native_option__CommonDH_group_ scrut = Negotiation_chosenGroup(mode);
    if (scrut.tag == FStar_Pervasives_Native_None)
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InError,
            .val = {
              .case_InError = {
                .fst = TLSError_fatalAlert(Parsers_AlertDescription_Handshake_failure),
                .snd = FStar_Error_perror("Old.Handshake.fst",
                  (krml_checked_int_t)698,
                  "no shared supported group")
              }
            }
          }
        );
    else if (scrut.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_
      x0 = mode.n_server_share;
      Prims_dtuple2__CommonDH_group__CommonDH_pre_share_ ite;
      if (x0.tag == FStar_Pervasives_Native_Some)
        ite = x0.v;
      else
        ite =
          KRML_EABORT(Prims_dtuple2__CommonDH_group__CommonDH_pre_share_,
            "unreachable (pattern matches are exhaustive in F*)");
      HandshakeMessages_kex_s
      kex_s = { .tag = HandshakeMessages_KEX_S_DHE, .val = { .case_KEX_S_DHE = ite } };
      FStar_Bytes_bytes cr = mode.n_offer.ch_client_random;
      FStar_Bytes_bytes sv = HandshakeMessages_kex_s_to_bytes(kex_s);
      FStar_Bytes_bytes csr = FStar_Bytes_append(cr, mode.n_server_random);
      FStar_Bytes_bytes
      tbs =
        Negotiation_to_be_signed(mode.n_protocol_version,
          TLSConstants_Server,
          (
            (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = csr
            }
          ),
          sv);
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
      scrut = Negotiation_sign(hs.r, hs.nego, tbs);
      if (scrut.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
        return
          ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        HandshakeMessages_signature signature = scrut.val.case_Correct;
        HandshakeMessages_ske ske = { .ske_kex_s = kex_s, .ske_signed_params = signature };
        HandshakeLog_send(hs.log,
          (
            (HandshakeMessages_hs_msg){
              .tag = HandshakeMessages_Certificate,
              .val = { .case_Certificate = Cert_chain_down(chain) }
            }
          ));
        HandshakeLog_send(hs.log,
          (
            (HandshakeMessages_hs_msg){
              .tag = HandshakeMessages_ServerKeyExchange,
              .val = { .case_ServerKeyExchange = ske }
            }
          ));
        HandshakeLog_send(hs.log,
          ((HandshakeMessages_hs_msg){ .tag = HandshakeMessages_ServerHelloDone }));
        hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Wait_CCS1 });
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = false, .complete = false } }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool Old_Handshake_not_encryptedExtension(Extensions_extension_ e)
{
  return !Extensions_encryptedExtension(e);
}

typedef struct
K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__Prims_list__Extensions_extension__s
{
  Parsers_ProtocolVersion_protocolVersion fst;
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ snd;
}
K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__Prims_list__Extensions_extension_;

static HandshakeMessages_hs_msg Old_Handshake_serverHello(Negotiation_mode m)
{
  Parsers_ProtocolVersion_protocolVersion pv = m.n_protocol_version;
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite
  scrut0;
  if (m.n_cipher_suite.tag == CipherSuite_NullCipherSuite)
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_NULL_WITH_NULL_NULL } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite13
    &&
      m.n_cipher_suite.val.case_CipherSuite13._0
      == EverCrypt_AES128_GCM
      && m.n_cipher_suite.val.case_CipherSuite13._1 == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_AES_128_GCM_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite13
    &&
      m.n_cipher_suite.val.case_CipherSuite13._0
      == EverCrypt_AES256_GCM
      && m.n_cipher_suite.val.case_CipherSuite13._1 == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_AES_256_GCM_SHA384 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite13
    &&
      m.n_cipher_suite.val.case_CipherSuite13._0
      == EverCrypt_CHACHA20_POLY1305
      && m.n_cipher_suite.val.case_CipherSuite13._1 == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_CHACHA20_POLY1305_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite13
    &&
      m.n_cipher_suite.val.case_CipherSuite13._0
      == EverCrypt_AES128_CCM
      && m.n_cipher_suite.val.case_CipherSuite13._1 == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_AES_128_CCM_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite13
    &&
      m.n_cipher_suite.val.case_CipherSuite13._0
      == EverCrypt_AES128_CCM8
      && m.n_cipher_suite.val.case_CipherSuite13._1 == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_AES_128_CCM_8_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MACOnly
          && m.n_cipher_suite.val.case_CipherSuite._2.val.case_MACOnly == Spec_Hash_Definitions_MD5
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_NULL_MD5 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MACOnly
          && m.n_cipher_suite.val.case_CipherSuite._2.val.case_MACOnly == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_NULL_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MACOnly
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MACOnly
            == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_NULL_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Stream
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Stream
              == EverCrypt_RC4_128
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_MD5
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_RC4_128_MD5 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Stream
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Stream
              == EverCrypt_RC4_128
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_RC4_128_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_TDES_EDE_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_3DES_EDE_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES128_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_AES_128_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES256_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_AES_256_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES128_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_AES_128_CBC_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES256_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_AES_256_CBC_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_TDES_EDE_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_TDES_EDE_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES128_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_AES_128_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES128_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_AES_128_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES256_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_AES_256_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES256_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_AES_256_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES128_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES128_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES256_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES256_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Stream
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Stream
                == EverCrypt_RC4_128
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_RC4_128_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_TDES_EDE_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES128_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES128_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES256_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_MtE
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
              == CipherSuite_Block
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
                == EverCrypt_AES256_CBC
                &&
                  m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                  == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES128_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_ECDSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES128_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES256_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_ECDSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES256_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Stream
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Stream
              == EverCrypt_RC4_128
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_MD5
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_RC4_128_MD5 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_TDES_EDE_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES128_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_AES_128_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES256_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA1
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_AES_256_CBC_SHA } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES128_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_AES_128_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_MtE
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.tag
            == CipherSuite_Block
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._0.val.case_Block
              == EverCrypt_AES256_CBC
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_MtE._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_AES_256_CBC_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_AES128_GCM
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_AES_128_GCM_SHA256 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_RSA
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_AES256_GCM
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = Parsers_CipherSuite_TLS_RSA_WITH_AES_256_GCM_SHA384 } }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES128_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES256_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DH
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES128_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DH
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES256_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES128_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES256_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DH
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES128_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DH
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_DSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_AES256_GCM
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_AES128_GCM
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_AES_128_GCM_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_AES256_GCM
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_384
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DH_anon_WITH_AES_256_GCM_SHA384 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_CHACHA20_POLY1305
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = {
              .tag = Parsers_CipherSuite_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
            }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_ECDSA
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_CHACHA20_POLY1305
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = {
              .tag = Parsers_CipherSuite_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
            }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_Some
        &&
          m.n_cipher_suite.val.case_CipherSuite._1.v
          == CipherSuite_RSASIG
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.tag
            == CipherSuite_AEAD
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
              == EverCrypt_CHACHA20_POLY1305
              &&
                m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
                == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_PSK
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_CHACHA20_POLY1305
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_PSK_ECDHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_CHACHA20_POLY1305
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = {
              .tag = Parsers_CipherSuite_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256
            }
          }
        }
      );
  else if
  (
    m.n_cipher_suite.tag
    == CipherSuite_CipherSuite
    &&
      m.n_cipher_suite.val.case_CipherSuite._0
      == CipherSuite_Kex_PSK_DHE
      &&
        m.n_cipher_suite.val.case_CipherSuite._1.tag
        == FStar_Pervasives_Native_None
        &&
          m.n_cipher_suite.val.case_CipherSuite._2.tag
          == CipherSuite_AEAD
          &&
            m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._0
            == EverCrypt_CHACHA20_POLY1305
            &&
              m.n_cipher_suite.val.case_CipherSuite._2.val.case_AEAD._1
              == Spec_Hash_Definitions_SHA2_256
  )
    scrut0 =
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Parsers_CipherSuite_cipherSuite){
          .tag = FStar_Error_Correct,
          .val = {
            .case_Correct = { .tag = Parsers_CipherSuite_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 }
          }
        }
      );
  else
    scrut0 =
      TLSError_fatal__Parsers_CipherSuite_cipherSuite(Parsers_AlertDescription_Illegal_parameter,
        FStar_Error_perror("CipherSuite.fsti",
          (krml_checked_int_t)290,
          "Invoked on a unknown ciphersuite"));
  Parsers_CipherSuite_cipherSuite ite0;
  if (scrut0.tag == FStar_Error_Correct)
    ite0 = scrut0.val.case_Correct;
  else
    ite0 =
      KRML_EABORT(Parsers_CipherSuite_cipherSuite,
        "unreachable (pattern matches are exhaustive in F*)");
  K___Parsers_ProtocolVersion_protocolVersion_FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
  scrut = { .fst = pv, .snd = m.n_server_extensions };
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_ ite;
  if
  (
    scrut.fst.tag
    == Parsers_ProtocolVersion_TLS_1p3
    && scrut.snd.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__Extensions_extension_ *exts = scrut.snd.v;
    ite =
      (
        (FStar_Pervasives_Native_option__Prims_list__Extensions_extension_){
          .tag = FStar_Pervasives_Native_Some,
          .v = FStar_List_Tot_Base_filter__Extensions_extension_(Old_Handshake_not_encryptedExtension,
            exts)
        }
      );
  }
  else
    ite = m.n_server_extensions;
  return
    (
      (HandshakeMessages_hs_msg){
        .tag = HandshakeMessages_ServerHello,
        .val = {
          .case_ServerHello = {
            .sh_protocol_version = pv, .sh_server_random = m.n_server_random,
            .sh_sessionID = m.n_sessionID, .sh_cipher_suite = ite0,
            .sh_compression = { .tag = Parsers_CompressionMethod_NullCompression },
            .sh_extensions = ite
          }
        }
      }
    );
}

typedef struct
K___FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes_s
{
  FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int fst;
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes snd;
}
K___FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes;

static bool
Old_Handshake_consistent_truncation(
  FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int x,
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes y
)
{
  K___FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
  scrut = { .fst = x, .snd = y };
  if
  (
    scrut.fst.tag
    == FStar_Pervasives_Native_None
    && scrut.snd.tag == FStar_Pervasives_Native_None
  )
    return true;
  else if
  (
    scrut.fst.tag
    == FStar_Pervasives_Native_None
    && scrut.snd.tag == FStar_Pervasives_Native_Some
  )
    return false;
  else if
  (
    scrut.fst.tag
    == FStar_Pervasives_Native_Some
    && scrut.snd.tag == FStar_Pervasives_Native_None
  )
    return false;
  else if
  (
    scrut.fst.tag
    == FStar_Pervasives_Native_Some
    && scrut.snd.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__FStar_Bytes_bytes *binders = scrut.snd.v;
    Prims_list__K___FStar_Bytes_bytes_uint32_t *psks = scrut.fst.v.fst;
    return
      FStar_List_Tot_Base_length__FStar_Bytes_bytes___uint32_t(psks)
      == FStar_List_Tot_Base_length__FStar_Bytes_bytes(binders);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
FStar_Pervasives_Native_uu___is_Some__Prims_list_FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t
FStar_List_Tot_Base_nth__FStar_Bytes_bytes___uint32_t(
  Prims_list__K___FStar_Bytes_bytes_uint32_t *l,
  Prims_int n
)
{
  if (l->tag == Prims_Nil)
    return
      (
        (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_uint32_t *tl1 = l->tl;
    K___FStar_Bytes_bytes_uint32_t hd1 = l->hd;
    if (n == (krml_checked_int_t)0)
      return
        (
          (FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return
        FStar_List_Tot_Base_nth__FStar_Bytes_bytes___uint32_t(tl1,
          Prims_op_Subtraction(n, (krml_checked_int_t)1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Pervasives_Native_option__FStar_Bytes_bytes
FStar_List_Tot_Base_nth__FStar_Bytes_bytes(Prims_list__FStar_Bytes_bytes *l, Prims_int n)
{
  if (l->tag == Prims_Nil)
    return
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  else if (l->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *tl1 = l->tl;
    FStar_Bytes_bytes hd1 = l->hd;
    if (n == (krml_checked_int_t)0)
      return
        (
          (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = hd1
          }
        );
    else
      return
        FStar_List_Tot_Base_nth__FStar_Bytes_bytes(tl1,
          Prims_op_Subtraction(n, (krml_checked_int_t)1));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry
TLSError_fatal__FStar_Pervasives_Native_option_CommonDH_keyShareEntry(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

static Old_Handshake_incoming
Old_Handshake_server_ClientHello(
  Old_Handshake_hs_ hs,
  HandshakeMessages_ch offer,
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes obinders
)
{
  Prims_string ite0;
  if (FStar_Pervasives_Native_uu___is_Some__Prims_list_FStar_Bytes_bytes(obinders))
  {
    Prims_list__FStar_Bytes_bytes *ite;
    if (obinders.tag == FStar_Pervasives_Native_Some)
      ite = obinders.v;
    else
      ite =
        KRML_EABORT(Prims_list__FStar_Bytes_bytes *,
          "unreachable (pattern matches are exhaustive in F*)");
    ite0 =
      Prims_strcat(" with ",
        Prims_strcat(Prims_string_of_int(FStar_List_Tot_Base_length__FStar_Bytes_bytes(ite)),
          " binder(s)"));
  }
  else
    ite0 = "";
  Old_Handshake_print(Prims_strcat("Processing ClientHello", ite0));
  FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int
  opsk = Negotiation_find_clientPske(offer);
  if (!Old_Handshake_consistent_truncation(opsk, obinders))
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Illegal_parameter),
              .snd = "unexpected number of binders"
            }
          }
        }
      );
  else
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Negotiation_serverMode
    scrut0 = Negotiation_server_ClientHello(hs.nego, offer, hs.log);
    if (scrut0.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
      return
        ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
    }
    else if
    (
      scrut0.tag
      == FStar_Error_Correct
      && scrut0.val.case_Correct.tag == Negotiation_ServerHelloRetryRequest
    )
    {
      HandshakeMessages_hrr hrr = scrut0.val.case_Correct.val.case_ServerHelloRetryRequest.hrr;
      HandshakeLog_send(hs.log,
        (
          (HandshakeMessages_hs_msg){
            .tag = HandshakeMessages_HelloRetryRequest,
            .val = { .case_HelloRetryRequest = hrr }
          }
        ));
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InAck,
            .val = { .case_InAck = { .next_keys = false, .complete = false } }
          }
        );
    }
    else if
    (scrut0.tag == FStar_Error_Correct && scrut0.val.case_Correct.tag == Negotiation_ServerMode)
    {
      Prims_list__Extensions_extension_ *app_exts = scrut0.val.case_Correct.val.case_ServerMode._2;
      Negotiation_mode mode = scrut0.val.case_Correct.val.case_ServerMode._0;
      TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
      Parsers_ProtocolVersion_protocolVersion pv = mode.n_protocol_version;
      FStar_Bytes_bytes cr = mode.n_offer.ch_client_random;
      Spec_Hash_Definitions_hash_alg ha = Negotiation_hashAlg(mode);
      if (Negotiation_resume_12(mode))
      {
        Old_Handshake_print("accepted TLS 1.2 resumption");
        CipherSuite_kexAlg ka = Negotiation_kexAlg(mode);
        HandshakeLog_setParams(hs.log,
          pv,
          ha,
          (
            (FStar_Pervasives_Native_option__CipherSuite_kexAlg){
              .tag = FStar_Pervasives_Native_Some,
              .v = ka
            }
          ),
          ((FStar_Pervasives_Native_option__CommonDH_group_){ .tag = FStar_Pervasives_Native_None }));
        FStar_Pervasives_Native_option__FStar_Bytes_bytes
        scrut0 = Negotiation_find_sessionTicket(offer);
        if (scrut0.tag == FStar_Pervasives_Native_Some)
        {
          FStar_Bytes_bytes tid = scrut0.v;
          FStar_Pervasives_Native_option__K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_TLSInfo_msId_FStar_Bytes_bytes
          scrut = Ticket_check_ticket12(tid);
          if (scrut.tag == FStar_Pervasives_Native_Some)
          {
            FStar_Bytes_bytes ms = scrut.v.f4;
            TLSInfo_msId msId = scrut.v.f3;
            bool ems = scrut.v.thd;
            CipherSuite_cipherSuite_ cs = scrut.v.snd;
            Parsers_ProtocolVersion_protocolVersion pv1 = scrut.v.fst;
            Old_KeySchedule_recordInstance
            adk = Old_KeySchedule_ks_server_12_resume(hs.ks, cr, pv1, cs, ems, msId, ms);
            Old_Handshake_register(hs, adk);
            FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Negotiation_mode
            scrut =
              Negotiation_server_ServerShare(hs.nego,
                (
                  (FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
                    .tag = FStar_Pervasives_Native_None
                  }
                ),
                app_exts);
            if (scrut.tag == FStar_Error_Error)
            {
              K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
              return
                (
                  (Old_Handshake_incoming){
                    .tag = Old_Handshake_InError,
                    .val = { .case_InError = z }
                  }
                );
            }
            else if (scrut.tag == FStar_Error_Correct)
            {
              Negotiation_mode mode1 = scrut.val.case_Correct;
              FStar_Bytes_bytes digestSessionTicket;
              if (Negotiation_sendticket_12(mode1))
              {
                HandshakeLog_send(hs.log, Old_Handshake_serverHello(mode1));
                HandshakeMessages_sticket
                ticket = { .sticket_lifetime = cfg.max_ticket_age, .sticket_ticket = tid };
                digestSessionTicket =
                  HandshakeLog_send_tag(ha,
                    hs.log,
                    (
                      (HandshakeMessages_hs_msg){
                        .tag = HandshakeMessages_NewSessionTicket,
                        .val = { .case_NewSessionTicket = ticket }
                      }
                    ));
              }
              else
                digestSessionTicket =
                  HandshakeLog_send_tag(ha,
                    hs.log,
                    Old_Handshake_serverHello(mode1));
              FStar_Bytes_bytes fink = Old_KeySchedule_ks_12_finished_key(hs.ks);
              FStar_Bytes_bytes
              svd = TLSPRF_finished12(ha, fink, TLSConstants_Server, digestSessionTicket);
              FStar_Bytes_bytes
              digestServerFinished =
                HandshakeLog_send_CCS_tag(ha,
                  hs.log,
                  (
                    (HandshakeMessages_hs_msg){
                      .tag = HandshakeMessages_Finished,
                      .val = { .case_Finished = svd }
                    }
                  ),
                  true);
              hs.state[0U] =
                (
                  (Old_Handshake_machineState){
                    .tag = Old_Handshake_S_Wait_CCS2,
                    .val = { .case_S_Wait_CCS2 = digestServerFinished }
                  }
                );
              return
                (
                  (Old_Handshake_incoming){
                    .tag = Old_Handshake_InAck,
                    .val = { .case_InAck = { .next_keys = false, .complete = false } }
                  }
                );
            }
            else
            {
              KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        CipherSuite_cipherSuite_ cs = mode.n_cipher_suite;
        FStar_Pervasives_Native_option__Prims_dtuple2__CommonDH_group__CommonDH_pre_share_
        g_gx = mode.n_client_share;
        FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry
        key_share_result;
        if
        (
          __eq__Parsers_ProtocolVersion_protocolVersion(pv,
            ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
        )
          if (mode.n_pski.tag == FStar_Pervasives_Native_None)
          {
            K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
            scrut =
              Old_KeySchedule_ks_server_13_init(hs.ks,
                cr,
                cs,
                (
                  (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                    .tag = FStar_Pervasives_Native_None
                  }
                ),
                g_gx);
            if (scrut.snd.tag == FStar_Pervasives_Native_None)
            {
              FStar_Pervasives_Native_option__CommonDH_keyShareEntry server_share = scrut.fst;
              key_share_result =
                (
                  (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
                    .tag = FStar_Error_Correct,
                    .val = { .case_Correct = server_share }
                  }
                );
            }
            else
              key_share_result =
                KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                  "unreachable (pattern matches are exhaustive in F*)");
          }
          else if (mode.n_pski.tag == FStar_Pervasives_Native_Some)
          {
            Prims_int i1 = mode.n_pski.v;
            Old_Handshake_print(Prims_strcat("accepted TLS 1.3 psk #", Prims_string_of_int(i1)));
            if (opsk.tag == FStar_Pervasives_Native_Some)
            {
              Prims_int tlen = opsk.v.snd;
              Prims_list__K___FStar_Bytes_bytes_uint32_t *psks = opsk.v.fst;
              FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_uint32_t
              scrut0 = FStar_List_Tot_Base_nth__FStar_Bytes_bytes___uint32_t(psks, i1);
              if (scrut0.tag == FStar_Pervasives_Native_Some)
              {
                FStar_Bytes_bytes id1 = scrut0.v.fst;
                Prims_list__FStar_Bytes_bytes *ite;
                if (obinders.tag == FStar_Pervasives_Native_Some)
                  ite = obinders.v;
                else
                  ite =
                    KRML_EABORT(Prims_list__FStar_Bytes_bytes *,
                      "unreachable (pattern matches are exhaustive in F*)");
                FStar_Pervasives_Native_option__FStar_Bytes_bytes
                scrut0 = FStar_List_Tot_Base_nth__FStar_Bytes_bytes(ite, i1);
                if (scrut0.tag == FStar_Pervasives_Native_Some)
                {
                  FStar_Bytes_bytes tag = scrut0.v;
                  K___FStar_Pervasives_Native_option__CommonDH_keyShareEntry_FStar_Pervasives_Native_option__Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key
                  scrut =
                    Old_KeySchedule_ks_server_13_init(hs.ks,
                      cr,
                      cs,
                      (
                        (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                          .tag = FStar_Pervasives_Native_Some,
                          .v = id1
                        }
                      ),
                      g_gx);
                  if (scrut.snd.tag == FStar_Pervasives_Native_Some)
                  {
                    Prims_dtuple2__TLSInfo_pre_binderId_Old_HMAC_UFCMA_key binderKey = scrut.snd.v;
                    FStar_Pervasives_Native_option__CommonDH_keyShareEntry server_share = scrut.fst;
                    if (Old_Handshake_verify_binder(hs, binderKey, tag, tlen))
                      key_share_result =
                        (
                          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
                            .tag = FStar_Error_Correct,
                            .val = { .case_Correct = server_share }
                          }
                        );
                    else
                      key_share_result =
                        TLSError_fatal__FStar_Pervasives_Native_option_CommonDH_keyShareEntry(Parsers_AlertDescription_Bad_record_mac,
                          "binder verification failed");
                  }
                  else
                    key_share_result =
                      KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                        "unreachable (pattern matches are exhaustive in F*)");
                }
                else
                  key_share_result =
                    KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                      "unreachable (pattern matches are exhaustive in F*)");
              }
              else
                key_share_result =
                  KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                    "unreachable (pattern matches are exhaustive in F*)");
            }
            else
              key_share_result =
                KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                  "unreachable (pattern matches are exhaustive in F*)");
          }
          else
            key_share_result =
              KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                "unreachable (pattern matches are exhaustive in F*)");
        else
          switch (Negotiation_kexAlg(mode))
          {
            case CipherSuite_Kex_DHE:
              {
                FStar_Pervasives_Native_option__CommonDH_group_
                scrut = Negotiation_chosenGroup(mode);
                if (scrut.tag == FStar_Pervasives_Native_Some)
                {
                  CommonDH_group_ g1 = scrut.v;
                  CommonDH_pre_share_
                  gy =
                    Old_KeySchedule_ks_server_12_init_dh(hs.ks,
                      cr,
                      pv,
                      cs,
                      Negotiation_emsFlag(mode),
                      g1);
                  key_share_result =
                    (
                      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
                        .tag = FStar_Error_Correct,
                        .val = {
                          .case_Correct = {
                            .tag = FStar_Pervasives_Native_Some,
                            .v = {
                              .tag = CommonDH_Share,
                              .val = { .case_Share = { .g = g1, ._1 = gy } }
                            }
                          }
                        }
                      }
                    );
                }
                else
                  key_share_result =
                    KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                      "unreachable (pattern matches are exhaustive in F*)");
                break;
              }
            case CipherSuite_Kex_ECDHE:
              {
                FStar_Pervasives_Native_option__CommonDH_group_
                scrut = Negotiation_chosenGroup(mode);
                if (scrut.tag == FStar_Pervasives_Native_Some)
                {
                  CommonDH_group_ g1 = scrut.v;
                  CommonDH_pre_share_
                  gy =
                    Old_KeySchedule_ks_server_12_init_dh(hs.ks,
                      cr,
                      pv,
                      cs,
                      Negotiation_emsFlag(mode),
                      g1);
                  key_share_result =
                    (
                      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry){
                        .tag = FStar_Error_Correct,
                        .val = {
                          .case_Correct = {
                            .tag = FStar_Pervasives_Native_Some,
                            .v = {
                              .tag = CommonDH_Share,
                              .val = { .case_Share = { .g = g1, ._1 = gy } }
                            }
                          }
                        }
                      }
                    );
                }
                else
                  key_share_result =
                    KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__CommonDH_keyShareEntry,
                      "unreachable (pattern matches are exhaustive in F*)");
                break;
              }
            default:
              {
                key_share_result =
                  TLSError_fatal__FStar_Pervasives_Native_option_CommonDH_keyShareEntry(Parsers_AlertDescription_Handshake_failure,
                    "Unsupported RSA key exchange");
              }
          }
        if (key_share_result.tag == FStar_Error_Error)
        {
          K___Parsers_Alert_alert_Prims_string z = key_share_result.val.case_Error;
          return
            ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
        }
        else if (key_share_result.tag == FStar_Error_Correct)
        {
          FStar_Pervasives_Native_option__CommonDH_keyShareEntry
          optional_server_share = key_share_result.val.case_Correct;
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_Negotiation_mode
          scrut = Negotiation_server_ServerShare(hs.nego, optional_server_share, app_exts);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            return
              (
                (Old_Handshake_incoming){
                  .tag = Old_Handshake_InError,
                  .val = { .case_InError = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            Negotiation_mode mode1 = scrut.val.case_Correct;
            CipherSuite_kexAlg ka = Negotiation_kexAlg(mode1);
            HandshakeLog_setParams(hs.log,
              pv,
              ha,
              (
                (FStar_Pervasives_Native_option__CipherSuite_kexAlg){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = ka
                }
              ),
              (
                (FStar_Pervasives_Native_option__CommonDH_group_){
                  .tag = FStar_Pervasives_Native_None
                }
              ));
            Spec_Hash_Definitions_hash_alg
            ha1 = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode1.n_cipher_suite);
            FStar_Bytes_bytes digestClientHelloBinders = HandshakeLog_hash_tag(ha1, hs.log);
            FStar_Bytes_bytes
            digestServerHello = HandshakeLog_send_tag(ha1, hs.log, Old_Handshake_serverHello(mode1));
            if
            (
              __eq__Parsers_ProtocolVersion_protocolVersion(pv,
                (
                  (Parsers_ProtocolVersion_protocolVersion){
                    .tag = Parsers_ProtocolVersion_TLS_1p3
                  }
                ))
            )
            {
              bool zeroing = Negotiation_zeroRTT(mode1);
              bool reject = Negotiation_zeroRTToffer(mode1.n_offer) && !zeroing;
              if (zeroing)
              {
                K___FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes_Old_KeySchedule_recordInstance
                scrut = Old_KeySchedule_ks_server_13_0rtt_key(hs.ks, digestClientHelloBinders);
                FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
                early_exporter_secret = scrut.fst;
                Old_KeySchedule_recordInstance zero_keys = scrut.snd;
                Old_Handshake_export(hs, early_exporter_secret);
                Old_Handshake_register(hs, zero_keys);
                Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
              }
              HandshakeLog_send_signals(hs.log,
                (
                  (FStar_Pervasives_Native_option__K___bool_bool_bool){
                    .tag = FStar_Pervasives_Native_Some,
                    .v = { .fst = false, .snd = zeroing, .thd = reject }
                  }
                ),
                false);
              Old_Handshake_print("derive handshake keys");
              Old_KeySchedule_recordInstance
              hs_keys = Old_KeySchedule_ks_server_13_sh(hs.ks, digestServerHello);
              Old_Handshake_register(hs, hs_keys);
              hs.state[0U] =
                ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Sent_ServerHello });
              return
                (
                  (Old_Handshake_incoming){
                    .tag = Old_Handshake_InAck,
                    .val = { .case_InAck = { .next_keys = zeroing, .complete = false } }
                  }
                );
            }
            else
              return Old_Handshake_server_ServerHelloDone(hs);
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static Old_Handshake_incoming
Old_Handshake_server_ClientCCS1(
  Old_Handshake_hs_ hs,
  HandshakeMessages_kex_c cke,
  FStar_Bytes_bytes digestCCS1
)
{
  Old_Handshake_print("process Client CCS");
  if (cke.tag == HandshakeMessages_KEX_C_RSA)
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = FStar_Error_perror("Old.Handshake.fst",
                (krml_checked_int_t)892,
                "Expected DHE/ECDHE CKE")
            }
          }
        }
      );
  else if (cke.tag == HandshakeMessages_KEX_C_DH)
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = FStar_Error_perror("Old.Handshake.fst",
                (krml_checked_int_t)892,
                "Expected DHE/ECDHE CKE")
            }
          }
        }
      );
  else if (cke.tag == HandshakeMessages_KEX_C_DHE)
  {
    FStar_Bytes_bytes gyb = cke.val.case_KEX_C_DHE;
    Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
    if (mode.n_server_share.tag == FStar_Pervasives_Native_Some)
    {
      CommonDH_group_ g1 = mode.n_server_share.v.fst;
      FStar_Pervasives_Native_option__CommonDH_pre_share_ scrut = CommonDH_parse(g1, gyb);
      if (scrut.tag == FStar_Pervasives_Native_None)
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InError,
              .val = {
                .case_InError = {
                  .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
                  .snd = FStar_Error_perror("Old.Handshake.fst",
                    (krml_checked_int_t)900,
                    "Cannot parse client share in CKE")
                }
              }
            }
          );
      else if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        CommonDH_pre_share_ gy = scrut.v;
        Old_KeySchedule_recordInstance
        app_keys =
          Old_KeySchedule_ks_server_12_cke_dh(hs.ks,
            ((Prims_dtuple2__CommonDH_group__CommonDH_pre_share_){ .fst = g1, .snd = gy }),
            digestCCS1);
        Old_Handshake_register(hs, app_keys);
        Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
        hs.state[0U] =
          (
            (Old_Handshake_machineState){
              .tag = Old_Handshake_S_Wait_Finished1,
              .val = { .case_S_Wait_Finished1 = digestCCS1 }
            }
          );
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = true, .complete = false } }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (cke.tag == HandshakeMessages_KEX_C_ECDHE)
  {
    FStar_Bytes_bytes gyb = cke.val.case_KEX_C_ECDHE;
    Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
    if (mode.n_server_share.tag == FStar_Pervasives_Native_Some)
    {
      CommonDH_group_ g1 = mode.n_server_share.v.fst;
      FStar_Pervasives_Native_option__CommonDH_pre_share_ scrut = CommonDH_parse(g1, gyb);
      if (scrut.tag == FStar_Pervasives_Native_None)
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InError,
              .val = {
                .case_InError = {
                  .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
                  .snd = FStar_Error_perror("Old.Handshake.fst",
                    (krml_checked_int_t)900,
                    "Cannot parse client share in CKE")
                }
              }
            }
          );
      else if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        CommonDH_pre_share_ gy = scrut.v;
        Old_KeySchedule_recordInstance
        app_keys =
          Old_KeySchedule_ks_server_12_cke_dh(hs.ks,
            ((Prims_dtuple2__CommonDH_group__CommonDH_pre_share_){ .fst = g1, .snd = gy }),
            digestCCS1);
        Old_Handshake_register(hs, app_keys);
        Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
        hs.state[0U] =
          (
            (Old_Handshake_machineState){
              .tag = Old_Handshake_S_Wait_Finished1,
              .val = { .case_S_Wait_Finished1 = digestCCS1 }
            }
          );
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = true, .complete = false } }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_server_ClientFinished(
  Old_Handshake_hs_ hs,
  FStar_Bytes_bytes cvd,
  FStar_Bytes_bytes digestCCS,
  FStar_Bytes_bytes digestClientFinished
)
{
  Old_Handshake_print("Process Client Finished");
  FStar_Bytes_bytes fink = Old_KeySchedule_ks_12_finished_key(hs.ks);
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
  Parsers_ProtocolVersion_protocolVersion pv = mode.n_protocol_version;
  CipherSuite_cipherSuite_ cs = mode.n_cipher_suite;
  Spec_Hash_Definitions_hash_alg
  ha = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode.n_cipher_suite);
  FStar_Bytes_bytes expected_cvd = TLSPRF_finished12(ha, fink, TLSConstants_Client, digestCCS);
  if (__eq__FStar_Bytes_bytes(cvd, expected_cvd))
  {
    FStar_Bytes_bytes digestTicket;
    if (Negotiation_sendticket_12(mode))
    {
      K___TLSInfo_msId_FStar_Bytes_bytes scrut = Old_KeySchedule_ks_12_ms(hs.ks);
      TLSInfo_msId msId = scrut.fst;
      FStar_Bytes_bytes ms = scrut.snd;
      Ticket_ticket
      ticket =
        {
          .tag = Ticket_Ticket12,
          .val = {
            .case_Ticket12 = {
              .pv = pv, .cs = cs, .ems = Negotiation_emsFlag(mode), .msId = msId, .ms = ms
            }
          }
        };
      HandshakeMessages_sticket
      ticket1 =
        {
          .sticket_lifetime = cfg.max_ticket_age,
          .sticket_ticket = Ticket_create_ticket(false, ticket)
        };
      digestTicket =
        HandshakeLog_send_tag(ha,
          hs.log,
          (
            (HandshakeMessages_hs_msg){
              .tag = HandshakeMessages_NewSessionTicket,
              .val = { .case_NewSessionTicket = ticket1 }
            }
          ));
    }
    else
      digestTicket = digestClientFinished;
    FStar_Bytes_bytes svd = TLSPRF_finished12(ha, fink, TLSConstants_Server, digestTicket);
    FStar_Bytes_bytes
    unused_digest =
      HandshakeLog_send_CCS_tag(ha,
        hs.log,
        (
          (HandshakeMessages_hs_msg){
            .tag = HandshakeMessages_Finished,
            .val = { .case_Finished = svd }
          }
        ),
        true);
    hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Complete });
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  }
  else
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = Prims_strcat("Finished MAC did not verify: expected digest ",
                FStar_Bytes_print_bytes(digestClientFinished))
            }
          }
        }
      );
}

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
Old_Handshake_server_ServerFinished_13(Old_Handshake_hs_ hs, TLSInfo_id i1)
{
  Old_Handshake_print("prepare Server Finished");
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
  CipherSuite_kexAlg kex = Negotiation_kexAlg(mode);
  Parsers_ProtocolVersion_protocolVersion pv = mode.n_protocol_version;
  CipherSuite_cipherSuite_ cs = mode.n_cipher_suite;
  FStar_Pervasives_Native_option__Prims_list__Extensions_extension_
  x0 = mode.n_server_extensions;
  Prims_list__Extensions_extension_ *exts;
  if (x0.tag == FStar_Pervasives_Native_Some)
    exts = x0.v;
  else
    exts =
      KRML_EABORT(Prims_list__Extensions_extension_ *,
        "unreachable (pattern matches are exhaustive in F*)");
  Hashing_Spec_tls_alg sh_alg = TLSConstants_sessionHashAlg(pv, cs);
  Spec_Hash_Definitions_hash_alg halg = TLSConstants_verifyDataHashAlg_of_ciphersuite(cs);
  Prims_list__Extensions_extension_
  *eexts = FStar_List_Tot_Base_filter__Extensions_extension_(Extensions_encryptedExtension, exts);
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes digestFinished;
  switch (kex)
  {
    case CipherSuite_Kex_ECDHE:
      {
        HandshakeLog_send(hs.log,
          (
            (HandshakeMessages_hs_msg){
              .tag = HandshakeMessages_EncryptedExtensions,
              .val = { .case_EncryptedExtensions = eexts }
            }
          ));
        if (mode.n_server_cert.tag == FStar_Pervasives_Native_Some)
        {
          Prims_list__K___FStar_Bytes_bytes_Prims_list__Extensions_extension_
          *chain = mode.n_server_cert.v.fst;
          FStar_Bytes_bytes
          digestSig =
            HandshakeLog_send_tag(halg,
              hs.log,
              (
                (HandshakeMessages_hs_msg){
                  .tag = HandshakeMessages_Certificate13,
                  .val = {
                    .case_Certificate13 = {
                      .crt_request_context = FStar_Bytes_empty_bytes,
                      .crt_chain13 = chain
                    }
                  }
                }
              ));
          FStar_Bytes_bytes
          tbs =
            Negotiation_to_be_signed(pv,
              TLSConstants_Server,
              (
                (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                  .tag = FStar_Pervasives_Native_None
                }
              ),
              digestSig);
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeMessages_signature
          scrut = Negotiation_sign(hs.r, hs.nego, tbs);
          if (scrut.tag == FStar_Error_Error)
          {
            K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
            digestFinished =
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes){
                  .tag = FStar_Error_Error,
                  .val = { .case_Error = z }
                }
              );
          }
          else if (scrut.tag == FStar_Error_Correct)
          {
            HandshakeMessages_signature signature = scrut.val.case_Correct;
            digestFinished =
              (
                (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes){
                  .tag = FStar_Error_Correct,
                  .val = {
                    .case_Correct = HandshakeLog_send_tag(halg,
                      hs.log,
                      (
                        (HandshakeMessages_hs_msg){
                          .tag = HandshakeMessages_CertificateVerify,
                          .val = { .case_CertificateVerify = signature }
                        }
                      ))
                  }
                }
              );
          }
          else
            digestFinished =
              KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes,
                "unreachable (pattern matches are exhaustive in F*)");
        }
        else
          digestFinished =
            KRML_EABORT(FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes,
              "unreachable (pattern matches are exhaustive in F*)");
        break;
      }
    default:
      {
        digestFinished =
          (
            (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Bytes_bytes){
              .tag = FStar_Error_Correct,
              .val = {
                .case_Correct = HandshakeLog_send_tag(halg,
                  hs.log,
                  (
                    (HandshakeMessages_hs_msg){
                      .tag = HandshakeMessages_EncryptedExtensions,
                      .val = { .case_EncryptedExtensions = eexts }
                    }
                  ))
              }
            }
          );
      }
  }
  if (digestFinished.tag == FStar_Error_Correct)
  {
    FStar_Bytes_bytes digestFinished1 = digestFinished.val.case_Correct;
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
    scrut0 = Old_KeySchedule_ks_server_13_server_finished(hs.ks);
    TLSInfo_pre_finishedId *sfinId = scrut0.fst;
    Old_HMAC_UFCMA_key sfin_key = scrut0.snd;
    FStar_Bytes_bytes
    svd =
      Old_HMAC_UFCMA_mac((
          (Old_HMAC_UFCMA_id){
            .tag = Old_HMAC_UFCMA_HMAC_Finished,
            .val = { .case_HMAC_Finished = sfinId }
          }
        ),
        sfin_key,
        digestFinished1);
    FStar_Bytes_bytes
    digestServerFinished =
      HandshakeLog_send_tag(halg,
        hs.log,
        (
          (HandshakeMessages_hs_msg){
            .tag = HandshakeMessages_Finished,
            .val = { .case_Finished = svd }
          }
        ));
    K___Old_KeySchedule_recordInstance_FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    scrut = Old_KeySchedule_ks_server_13_sf(hs.ks, digestServerFinished);
    Old_KeySchedule_recordInstance app_keys = scrut.fst;
    FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_exportId_FStar_Bytes_bytes
    exporter_master_secret = scrut.snd;
    Old_Handshake_export(hs, exporter_master_secret);
    Old_Handshake_register(hs, app_keys);
    HandshakeLog_send_signals(hs.log,
      (
        (FStar_Pervasives_Native_option__K___bool_bool_bool){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = true, .snd = false, .thd = false }
        }
      ),
      false);
    Old_Handshake_machineState uu____0;
    if (Negotiation_zeroRTT(mode) && !cfg.is_quic)
      uu____0 = ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Wait_EOED });
    else
    {
      Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
      uu____0 =
        (
          (Old_Handshake_machineState){
            .tag = Old_Handshake_S_Wait_Finished2,
            .val = { .case_S_Wait_Finished2 = digestServerFinished }
          }
        );
    }
    hs.state[0U] = uu____0;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___){
          .tag = FStar_Error_Correct
        }
      );
  }
  else if (digestFinished.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = digestFinished.val.case_Error;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___){
          .tag = FStar_Error_Error,
          ._0 = z
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_server_EOED(Old_Handshake_hs_ hs, FStar_Bytes_bytes digestEOED)
{
  Old_Handshake_print("Process EOED (increment reader to HS key)");
  Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
  hs.state[0U] =
    (
      (Old_Handshake_machineState){
        .tag = Old_Handshake_S_Wait_Finished2,
        .val = { .case_S_Wait_Finished2 = digestEOED }
      }
    );
  return
    (
      (Old_Handshake_incoming){
        .tag = Old_Handshake_InAck,
        .val = { .case_InAck = { .next_keys = false, .complete = false } }
      }
    );
}

static void Old_Handshake_server_Ticket(Old_Handshake_hs_ hs, FStar_Bytes_bytes app_data)
{
  FStar_Pervasives_dtuple3__TLSInfo_logInfo_TLSInfo_pre_rmsId_FStar_Bytes_bytes
  scrut0 = Old_KeySchedule_ks_server_13_rms(hs.ks);
  TLSInfo_logInfo li = scrut0._1;
  TLSInfo_pre_rmsId *rmsid = scrut0._2;
  FStar_Bytes_bytes rms = scrut0._3;
  TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  CipherSuite_cipherSuite_ cs = mode.n_cipher_suite;
  FStar_Bytes_bytes age_add = Random_sample32((uint32_t)4U);
  uint32_t age_add1 = Parse_uint32_of_bytes(age_add);
  uint32_t now1 = FStar_UInt32_uint_to_t(FStar_Date_secondsFromDawn());
  Ticket_ticket
  ticket =
    {
      .tag = Ticket_Ticket13,
      .val = {
        .case_Ticket13 = {
          .cs = cs, .li = li, .rmsId = rmsid, .rms = rms, .nonce = FStar_Bytes_empty_bytes,
          .ticket_created = now1, .ticket_age_add = age_add1, .custom = app_data
        }
      }
    };
  FStar_Bytes_bytes tb = Ticket_create_ticket(false, ticket);
  Old_Handshake_print(Prims_strcat("Sending ticket: ", FStar_Bytes_print_bytes(tb)));
  Old_Handshake_print(Prims_strcat("Application data in ticket: ",
      FStar_Bytes_print_bytes(app_data)));
  Prims_list__Extensions_extension_ *ticket_ext;
  if (cfg.max_early_data.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t max_ed = cfg.max_early_data.v;
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf0 = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf0[0U]
    =
      (
        (Prims_list__Extensions_extension_){
          .tag = Prims_Cons,
          .hd = {
            .tag = Extensions_E_early_data,
            .val = { .case_E_early_data = { .tag = FStar_Pervasives_Native_Some, .v = max_ed } }
          },
          .tl = buf
        }
      );
    ticket_ext = buf0;
  }
  else if (cfg.max_early_data.tag == FStar_Pervasives_Native_None)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__Extensions_extension_), (uint32_t)1U);
    Prims_list__Extensions_extension_
    *buf = KRML_HOST_MALLOC(sizeof (Prims_list__Extensions_extension_));
    buf[0U] = ((Prims_list__Extensions_extension_){ .tag = Prims_Nil });
    ticket_ext = buf;
  }
  else
    ticket_ext =
      KRML_EABORT(Prims_list__Extensions_extension_ *,
        "unreachable (pattern matches are exhaustive in F*)");
  K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = FStar_Bytes_split(tb, (uint32_t)12U);
  FStar_Bytes_bytes tnonce = scrut.fst;
  HandshakeLog_send(hs.log,
    (
      (HandshakeMessages_hs_msg){
        .tag = HandshakeMessages_NewSessionTicket13,
        .val = {
          .case_NewSessionTicket13 = {
            .ticket13_lifetime = cfg.max_ticket_age, .ticket13_age_add = age_add1,
            .ticket13_nonce = tnonce, .ticket13_ticket = tb, .ticket13_extensions = ticket_ext
          }
        }
      }
    ));
}

typedef struct K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes_s
{
  HandshakeMessages_crt13 fst;
  HandshakeMessages_signature snd;
  FStar_Bytes_bytes thd;
}
K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes;

typedef struct
FStar_Pervasives_Native_option__K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes_s
{
  FStar_Pervasives_Native_option__Prims_string_tags tag;
  K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes v;
}
FStar_Pervasives_Native_option__K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes;

static Old_Handshake_incoming
Old_Handshake_server_ClientFinished_13(
  Old_Handshake_hs_ hs,
  FStar_Bytes_bytes f,
  FStar_Bytes_bytes digestBeforeClientFinished,
  FStar_Bytes_bytes digestClientFinished,
  FStar_Pervasives_Native_option__K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes
  clientAuth
)
{
  Old_Handshake_print("Process Client Finished");
  if (clientAuth.tag == FStar_Pervasives_Native_Some)
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Internal_error),
              .snd = FStar_Error_perror("Old.Handshake.fst",
                (krml_checked_int_t)1056,
                "Client CertificateVerify validation not implemented")
            }
          }
        }
      );
  else if (clientAuth.tag == FStar_Pervasives_Native_None)
  {
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
    scrut0 = Old_KeySchedule_ks_server_13_client_finished(hs.ks);
    TLSInfo_pre_finishedId *i1 = scrut0.fst;
    Old_HMAC_UFCMA_key cfin_key = scrut0.snd;
    Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
    if
    (
      Old_HMAC_UFCMA_verify((
          (Old_HMAC_UFCMA_id){
            .tag = Old_HMAC_UFCMA_HMAC_Finished,
            .val = { .case_HMAC_Finished = i1 }
          }
        ),
        cfin_key,
        digestBeforeClientFinished,
        f)
    )
    {
      Old_KeySchedule_ks_server_13_cf(hs.ks, digestClientFinished);
      hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Complete });
      TLSConstants_config cfg = Negotiation_local_config(hs.r, hs.nego);
      Prims_list__Extensions_psk_kex *scrut = Negotiation_find_psk_key_exchange_modes(mode.n_offer);
      if (scrut->tag == Prims_Nil)
        Old_Handshake_print("Not sending a ticket: no PSK key exchange mode advertised");
      else if (FStar_Pervasives_Native_uu___is_Some__FStar_Bytes_bytes(cfg.send_ticket))
      {
        FStar_Bytes_bytes ite;
        if (cfg.send_ticket.tag == FStar_Pervasives_Native_Some)
          ite = cfg.send_ticket.v;
        else
          ite = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
        Old_Handshake_server_Ticket(hs, ite);
      }
      Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InAck,
            .val = { .case_InAck = { .next_keys = true, .complete = true } }
          }
        );
    }
    else
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InError,
            .val = {
              .case_InError = {
                .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
                .snd = Prims_strcat("Finished MAC did not verify: expected digest ",
                  FStar_Bytes_print_bytes(digestClientFinished))
              }
            }
          }
        );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Old_Handshake_hs_ Old_Handshake_create(TLSConstants_config cfg, TLSConstants_role role)
{
  HandshakeLog_state
  *log1 =
    HandshakeLog_create((
        (FStar_Pervasives_Native_option__Parsers_ProtocolVersion_protocolVersion){
          .tag = FStar_Pervasives_Native_None
        }
      ));
  K___Old_KeySchedule_ks_FStar_Bytes_bytes scrut = Old_KeySchedule_create(role, cfg.is_quic);
  Old_KeySchedule_ks ks = scrut.fst;
  FStar_Bytes_bytes nonce1 = scrut.snd;
  Negotiation_t nego = Negotiation_create(role, cfg, nonce1);
  Old_Epochs_epochs epochs = Old_Epochs_create(nonce1);
  Old_Handshake_machineState ite;
  if (__eq__TLSConstants_role(role, TLSConstants_Client))
    ite = ((Old_Handshake_machineState){ .tag = Old_Handshake_C_Idle });
  else
    ite = ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Idle });
  KRML_CHECK_SIZE(sizeof (Old_Handshake_machineState), (uint32_t)1U);
  Old_Handshake_machineState *state = KRML_HOST_MALLOC(sizeof (Old_Handshake_machineState));
  state[0U] = ite;
  return
    (
      (Old_Handshake_hs_){
        .r = role,
        .nego = nego,
        .log = log1,
        .ks = ks,
        .epochs = epochs,
        .state = state
      }
    );
}

bool Old_Handshake_rehandshake(Old_Handshake_hs_ s, TLSConstants_config c)
{
  KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "rehandshake: not yet implemented");
  KRML_HOST_EXIT(255U);
}

bool Old_Handshake_rekey(Old_Handshake_hs_ s, TLSConstants_config c)
{
  KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "rekey: not yet implemented");
  KRML_HOST_EXIT(255U);
}

bool Old_Handshake_send_ticket(Old_Handshake_hs_ hs, FStar_Bytes_bytes app_data)
{
  if (Old_Handshake_is_post_handshake(hs))
  {
    Old_Handshake_server_Ticket(hs, app_data);
    return true;
  }
  else
    return false;
}

FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets
Old_Handshake_rekey_secrets(Old_Handshake_hs_ hs)
{
  return Old_KeySchedule_ks_13_rekey_secrets(hs.ks);
}

bool Old_Handshake_request(Old_Handshake_hs_ s, TLSConstants_config c)
{
  KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "request: not yet implemented");
  KRML_HOST_EXIT(255U);
}

void Old_Handshake_invalidateSession(Old_Handshake_hs_ hs)
{
  
}

typedef struct K___HandshakeLog_outgoing_Old_Handshake_machineState_s
{
  HandshakeLog_outgoing fst;
  Old_Handshake_machineState snd;
}
K___HandshakeLog_outgoing_Old_Handshake_machineState;

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
Old_Handshake_next_fragment_bounded(Old_Handshake_hs_ hs, TLSInfo_id i1, Prims_int max1)
{
  Old_Handshake_print("next_fragment");
  HandshakeLog_outgoing outgoing = HandshakeLog_write_at_most(hs.log, i1, max1);
  K___HandshakeLog_outgoing_Old_Handshake_machineState
  scrut = { .fst = outgoing, .snd = hs.state[0U] };
  if
  (
    scrut.fst.send_first.tag
    == FStar_Pervasives_Native_None
    &&
      scrut.fst.next_keys.tag
      == FStar_Pervasives_Native_None
      && scrut.fst.complete == false && scrut.snd.tag == Old_Handshake_C_Idle
  )
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
    scrut = Old_Handshake_client_ClientHello(hs, i1);
    if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut._0;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut.tag == FStar_Error_Correct)
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = HandshakeLog_write_at_most(hs.log, i1, max1) }
          }
        );
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if
  (
    scrut.fst.send_first.tag
    == FStar_Pervasives_Native_None
    &&
      scrut.fst.next_keys.tag
      == FStar_Pervasives_Native_None
      && scrut.fst.complete == false && scrut.snd.tag == Old_Handshake_S_Sent_ServerHello
  )
  {
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
    scrut = Old_Handshake_server_ServerFinished_13(hs, i1);
    if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut._0;
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing){
            .tag = FStar_Error_Error,
            .val = { .case_Error = z }
          }
        );
    }
    else if (scrut.tag == FStar_Error_Correct)
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing){
            .tag = FStar_Error_Correct,
            .val = { .case_Correct = HandshakeLog_write_at_most(hs.log, i1, max1) }
          }
        );
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else if
  (
    scrut.fst.send_first.tag
    == FStar_Pervasives_Native_None
    &&
      scrut.fst.next_keys.tag
      == FStar_Pervasives_Native_None
      && scrut.fst.complete == false && scrut.snd.tag == Old_Handshake_C_Sent_EOED
  )
  {
    Prims_dtuple2__TLSInfo_pre_finishedId_Old_HMAC_UFCMA_key
    cfk = scrut.snd.val.case_C_Sent_EOED._2;
    FStar_Pervasives_Native_option__HandshakeMessages_cr ocr = scrut.snd.val.case_C_Sent_EOED._1;
    FStar_Bytes_bytes d = scrut.snd.val.case_C_Sent_EOED._0;
    Old_Handshake_client_ClientFinished_13(hs, d, ocr, cfk, false);
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = HandshakeLog_write_at_most(hs.log, i1, max1) }
        }
      );
  }
  else
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = outgoing }
        }
      );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
Old_Handshake_next_fragment(Old_Handshake_hs_ hs, TLSInfo_id i1)
{
  return
    Old_Handshake_next_fragment_bounded(hs,
      i1,
      TLSConstants_max_TLSPlaintext_fragment_length);
}

Prims_int Old_Handshake_to_be_written(Old_Handshake_hs_ hs)
{
  return HandshakeLog_to_be_written(hs.log);
}

Prims_string
TLSConstants_fold_string__FStar_Bytes_bytes(
  Prims_string (*f)(FStar_Bytes_bytes x0),
  Prims_string accum,
  Prims_string sep,
  Prims_list__FStar_Bytes_bytes *al
)
{
  if (al->tag == Prims_Nil)
    return accum;
  else if (al->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *al1 = al->tl;
    FStar_Bytes_bytes a = al->hd;
    Prims_string accum1 = Prims_strcat(accum, Prims_strcat(sep, f(a)));
    return TLSConstants_fold_string__FStar_Bytes_bytes(f, accum1, sep, al1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Old_Handshake_incoming
Old_Handshake_server_ClientFinished2__FStar_Bytes_bytes(
  Old_Handshake_hs_ hs,
  FStar_Bytes_bytes cvd,
  FStar_Bytes_bytes digestSF,
  FStar_Bytes_bytes digestCF
)
{
  Old_Handshake_print("Process Client Finished");
  FStar_Bytes_bytes fink = Old_KeySchedule_ks_12_finished_key(hs.ks);
  Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
  Spec_Hash_Definitions_hash_alg
  ha = TLSConstants_verifyDataHashAlg_of_ciphersuite(mode.n_cipher_suite);
  FStar_Bytes_bytes expected_cvd = TLSPRF_finished12(ha, fink, TLSConstants_Client, digestSF);
  if (__eq__FStar_Bytes_bytes(cvd, expected_cvd))
  {
    hs.state[0U] = ((Old_Handshake_machineState){ .tag = Old_Handshake_S_Complete });
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  }
  else
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InError,
          .val = {
            .case_InError = {
              .fst = TLSError_fatalAlert(Parsers_AlertDescription_Decode_error),
              .snd = Prims_strcat("Client Finished MAC did not verify: expected digest ",
                FStar_Bytes_print_bytes(digestSF))
            }
          }
        }
      );
}

typedef struct
K___Old_Handshake_machineState_Prims_list__HandshakeMessages_hs_msg_Prims_list__FStar_Bytes_bytes_s
{
  Old_Handshake_machineState fst;
  Prims_list__HandshakeMessages_hs_msg *snd;
  Prims_list__FStar_Bytes_bytes *thd;
}
K___Old_Handshake_machineState_Prims_list__HandshakeMessages_hs_msg_Prims_list__FStar_Bytes_bytes;

Old_Handshake_incoming
Old_Handshake_recv_fragment(
  Old_Handshake_hs_ hs,
  TLSInfo_id i1,
  K___Prims_int_Prims_int rg1,
  FStar_Bytes_bytes f
)
{
  Old_Handshake_print("recv_fragment");
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__K___Prims_list__HandshakeMessages_hs_msg_Prims_list__FStar_Bytes_bytes
  flight = HandshakeLog_receive(hs.log, f);
  if (flight.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string z = flight.val.case_Error;
    return
      ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
  }
  else if
  (
    flight.tag
    == FStar_Error_Correct
    && flight.val.case_Correct.tag == FStar_Pervasives_Native_None
  )
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  else if
  (
    flight.tag
    == FStar_Error_Correct
    && flight.val.case_Correct.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_list__FStar_Bytes_bytes *ts = flight.val.case_Correct.v.snd;
    Prims_list__HandshakeMessages_hs_msg *ms = flight.val.case_Correct.v.fst;
    K___Old_Handshake_machineState_Prims_list__HandshakeMessages_hs_msg_Prims_list__FStar_Bytes_bytes
    scrut = { .fst = hs.state[0U], .snd = ms, .thd = ts };
    if (scrut.fst.tag == Old_Handshake_C_Idle)
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InError,
            .val = {
              .case_InError = {
                .fst = TLSError_fatalAlert(Parsers_AlertDescription_Unexpected_message),
                .snd = "Client hasn\'t sent hello yet"
              }
            }
          }
        );
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_ServerHello
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_HelloRetryRequest
          && scrut.snd->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      HandshakeMessages_hrr hrr = scrut.snd->hd.val.case_HelloRetryRequest;
      return Old_Handshake_client_HelloRetryRequest(hs, hrr);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_ServerHello
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_ServerHello
          && scrut.snd->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      HandshakeMessages_sh sh = scrut.snd->hd.val.case_ServerHello;
      Old_Handshake_incoming scrut = Old_Handshake_client_ServerHello(hs, sh);
      if
      (
        scrut.tag
        == Old_Handshake_InAck
        && scrut.val.case_InAck.next_keys == false && scrut.val.case_InAck.complete == false
      )
        return
          Old_Handshake_recv_fragment(hs,
            i1,
            (
              (K___Prims_int_Prims_int){
                .fst = (krml_checked_int_t)0,
                .snd = (krml_checked_int_t)0
              }
            ),
            FStar_Bytes_empty_bytes);
      else
        return scrut;
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_ServerHelloDone
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Certificate
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_ServerKeyExchange
              &&
                scrut.snd->tl->tl->tag
                == Prims_Cons
                &&
                  scrut.snd->tl->tl->hd.tag
                  == HandshakeMessages_ServerHelloDone
                  && scrut.snd->tl->tl->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      HandshakeMessages_ske ske = scrut.snd->tl->hd.val.case_ServerKeyExchange;
      Prims_list__FStar_Bytes_bytes *c = scrut.snd->hd.val.case_Certificate;
      return
        Old_Handshake_client_ServerHelloDone(hs,
          c,
          ske,
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_cr){
              .tag = FStar_Pervasives_Native_None
            }
          ));
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_ServerHelloDone
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Certificate
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_ServerKeyExchange
              &&
                scrut.snd->tl->tl->tag
                == Prims_Cons
                &&
                  scrut.snd->tl->tl->hd.tag
                  == HandshakeMessages_CertificateRequest
                  &&
                    scrut.snd->tl->tl->tl->tag
                    == Prims_Cons
                    &&
                      scrut.snd->tl->tl->tl->hd.tag
                      == HandshakeMessages_ServerHelloDone
                      && scrut.snd->tl->tl->tl->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      HandshakeMessages_cr cr = scrut.snd->tl->tl->hd.val.case_CertificateRequest;
      HandshakeMessages_ske ske = scrut.snd->tl->hd.val.case_ServerKeyExchange;
      Prims_list__FStar_Bytes_bytes *c = scrut.snd->hd.val.case_Certificate;
      return
        Old_Handshake_client_ServerHelloDone(hs,
          c,
          ske,
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_cr){
              .tag = FStar_Pervasives_Native_Some,
              .v = cr
            }
          ));
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_Finished1
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_EncryptedExtensions
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_Certificate13
              &&
                scrut.snd->tl->tl->tag
                == Prims_Cons
                &&
                  scrut.snd->tl->tl->hd.tag
                  == HandshakeMessages_CertificateVerify
                  &&
                    scrut.snd->tl->tl->tl->tag
                    == Prims_Cons
                    &&
                      scrut.snd->tl->tl->tl->hd.tag
                      == HandshakeMessages_Finished
                      &&
                        scrut.snd->tl->tl->tl->tl->tag
                        == Prims_Nil
                        &&
                          scrut.thd->tag
                          == Prims_Cons
                          &&
                            scrut.thd->tl->tag
                            == Prims_Cons
                            &&
                              scrut.thd->tl->tl->tag
                              == Prims_Cons
                              &&
                                scrut.thd->tl->tl->tl->tag
                                == Prims_Cons
                                && scrut.thd->tl->tl->tl->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestServerFinished = scrut.thd->tl->tl->tl->hd;
      FStar_Bytes_bytes digestCertVerify = scrut.thd->tl->tl->hd;
      FStar_Bytes_bytes digestCert = scrut.thd->tl->hd;
      FStar_Bytes_bytes f1 = scrut.snd->tl->tl->tl->hd.val.case_Finished;
      HandshakeMessages_signature cv = scrut.snd->tl->tl->hd.val.case_CertificateVerify;
      HandshakeMessages_crt13 c = scrut.snd->tl->hd.val.case_Certificate13;
      Prims_list__Extensions_extension_ *ee = scrut.snd->hd.val.case_EncryptedExtensions;
      return
        Old_Handshake_client_ServerFinished_13(hs,
          ee,
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_cr){
              .tag = FStar_Pervasives_Native_None
            }
          ),
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_crt13){
              .tag = FStar_Pervasives_Native_Some,
              .v = c
            }
          ),
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_signature){
              .tag = FStar_Pervasives_Native_Some,
              .v = cv
            }
          ),
          f1,
          (
            (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = digestCert
            }
          ),
          digestCertVerify,
          digestServerFinished);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_Finished1
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_EncryptedExtensions
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_CertificateRequest13
              &&
                scrut.snd->tl->tl->tag
                == Prims_Cons
                &&
                  scrut.snd->tl->tl->hd.tag
                  == HandshakeMessages_Certificate13
                  &&
                    scrut.snd->tl->tl->tl->tag
                    == Prims_Cons
                    &&
                      scrut.snd->tl->tl->tl->hd.tag
                      == HandshakeMessages_CertificateVerify
                      &&
                        scrut.snd->tl->tl->tl->tl->tag
                        == Prims_Cons
                        &&
                          scrut.snd->tl->tl->tl->tl->hd.tag
                          == HandshakeMessages_Finished
                          &&
                            scrut.snd->tl->tl->tl->tl->tl->tag
                            == Prims_Nil
                            &&
                              scrut.thd->tag
                              == Prims_Cons
                              &&
                                scrut.thd->tl->tag
                                == Prims_Cons
                                &&
                                  scrut.thd->tl->tl->tag
                                  == Prims_Cons
                                  &&
                                    scrut.thd->tl->tl->tl->tag
                                    == Prims_Cons
                                    && scrut.thd->tl->tl->tl->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestServerFinished = scrut.thd->tl->tl->tl->hd;
      FStar_Bytes_bytes digestCertVerify = scrut.thd->tl->tl->hd;
      FStar_Bytes_bytes digestCert = scrut.thd->tl->hd;
      FStar_Bytes_bytes f1 = scrut.snd->tl->tl->tl->tl->hd.val.case_Finished;
      HandshakeMessages_signature cv = scrut.snd->tl->tl->tl->hd.val.case_CertificateVerify;
      HandshakeMessages_crt13 c = scrut.snd->tl->tl->hd.val.case_Certificate13;
      HandshakeMessages_cr cr = scrut.snd->tl->hd.val.case_CertificateRequest13;
      Prims_list__Extensions_extension_ *ee = scrut.snd->hd.val.case_EncryptedExtensions;
      return
        Old_Handshake_client_ServerFinished_13(hs,
          ee,
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_cr){
              .tag = FStar_Pervasives_Native_Some,
              .v = cr
            }
          ),
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_crt13){
              .tag = FStar_Pervasives_Native_Some,
              .v = c
            }
          ),
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_signature){
              .tag = FStar_Pervasives_Native_Some,
              .v = cv
            }
          ),
          f1,
          (
            (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = digestCert
            }
          ),
          digestCertVerify,
          digestServerFinished);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_Finished1
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_EncryptedExtensions
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_Finished
              &&
                scrut.snd->tl->tl->tag
                == Prims_Nil
                &&
                  scrut.thd->tag
                  == Prims_Cons
                  && scrut.thd->tl->tag == Prims_Cons && scrut.thd->tl->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestServerFinished = scrut.thd->tl->hd;
      FStar_Bytes_bytes digestEE = scrut.thd->hd;
      FStar_Bytes_bytes f1 = scrut.snd->tl->hd.val.case_Finished;
      Prims_list__Extensions_extension_ *ee = scrut.snd->hd.val.case_EncryptedExtensions;
      return
        Old_Handshake_client_ServerFinished_13(hs,
          ee,
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_cr){
              .tag = FStar_Pervasives_Native_None
            }
          ),
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_crt13){
              .tag = FStar_Pervasives_Native_None
            }
          ),
          (
            (FStar_Pervasives_Native_option__HandshakeMessages_signature){
              .tag = FStar_Pervasives_Native_None
            }
          ),
          f1,
          (
            (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_None
            }
          ),
          digestEE,
          digestServerFinished);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_R_Finished1
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Finished
          &&
            scrut.snd->tl->tag
            == Prims_Nil
            && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestServerFinished = scrut.thd->hd;
      FStar_Bytes_bytes f1 = scrut.snd->hd.val.case_Finished;
      FStar_Bytes_bytes digestNewSessionTicket = scrut.fst.val.case_C_Wait_R_Finished1;
      return
        Old_Handshake_client_R_ServerFinished(hs,
          f1,
          digestNewSessionTicket,
          digestServerFinished);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Wait_Finished2
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Finished
          &&
            scrut.snd->tl->tag
            == Prims_Nil
            && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes f1 = scrut.snd->hd.val.case_Finished;
      FStar_Bytes_bytes digestClientFinished = scrut.fst.val.case_C_Wait_Finished2;
      return Old_Handshake_client_ServerFinished(hs, f1, digestClientFinished);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Idle
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_ClientHello
          && scrut.snd->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      HandshakeMessages_ch ch = scrut.snd->hd.val.case_ClientHello;
      return
        Old_Handshake_server_ClientHello(hs,
          ch,
          (
            (FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_None
            }
          ));
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Idle
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_ClientHello
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_Binders
              && scrut.snd->tl->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      Prims_list__FStar_Bytes_bytes *binders = scrut.snd->tl->hd.val.case_Binders;
      HandshakeMessages_ch ch = scrut.snd->hd.val.case_ClientHello;
      return
        Old_Handshake_server_ClientHello(hs,
          ch,
          (
            (FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = binders
            }
          ));
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Wait_Finished1
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Finished
          &&
            scrut.snd->tl->tag
            == Prims_Nil
            && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestClientFinish = scrut.thd->hd;
      FStar_Bytes_bytes f1 = scrut.snd->hd.val.case_Finished;
      FStar_Bytes_bytes digest = scrut.fst.val.case_S_Wait_Finished1;
      return Old_Handshake_server_ClientFinished(hs, f1, digest, digestClientFinish);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Wait_Finished1
      &&
        scrut.snd->tag
        == Prims_Cons
        && scrut.snd->hd.tag == HandshakeMessages_Finished && scrut.snd->tl->tag == Prims_Nil
    )
    {
      Prims_list__FStar_Bytes_bytes *tags = scrut.thd;
      FStar_Bytes_bytes f1 = scrut.snd->hd.val.case_Finished;
      FStar_Bytes_bytes digest = scrut.fst.val.case_S_Wait_Finished1;
      Old_Handshake_print(TLSConstants_fold_string__FStar_Bytes_bytes(FStar_Bytes_print_bytes,
          "BAD TAGS: ",
          " ",
          tags));
      return Old_Handshake_server_ClientFinished(hs, f1, digest, digest);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Wait_CF2
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Finished
          &&
            scrut.snd->tl->tag
            == Prims_Nil
            && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestClientFinished = scrut.thd->hd;
      FStar_Bytes_bytes f1 = scrut.snd->hd.val.case_Finished;
      FStar_Bytes_bytes digest = scrut.fst.val.case_S_Wait_CF2;
      return
        Old_Handshake_server_ClientFinished2__FStar_Bytes_bytes(hs,
          f1,
          digest,
          digestClientFinished);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Wait_Finished2
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Finished
          &&
            scrut.snd->tl->tag
            == Prims_Nil
            && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestClientFinished = scrut.thd->hd;
      FStar_Bytes_bytes f1 = scrut.snd->hd.val.case_Finished;
      FStar_Bytes_bytes digestServerFinished = scrut.fst.val.case_S_Wait_Finished2;
      return
        Old_Handshake_server_ClientFinished_13(hs,
          f1,
          digestServerFinished,
          digestClientFinished,
          (
            (FStar_Pervasives_Native_option__K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_None
            }
          ));
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Wait_Finished2
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_Certificate13
          &&
            scrut.snd->tl->tag
            == Prims_Cons
            &&
              scrut.snd->tl->hd.tag
              == HandshakeMessages_CertificateVerify
              &&
                scrut.snd->tl->tl->tag
                == Prims_Cons
                &&
                  scrut.snd->tl->tl->hd.tag
                  == HandshakeMessages_Finished
                  &&
                    scrut.snd->tl->tl->tl->tag
                    == Prims_Nil
                    &&
                      scrut.thd->tag
                      == Prims_Cons
                      &&
                        scrut.thd->tl->tag
                        == Prims_Cons
                        &&
                          scrut.thd->tl->tl->tag
                          == Prims_Cons
                          && scrut.thd->tl->tl->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestClientFinished = scrut.thd->tl->tl->hd;
      FStar_Bytes_bytes digestCertVerify = scrut.thd->tl->hd;
      FStar_Bytes_bytes digestSigned = scrut.thd->hd;
      FStar_Bytes_bytes f1 = scrut.snd->tl->tl->hd.val.case_Finished;
      HandshakeMessages_signature cv = scrut.snd->tl->hd.val.case_CertificateVerify;
      HandshakeMessages_crt13 c = scrut.snd->hd.val.case_Certificate13;
      return
        Old_Handshake_server_ClientFinished_13(hs,
          f1,
          digestCertVerify,
          digestClientFinished,
          (
            (FStar_Pervasives_Native_option__K___HandshakeMessages_crt13_HandshakeMessages_signature_FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .fst = c, .snd = cv, .thd = digestSigned }
            }
          ));
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_S_Wait_EOED
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_EndOfEarlyData
          &&
            scrut.snd->tl->tag
            == Prims_Nil
            && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
    )
    {
      FStar_Bytes_bytes digestEOED = scrut.thd->hd;
      return Old_Handshake_server_EOED(hs, digestEOED);
    }
    else if
    (
      scrut.fst.tag
      == Old_Handshake_C_Complete
      &&
        scrut.snd->tag
        == Prims_Cons
        &&
          scrut.snd->hd.tag
          == HandshakeMessages_NewSessionTicket13
          && scrut.snd->tl->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
    )
    {
      HandshakeMessages_sticket13 st13 = scrut.snd->hd.val.case_NewSessionTicket13;
      return Old_Handshake_client_NewSessionTicket_13(hs, st13);
    }
    else
    {
      Old_Handshake_print("DISCARD FLIGHT");
      return
        (
          (Old_Handshake_incoming){
            .tag = Old_Handshake_InAck,
            .val = { .case_InAck = { .next_keys = false, .complete = false } }
          }
        );
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Old_Handshake_incoming Old_Handshake_recv_ccs(Old_Handshake_hs_ hs)
{
  Old_Handshake_print("recv_ccs");
  bool is_hrr1 = Negotiation_is_hrr(hs.r, hs.nego);
  bool is_idle = Old_Handshake_uu___is_S_Idle(hs.state[0U]);
  if (is_hrr1 || is_idle)
  {
    Old_Handshake_print("IGNORING CCS (workaround for implementations that send CCS after HRR)");
    return
      (
        (Old_Handshake_incoming){
          .tag = Old_Handshake_InAck,
          .val = { .case_InAck = { .next_keys = false, .complete = false } }
        }
      );
  }
  else
  {
    Negotiation_mode mode = Negotiation_getMode(hs.r, hs.nego);
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Prims_list__HandshakeMessages_hs_msg_Prims_list__FStar_Bytes_bytes_FStar_Bytes_bytes
    scrut = HandshakeLog_receive_CCS(Negotiation_hashAlg(mode), hs.log);
    if (scrut.tag == FStar_Error_Error)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut.val.case_Error;
      return
        ((Old_Handshake_incoming){ .tag = Old_Handshake_InError, .val = { .case_InError = z } });
    }
    else if (scrut.tag == FStar_Error_Correct)
    {
      FStar_Bytes_bytes digestCCS = scrut.val.case_Correct.thd;
      Prims_list__FStar_Bytes_bytes *digests = scrut.val.case_Correct.snd;
      Prims_list__HandshakeMessages_hs_msg *ms = scrut.val.case_Correct.fst;
      K___Old_Handshake_machineState_Prims_list__HandshakeMessages_hs_msg_Prims_list__FStar_Bytes_bytes
      scrut = { .fst = hs.state[0U], .snd = ms, .thd = digests };
      if
      (
        scrut.fst.tag
        == Old_Handshake_C_Wait_CCS1
        &&
          scrut.snd->tag
          == Prims_Cons
          &&
            scrut.snd->hd.tag
            == HandshakeMessages_NewSessionTicket
            &&
              scrut.snd->tl->tag
              == Prims_Nil
              && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
      )
      {
        FStar_Bytes_bytes digestNewSessionTicket = scrut.thd->hd;
        HandshakeMessages_sticket st = scrut.snd->hd.val.case_NewSessionTicket;
        return
          Old_Handshake_client_NewSessionTicket_12(hs,
            true,
            digestNewSessionTicket,
            (
              (FStar_Pervasives_Native_option__HandshakeMessages_sticket){
                .tag = FStar_Pervasives_Native_Some,
                .v = st
              }
            ));
      }
      else if
      (
        scrut.fst.tag
        == Old_Handshake_C_Wait_CCS1
        && scrut.snd->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
      )
      {
        FStar_Bytes_bytes digestServerHello = scrut.fst.val.case_C_Wait_CCS1;
        return
          Old_Handshake_client_NewSessionTicket_12(hs,
            true,
            digestServerHello,
            (
              (FStar_Pervasives_Native_option__HandshakeMessages_sticket){
                .tag = FStar_Pervasives_Native_None
              }
            ));
      }
      else if
      (
        scrut.fst.tag
        == Old_Handshake_C_Wait_CCS2
        && scrut.snd->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
      )
      {
        FStar_Bytes_bytes digest = scrut.fst.val.case_C_Wait_CCS2;
        return
          Old_Handshake_client_NewSessionTicket_12(hs,
            false,
            digest,
            (
              (FStar_Pervasives_Native_option__HandshakeMessages_sticket){
                .tag = FStar_Pervasives_Native_None
              }
            ));
      }
      else if
      (
        scrut.fst.tag
        == Old_Handshake_C_Wait_CCS2
        &&
          scrut.snd->tag
          == Prims_Cons
          &&
            scrut.snd->hd.tag
            == HandshakeMessages_NewSessionTicket
            &&
              scrut.snd->tl->tag
              == Prims_Nil
              && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
      )
      {
        FStar_Bytes_bytes digestNewSessionTicket = scrut.thd->hd;
        HandshakeMessages_sticket st = scrut.snd->hd.val.case_NewSessionTicket;
        return
          Old_Handshake_client_NewSessionTicket_12(hs,
            false,
            digestNewSessionTicket,
            (
              (FStar_Pervasives_Native_option__HandshakeMessages_sticket){
                .tag = FStar_Pervasives_Native_Some,
                .v = st
              }
            ));
      }
      else if
      (
        scrut.fst.tag
        == Old_Handshake_S_Wait_CCS2
        && scrut.snd->tag == Prims_Nil && scrut.thd->tag == Prims_Nil
      )
      {
        FStar_Bytes_bytes digestServerFinished = scrut.fst.val.case_S_Wait_CCS2;
        Old_Epochs_incr_reader(Negotiation_nonce(hs.r, hs.nego), hs.epochs);
        hs.state[0U] =
          (
            (Old_Handshake_machineState){
              .tag = Old_Handshake_S_Wait_CF2,
              .val = { .case_S_Wait_CF2 = digestServerFinished }
            }
          );
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InAck,
              .val = { .case_InAck = { .next_keys = true, .complete = false } }
            }
          );
      }
      else if
      (
        scrut.fst.tag
        == Old_Handshake_S_Wait_CCS1
        &&
          scrut.snd->tag
          == Prims_Cons
          &&
            scrut.snd->hd.tag
            == HandshakeMessages_ClientKeyExchange
            &&
              scrut.snd->tl->tag
              == Prims_Nil
              && scrut.thd->tag == Prims_Cons && scrut.thd->tl->tag == Prims_Nil
      )
      {
        HandshakeMessages_kex_c cke = scrut.snd->hd.val.case_ClientKeyExchange;
        return Old_Handshake_server_ClientCCS1(hs, cke, digestCCS);
      }
      else
      {
        Old_Handshake_print("WARNING: bad CCS");
        return
          (
            (Old_Handshake_incoming){
              .tag = Old_Handshake_InError,
              .val = {
                .case_InError = {
                  .fst = TLSError_fatalAlert(Parsers_AlertDescription_Unexpected_message),
                  .snd = "CCS received at wrong time"
                }
              }
            }
          );
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

Old_Handshake_incoming
Old_Handshake_authorize(Old_Handshake_hs_ s, Prims_list__FStar_Bytes_bytes *ch)
{
  KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "authorize: not yet implemented");
  KRML_HOST_EXIT(255U);
}

