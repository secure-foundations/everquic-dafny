/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "QUIC.h"

void QUIC_discard(bool uu____28)
{
  
}

void QUIC_print(Prims_string s)
{
  QUIC_discard(FStar_IO_debug_print_string(Prims_strcat("QIC| ", Prims_strcat(s, "\n"))));
}

void (*QUIC_trace)(Prims_string x0) = QUIC_print;

static bool
FStar_Pervasives_Native_uu___is_None__Prims_list_FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_None)
    return true;
  else
    return false;
}

void QUIC_quic_check(TLSConstants_config config)
{
  if
  (
    __neq__Parsers_ProtocolVersion_protocolVersion(config.min_version,
      ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 }))
  )
    QUIC_print("WARNING: not TLS 1.3");
  if (!config.non_blocking_read)
    QUIC_print("WARNING: reads are blocking");
  if (FStar_Pervasives_Native_uu___is_None__Prims_list_FStar_Bytes_bytes(config.alpn))
    QUIC_print("WARNING: missing ALPN");
  if (!config.is_quic)
    QUIC_print("WARNING: missing QUIC config, using TLS key labels");
}

TLSConstants_config QUIC_ffiConfig(FStar_Bytes_bytes host)
{
  FStar_Pervasives_Native_option__FStar_Bytes_bytes h1;
  if (FStar_UInt32_v(FStar_Bytes_len(host)) == (krml_checked_int_t)0)
    h1 =
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  else
    h1 =
      (
        (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
          .tag = FStar_Pervasives_Native_Some,
          .v = host
        }
      );
  TLSConstants_config uu____0 = TLSInfo_defaultConfig;
  return
    (
      (TLSConstants_config){
        .min_version = { .tag = Parsers_ProtocolVersion_TLS_1p3 },
        .max_version = { .tag = Parsers_ProtocolVersion_TLS_1p3 },
        .is_quic = true,
        .cipher_suites = uu____0.cipher_suites,
        .named_groups = uu____0.named_groups,
        .signature_algorithms = uu____0.signature_algorithms,
        .hello_retry = uu____0.hello_retry,
        .offer_shares = uu____0.offer_shares,
        .custom_extensions = uu____0.custom_extensions,
        .use_tickets = uu____0.use_tickets,
        .send_ticket = { .tag = FStar_Pervasives_Native_None },
        .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
        .request_client_certificate = uu____0.request_client_certificate,
        .non_blocking_read = true,
        .max_early_data = uu____0.max_early_data,
        .max_ticket_age = uu____0.max_ticket_age,
        .safe_renegotiation = uu____0.safe_renegotiation,
        .extended_master_secret = uu____0.extended_master_secret,
        .enable_tickets = uu____0.enable_tickets,
        .ticket_callback = uu____0.ticket_callback,
        .nego_callback = uu____0.nego_callback,
        .cert_callbacks = uu____0.cert_callbacks,
        .alpn = uu____0.alpn,
        .peer_name = h1
      }
    );
}

FStar_Bytes_bytes QUIC___proj__MkchSummary__item__ch_sni(QUIC_chSummary projectee)
{
  return projectee.ch_sni;
}

FStar_Bytes_bytes QUIC___proj__MkchSummary__item__ch_alpn(QUIC_chSummary projectee)
{
  return projectee.ch_alpn;
}

FStar_Bytes_bytes QUIC___proj__MkchSummary__item__ch_extensions(QUIC_chSummary projectee)
{
  return projectee.ch_extensions;
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes
QUIC___proj__MkchSummary__item__ch_cookie(QUIC_chSummary projectee)
{
  return projectee.ch_cookie;
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes
QUIC___proj__MkchSummary__item__ch_ticket_data(QUIC_chSummary projectee)
{
  return projectee.ch_ticket_data;
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes
QUIC_find_ticket_content(Prims_list__K___FStar_Bytes_bytes_uint32_t *l)
{
  if (l->tag == Prims_Nil)
    return
      ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
  else if (l->tag == Prims_Cons)
  {
    Prims_list__K___FStar_Bytes_bytes_uint32_t *t = l->tl;
    FStar_Bytes_bytes id1 = l->hd.fst;
    FStar_Pervasives_Native_option__Ticket_ticket scrut = Ticket_check_ticket(false, id1);
    if (scrut.tag == FStar_Pervasives_Native_Some && scrut.v.tag == Ticket_Ticket13)
    {
      FStar_Bytes_bytes app_data = scrut.v.val.case_Ticket13.custom;
      return
        (
          (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = app_data
          }
        );
    }
    else
      return QUIC_find_ticket_content(t);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool __neq__Content_contentType(Content_contentType y, Content_contentType x)
{
  switch (x)
  {
    case Content_Change_cipher_spec:
      {
        switch (y)
        {
          case Content_Change_cipher_spec:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Content_Alert:
      {
        switch (y)
        {
          case Content_Alert:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Content_Handshake:
      {
        switch (y)
        {
          case Content_Handshake:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case Content_Application_data:
      {
        switch (y)
        {
          case Content_Application_data:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    default:
      {
        return true;
      }
  }
}

static bool
__neq__HandshakeMessages_handshakeType(
  HandshakeMessages_handshakeType y,
  HandshakeMessages_handshakeType x
)
{
  switch (x)
  {
    case HandshakeMessages_HT_hello_request:
      {
        switch (y)
        {
          case HandshakeMessages_HT_hello_request:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_client_hello:
      {
        switch (y)
        {
          case HandshakeMessages_HT_client_hello:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_server_hello:
      {
        switch (y)
        {
          case HandshakeMessages_HT_server_hello:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_session_ticket:
      {
        switch (y)
        {
          case HandshakeMessages_HT_session_ticket:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_end_of_early_data:
      {
        switch (y)
        {
          case HandshakeMessages_HT_end_of_early_data:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_hello_retry_request:
      {
        switch (y)
        {
          case HandshakeMessages_HT_hello_retry_request:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_encrypted_extensions:
      {
        switch (y)
        {
          case HandshakeMessages_HT_encrypted_extensions:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_certificate:
      {
        switch (y)
        {
          case HandshakeMessages_HT_certificate:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_server_key_exchange:
      {
        switch (y)
        {
          case HandshakeMessages_HT_server_key_exchange:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_certificate_request:
      {
        switch (y)
        {
          case HandshakeMessages_HT_certificate_request:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_server_hello_done:
      {
        switch (y)
        {
          case HandshakeMessages_HT_server_hello_done:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_certificate_verify:
      {
        switch (y)
        {
          case HandshakeMessages_HT_certificate_verify:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_client_key_exchange:
      {
        switch (y)
        {
          case HandshakeMessages_HT_client_key_exchange:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_finished:
      {
        switch (y)
        {
          case HandshakeMessages_HT_finished:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_key_update:
      {
        switch (y)
        {
          case HandshakeMessages_HT_key_update:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    case HandshakeMessages_HT_message_hash:
      {
        switch (y)
        {
          case HandshakeMessages_HT_message_hash:
            {
              return false;
            }
          default:
            {
              return true;
            }
        }
        break;
      }
    default:
      {
        return true;
      }
  }
}

FStar_Pervasives_Native_option__QUIC_chSummary
QUIC_peekClientHello(FStar_Bytes_bytes ch, bool has_record)
{
  if (Prims_op_LessThan(FStar_UInt32_v(FStar_Bytes_len(ch)), (krml_checked_int_t)40))
  {
    QUIC_print("peekClientHello: too short");
    return
      ((FStar_Pervasives_Native_option__QUIC_chSummary){ .tag = FStar_Pervasives_Native_None });
  }
  else
  {
    FStar_Pervasives_Native_option__FStar_Bytes_bytes ch10;
    if (has_record)
    {
      K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut0 = FStar_Bytes_split(ch, (uint32_t)5U);
      FStar_Bytes_bytes hdr = scrut0.fst;
      FStar_Bytes_bytes ch1 = scrut0.snd;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___Content_contentType_Parsers_ProtocolVersion_protocolVersion_Prims_int
      scrut = Record_parseHeader(hdr);
      if (scrut.tag == FStar_Error_Error)
      {
        QUIC_print("peekClientHello: bad record header");
        ch10 =
          (
            (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
              .tag = FStar_Pervasives_Native_None
            }
          );
      }
      else if (scrut.tag == FStar_Error_Correct)
      {
        Prims_int len1 = scrut.val.case_Correct.thd;
        Content_contentType ct1 = scrut.val.case_Correct.fst;
        if
        (
          __neq__Content_contentType(ct1,
            Content_Handshake)
          || len1 != FStar_UInt32_v(FStar_Bytes_len(ch1))
        )
        {
          QUIC_print("peekClientHello: bad CT or length");
          ch10 =
            (
              (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                .tag = FStar_Pervasives_Native_None
              }
            );
        }
        else
          ch10 =
            (
              (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                .tag = FStar_Pervasives_Native_Some,
                .v = ch1
              }
            );
      }
      else
        ch10 =
          KRML_EABORT(FStar_Pervasives_Native_option__FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
    }
    else
      ch10 =
        (
          (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
            .tag = FStar_Pervasives_Native_Some,
            .v = ch
          }
        );
    if (ch10.tag == FStar_Pervasives_Native_None)
      return
        ((FStar_Pervasives_Native_option__QUIC_chSummary){ .tag = FStar_Pervasives_Native_None });
    else if (ch10.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes ch2 = ch10.v;
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__FStar_Pervasives_dtuple4__FStar_Bytes_bytes_HandshakeMessages_handshakeType_FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut0 = HandshakeMessages_parseMessage(ch2);
      if (scrut0.tag == FStar_Error_Error)
      {
        QUIC_print("peekClientHello: bad handshake header");
        return
          ((FStar_Pervasives_Native_option__QUIC_chSummary){ .tag = FStar_Pervasives_Native_None });
      }
      else if
      (
        scrut0.tag
        == FStar_Error_Correct
        && scrut0.val.case_Correct.tag == FStar_Pervasives_Native_None
      )
      {
        QUIC_print("peekClientHello: bad handshake header");
        return
          ((FStar_Pervasives_Native_option__QUIC_chSummary){ .tag = FStar_Pervasives_Native_None });
      }
      else if
      (
        scrut0.tag
        == FStar_Error_Correct
        && scrut0.val.case_Correct.tag == FStar_Pervasives_Native_Some
      )
      {
        FStar_Bytes_bytes ch3 = scrut0.val.case_Correct.v._3;
        HandshakeMessages_handshakeType hst = scrut0.val.case_Correct.v._2;
        if (__neq__HandshakeMessages_handshakeType(hst, HandshakeMessages_HT_client_hello))
        {
          QUIC_print("peekClientHello: not a client hello");
          return
            (
              (FStar_Pervasives_Native_option__QUIC_chSummary){
                .tag = FStar_Pervasives_Native_None
              }
            );
        }
        else
        {
          FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_K___HandshakeMessages_ch_FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
          scrut0 = HandshakeMessages_parseClientHello(ch3);
          if (scrut0.tag == FStar_Error_Error)
          {
            Prims_string msg = scrut0.val.case_Error.snd;
            QUIC_print(Prims_strcat("peekClientHello: bad client hello: ", msg));
            return
              (
                (FStar_Pervasives_Native_option__QUIC_chSummary){
                  .tag = FStar_Pervasives_Native_None
                }
              );
          }
          else if (scrut0.tag == FStar_Error_Correct)
          {
            HandshakeMessages_ch ch4 = scrut0.val.case_Correct.fst;
            FStar_Bytes_bytes sni = Negotiation_get_sni(ch4);
            FStar_Bytes_bytes alpn = Extensions_alpnBytes(Negotiation_get_alpn(ch4));
            FStar_Bytes_bytes ext = HandshakeMessages_optionExtensionsBytes(ch4.ch_extensions);
            FStar_Pervasives_Native_option__K___Prims_list__K___FStar_Bytes_bytes_uint32_t_Prims_int
            scrut0 = Negotiation_find_clientPske(ch4);
            FStar_Pervasives_Native_option__FStar_Bytes_bytes ticket_data;
            if (scrut0.tag == FStar_Pervasives_Native_None)
              ticket_data =
                (
                  (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                    .tag = FStar_Pervasives_Native_None
                  }
                );
            else if (scrut0.tag == FStar_Pervasives_Native_Some)
            {
              Prims_list__K___FStar_Bytes_bytes_uint32_t *psk = scrut0.v.fst;
              ticket_data = QUIC_find_ticket_content(psk);
            }
            else
              ticket_data =
                KRML_EABORT(FStar_Pervasives_Native_option__FStar_Bytes_bytes,
                  "unreachable (pattern matches are exhaustive in F*)");
            FStar_Pervasives_Native_option__FStar_Bytes_bytes scrut = Negotiation_find_cookie(ch4);
            FStar_Pervasives_Native_option__FStar_Bytes_bytes cookie;
            if (scrut.tag == FStar_Pervasives_Native_None)
              cookie =
                (
                  (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                    .tag = FStar_Pervasives_Native_None
                  }
                );
            else if (scrut.tag == FStar_Pervasives_Native_Some)
            {
              FStar_Bytes_bytes c = scrut.v;
              FStar_Pervasives_Native_option__K___HandshakeMessages_hrr_FStar_Bytes_bytes_FStar_Bytes_bytes
              scrut = Ticket_check_cookie(c);
              if (scrut.tag == FStar_Pervasives_Native_None)
                cookie =
                  (
                    (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                      .tag = FStar_Pervasives_Native_None
                    }
                  );
              else if (scrut.tag == FStar_Pervasives_Native_Some)
              {
                FStar_Bytes_bytes extra = scrut.v.thd;
                cookie =
                  (
                    (FStar_Pervasives_Native_option__FStar_Bytes_bytes){
                      .tag = FStar_Pervasives_Native_Some,
                      .v = extra
                    }
                  );
              }
              else
                cookie =
                  KRML_EABORT(FStar_Pervasives_Native_option__FStar_Bytes_bytes,
                    "unreachable (pattern matches are exhaustive in F*)");
            }
            else
              cookie =
                KRML_EABORT(FStar_Pervasives_Native_option__FStar_Bytes_bytes,
                  "unreachable (pattern matches are exhaustive in F*)");
            return
              (
                (FStar_Pervasives_Native_option__QUIC_chSummary){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = {
                    .ch_sni = sni, .ch_alpn = alpn, .ch_extensions = ext, .ch_cookie = cookie,
                    .ch_ticket_data = ticket_data
                  }
                }
              );
          }
          else
          {
            KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

Old_Handshake_hs_ QUIC_create_hs(bool is_server, TLSConstants_config config)
{
  QUIC_quic_check(config);
  TLSConstants_role role;
  if (is_server)
    role = TLSConstants_Server;
  else
    role = TLSConstants_Client;
  return Old_Handshake_create(config, role);
}

FStar_Bytes_bytes QUIC___proj__Mkhs_in__item__input(QUIC_hs_in projectee)
{
  return projectee.input;
}

uint32_t QUIC___proj__Mkhs_in__item__max_output(QUIC_hs_in projectee)
{
  return projectee.max_output;
}

uint32_t QUIC___proj__Mkhs_out__item__consumed(QUIC_hs_out projectee)
{
  return projectee.consumed;
}

FStar_Bytes_bytes QUIC___proj__Mkhs_out__item__output(QUIC_hs_out projectee)
{
  return projectee.output;
}

uint32_t QUIC___proj__Mkhs_out__item__to_be_written(QUIC_hs_out projectee)
{
  return projectee.to_be_written;
}

bool QUIC___proj__Mkhs_out__item__is_complete(QUIC_hs_out projectee)
{
  return projectee.is_complete;
}

bool QUIC___proj__Mkhs_out__item__is_writable(QUIC_hs_out projectee)
{
  return projectee.is_writable;
}

bool QUIC___proj__Mkhs_out__item__is_early_rejected(QUIC_hs_out projectee)
{
  return projectee.is_early_rejected;
}

bool QUIC___proj__Mkhs_out__item__is_post_handshake(QUIC_hs_out projectee)
{
  return projectee.is_post_handshake;
}

bool QUIC_uu___is_HS_SUCCESS(QUIC_hs_result projectee)
{
  if (projectee.tag == QUIC_HS_SUCCESS)
    return true;
  else
    return false;
}

QUIC_hs_out QUIC___proj__HS_SUCCESS__item___0(QUIC_hs_result projectee)
{
  if (projectee.tag == QUIC_HS_SUCCESS)
    return projectee.val.case_HS_SUCCESS;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool QUIC_uu___is_HS_ERROR(QUIC_hs_result projectee)
{
  if (projectee.tag == QUIC_HS_ERROR)
    return true;
  else
    return false;
}

uint16_t QUIC___proj__HS_ERROR__item___0(QUIC_hs_result projectee)
{
  if (projectee.tag == QUIC_HS_ERROR)
    return projectee.val.case_HS_ERROR;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static TLSInfo_id QUIC_currentId(Old_Handshake_hs_ hs, TLSConstants_rw rw)
{
  Prims_int j1 = Old_Handshake_i(hs, rw);
  if (Prims_op_LessThan(j1, (krml_checked_int_t)0))
    return
      (
        (TLSInfo_id){
          .tag = TLSInfo_PlaintextID,
          .val = { .case_PlaintextID = Old_Handshake_nonce(hs) }
        }
      );
  else
  {
    Old_Epochs_epoch
    e = Old_Epochs_get_current_epoch(Old_Handshake_random_of(hs), Old_Handshake_epochs_of(hs), rw);
    return Old_Epochs_epoch_id(Old_Handshake_random_of(hs), e);
  }
}

K___Prims_int_Prims_int QUIC_get_epochs(Old_Handshake_hs_ hs)
{
  Prims_int uu____0 = Old_Handshake_i(hs, TLSConstants_Reader);
  return
    ((K___Prims_int_Prims_int){ .fst = uu____0, .snd = Old_Handshake_i(hs, TLSConstants_Writer) });
}

typedef struct K___bool_bool_s
{
  bool fst;
  bool snd;
}
K___bool_bool;

static K___bool_bool
QUIC_handle_signals(
  Old_Handshake_hs_ hs,
  FStar_Pervasives_Native_option__HandshakeLog_next_keys_use sig_1344
)
{
  if (sig_1344.tag == FStar_Pervasives_Native_None)
    return ((K___bool_bool){ .fst = false, .snd = false });
  else if (sig_1344.tag == FStar_Pervasives_Native_Some)
  {
    HandshakeLog_next_keys_use use = sig_1344.v;
    Old_Epochs_incr_writer(Old_Handshake_random_of(hs), Old_Handshake_epochs_of(hs));
    if (use.out_skip_0RTT)
    {
      QUIC_print("Skip 0-RTT (incr writer)");
      Old_Epochs_incr_writer(Old_Handshake_random_of(hs), Old_Handshake_epochs_of(hs));
    }
    return ((K___bool_bool){ .fst = use.out_appdata, .snd = use.out_0RTT_reject });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Bytes_bytes
Prims___proj__Mkdtuple2__item___2__Prims_int___Prims_int_FStar_Bytes_bytes(
  Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes pair
)
{
  return pair.snd;
}

static FStar_Bytes_bytes
FStar_Pervasives_dsnd__Prims_int___Prims_int_FStar_Bytes_bytes(
  Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes t
)
{
  return Prims___proj__Mkdtuple2__item___2__Prims_int___Prims_int_FStar_Bytes_bytes(t);
}

QUIC_hs_result QUIC_process_hs(Old_Handshake_hs_ hs, QUIC_hs_in ctx)
{
  Prims_int tbw = Old_Handshake_to_be_written(hs);
  if (Prims_op_GreaterThan(tbw, (krml_checked_int_t)0))
    if (ctx.max_output == (uint32_t)0U)
      return
        (
          (QUIC_hs_result){
            .tag = QUIC_HS_SUCCESS,
            .val = {
              .case_HS_SUCCESS = {
                .consumed = (uint32_t)0U, .output = FStar_Bytes_empty_bytes,
                .to_be_written = FStar_UInt32_uint_to_t(tbw), .is_complete = false,
                .is_writable = false, .is_early_rejected = false, .is_post_handshake = false
              }
            }
          }
        );
    else
    {
      TLSInfo_id i1 = QUIC_currentId(hs, TLSConstants_Writer);
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
      scrut0 = Old_Handshake_next_fragment_bounded(hs, i1, FStar_UInt32_v(ctx.max_output));
      if (scrut0.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
        Parsers_Alert_alert ad = z.fst;
        Prims_string err = z.snd;
        QUIC_print(Prims_strcat("Returning HS error: ", err));
        return
          (
            (QUIC_hs_result){
              .tag = QUIC_HS_ERROR,
              .val = { .case_HS_ERROR = Parse_uint16_of_bytes(Alert_alertBytes(ad)) }
            }
          );
      }
      else if
      (
        scrut0.tag
        == FStar_Error_Correct
        && scrut0.val.case_Correct.send_first.tag == FStar_Pervasives_Native_Some
      )
      {
        bool complete = scrut0.val.case_Correct.complete;
        FStar_Pervasives_Native_option__HandshakeLog_next_keys_use
        sig_1493 = scrut0.val.case_Correct.next_keys;
        Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes
        frag = scrut0.val.case_Correct.send_first.v;
        K___bool_bool scrut = QUIC_handle_signals(hs, sig_1493);
        bool is_writable = scrut.fst;
        bool reject_0rtt = scrut.snd;
        uint32_t uu____0 = FStar_UInt32_uint_to_t(Old_Handshake_to_be_written(hs));
        return
          (
            (QUIC_hs_result){
              .tag = QUIC_HS_SUCCESS,
              .val = {
                .case_HS_SUCCESS = {
                  .consumed = (uint32_t)0U,
                  .output = FStar_Pervasives_dsnd__Prims_int___Prims_int_FStar_Bytes_bytes(frag),
                  .to_be_written = uu____0, .is_complete = complete, .is_writable = is_writable,
                  .is_early_rejected = reject_0rtt, .is_post_handshake = false
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  else
  {
    TLSInfo_id i1 = QUIC_currentId(hs, TLSConstants_Reader);
    Prims_int len1 = FStar_UInt32_v(FStar_Bytes_len(ctx.input));
    K___Prims_int_Prims_int rg1 = { .fst = len1, .snd = len1 };
    FStar_Bytes_bytes f = ctx.input;
    Old_Handshake_incoming scrut0 = Old_Handshake_recv_fragment(hs, i1, rg1, f);
    if (scrut0.tag == Old_Handshake_InQuery)
    {
      QUIC_print("Unexpected handshake query");
      return ((QUIC_hs_result){ .tag = QUIC_HS_ERROR, .val = { .case_HS_ERROR = (uint16_t)252U } });
    }
    else if (scrut0.tag == Old_Handshake_InError)
    {
      K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_InError;
      Parsers_Alert_alert ad = z.fst;
      Prims_string err = z.snd;
      QUIC_print(Prims_strcat("Returning HS error: ", err));
      return
        (
          (QUIC_hs_result){
            .tag = QUIC_HS_ERROR,
            .val = { .case_HS_ERROR = Parse_uint16_of_bytes(Alert_alertBytes(ad)) }
          }
        );
    }
    else if (scrut0.tag == Old_Handshake_InAck)
    {
      bool complete = scrut0.val.case_InAck.complete;
      uint32_t consumed = FStar_UInt32_uint_to_t(len1);
      Prims_int j1 = Old_Handshake_i(hs, TLSConstants_Writer);
      bool post_hs = Old_Handshake_is_post_handshake(hs);
      TLSInfo_id i2 = QUIC_currentId(hs, TLSConstants_Writer);
      Prims_int max_o = FStar_UInt32_v(ctx.max_output);
      FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
      scrut0 = Old_Handshake_next_fragment_bounded(hs, i2, max_o);
      if (scrut0.tag == FStar_Error_Error)
      {
        K___Parsers_Alert_alert_Prims_string z = scrut0.val.case_Error;
        Parsers_Alert_alert ad = z.fst;
        Prims_string err = z.snd;
        QUIC_print(Prims_strcat("Returning HS error: ", err));
        return
          (
            (QUIC_hs_result){
              .tag = QUIC_HS_ERROR,
              .val = { .case_HS_ERROR = Parse_uint16_of_bytes(Alert_alertBytes(ad)) }
            }
          );
      }
      else if (scrut0.tag == FStar_Error_Correct)
      {
        bool complete_ = scrut0.val.case_Correct.complete;
        FStar_Pervasives_Native_option__HandshakeLog_next_keys_use
        sig_1612 = scrut0.val.case_Correct.next_keys;
        FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes
        frag = scrut0.val.case_Correct.send_first;
        K___bool_bool scrut = QUIC_handle_signals(hs, sig_1612);
        bool is_writable = scrut.fst;
        bool reject_0rtt = scrut.snd;
        uint32_t uu____1 = FStar_UInt32_uint_to_t(Old_Handshake_to_be_written(hs));
        FStar_Bytes_bytes ite;
        if (frag.tag == FStar_Pervasives_Native_Some)
        {
          Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes f1 = frag.v;
          ite = FStar_Pervasives_dsnd__Prims_int___Prims_int_FStar_Bytes_bytes(f1);
        }
        else if (frag.tag == FStar_Pervasives_Native_None)
          ite = FStar_Bytes_empty_bytes;
        else
          ite = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
        return
          (
            (QUIC_hs_result){
              .tag = QUIC_HS_SUCCESS,
              .val = {
                .case_HS_SUCCESS = {
                  .consumed = consumed, .output = ite, .to_be_written = uu____1,
                  .is_complete = complete || complete_, .is_writable = is_writable,
                  .is_early_rejected = reject_0rtt, .is_post_handshake = post_hs
                }
              }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

EverCrypt_aead_alg QUIC___proj__Mkraw_key__item__alg(QUIC_raw_key projectee)
{
  return projectee.alg;
}

FStar_Bytes_bytes QUIC___proj__Mkraw_key__item__aead_key(QUIC_raw_key projectee)
{
  return projectee.aead_key;
}

FStar_Bytes_bytes QUIC___proj__Mkraw_key__item__aead_iv(QUIC_raw_key projectee)
{
  return projectee.aead_iv;
}

FStar_Bytes_bytes QUIC___proj__Mkraw_key__item__pn_key(QUIC_raw_key projectee)
{
  return projectee.pn_key;
}

FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets
QUIC_get_secrets(Old_Handshake_hs_ hs, Prims_int ectr)
{
  Prims_list__Old_Epochs_epoch
  *epochs1 =
    FStar_Monotonic_Seq_i_read__Old_Epochs_epoch___(Old_Epochs_get_epochs(Old_Handshake_random_of(hs),
        Old_Handshake_epochs_of(hs)));
  if (Prims_op_LessThanOrEqual(FStar_Seq_Base_length__Old_Epochs_epoch(epochs1), ectr))
    return
      (
        (FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    Old_Epochs_epoch e = FStar_Seq_Base_index__Old_Epochs_epoch(epochs1, ectr);
    CipherSuite_aeAlg
    scrut0 = TLSInfo_aeAlg_of_id(Old_Epochs_epoch_id(Old_Handshake_random_of(hs), e));
    if (scrut0.tag == CipherSuite_AEAD)
    {
      Spec_Hash_Definitions_hash_alg h1 = scrut0.val.case_AEAD._1;
      EverCrypt_aead_alg ae = scrut0.val.case_AEAD._0;
      K___FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut = Old_Epochs_pn_epoch(Old_Handshake_random_of(hs), e);
      if
      (
        scrut.fst.tag
        == FStar_Pervasives_Native_Some
        && scrut.snd.tag == FStar_Pervasives_Native_Some
      )
      {
        FStar_Bytes_bytes sts = scrut.snd.v.snd;
        FStar_Bytes_bytes cts = scrut.fst.v.snd;
        return
          (
            (FStar_Pervasives_Native_option__Old_KeySchedule_raw_rekey_secrets){
              .tag = FStar_Pervasives_Native_Some,
              .v = { .rekey_aead = ae, .rekey_hash = h1, .rekey_client = cts, .rekey_server = sts }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

typedef struct K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes_s
{
  K___FStar_Bytes_bytes_FStar_Bytes_bytes fst;
  FStar_Bytes_bytes snd;
}
K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes;

FStar_Pervasives_Native_option__QUIC_raw_key
QUIC_get_key(Old_Handshake_hs_ hs, Prims_int ectr, bool rw)
{
  Prims_list__Old_Epochs_epoch
  *epochs1 =
    FStar_Monotonic_Seq_i_read__Old_Epochs_epoch___(Old_Epochs_get_epochs(Old_Handshake_random_of(hs),
        Old_Handshake_epochs_of(hs)));
  if (Prims_op_LessThanOrEqual(FStar_Seq_Base_length__Old_Epochs_epoch(epochs1), ectr))
    return ((FStar_Pervasives_Native_option__QUIC_raw_key){ .tag = FStar_Pervasives_Native_None });
  else
  {
    Old_Epochs_epoch e = FStar_Seq_Base_index__Old_Epochs_epoch(epochs1, ectr);
    CipherSuite_aeAlg
    scrut0 = TLSInfo_aeAlg_of_id(Old_Epochs_epoch_id(Old_Handshake_random_of(hs), e));
    if (scrut0.tag == CipherSuite_AEAD)
    {
      EverCrypt_aead_alg alg1 = scrut0.val.case_AEAD._0;
      K___FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes
      scrut0 = Old_Epochs_pn_epoch(Old_Handshake_random_of(hs), e);
      K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes scrut1;
      if
      (
        scrut0.fst.tag
        == FStar_Pervasives_Native_Some
        && scrut0.snd.tag == FStar_Pervasives_Native_Some
      )
      {
        FStar_Bytes_bytes wpn = scrut0.snd.v.fst;
        FStar_Bytes_bytes rpn = scrut0.fst.v.fst;
        if (rw)
        {
          StAE_state scrut = Old_Epochs_reader_epoch(Old_Handshake_random_of(hs), e);
          if (scrut.tag == StAE_Stream)
          {
            StreamAE_state st = scrut.val.case_Stream;
            FStar_Bytes_bytes x10 = Old_Handshake_random_of(hs);
            TLSInfo_id x0 = TLSInfo_peerId(e.i);
            K____EverCrypt__aead_state__K___FStar_Bytes_bytes_FStar_Bytes_bytes st1 = st.aead;
            FStar_Bytes_bytes x1 = Old_Handshake_random_of(hs);
            scrut1 =
              (
                (K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes){
                  .fst = AEADProvider_leak(TLSInfo_peerId(e.i), TLSConstants_Reader, st1),
                  .snd = rpn
                }
              );
          }
          else
            scrut1 =
              KRML_EABORT(K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes,
                "unreachable (pattern matches are exhaustive in F*)");
        }
        else
        {
          StAE_state scrut = Old_Epochs_writer_epoch(Old_Handshake_random_of(hs), e);
          if (scrut.tag == StAE_Stream)
          {
            StreamAE_state st = scrut.val.case_Stream;
            FStar_Bytes_bytes x10 = Old_Handshake_random_of(hs);
            TLSInfo_id x0 = e.i;
            K____EverCrypt__aead_state__K___FStar_Bytes_bytes_FStar_Bytes_bytes st1 = st.aead;
            FStar_Bytes_bytes x1 = Old_Handshake_random_of(hs);
            scrut1 =
              (
                (K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes){
                  .fst = AEADProvider_leak(e.i, TLSConstants_Writer, st1),
                  .snd = wpn
                }
              );
          }
          else
            scrut1 =
              KRML_EABORT(K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes,
                "unreachable (pattern matches are exhaustive in F*)");
        }
      }
      else
        scrut1 =
          KRML_EABORT(K___K___FStar_Bytes_bytes_FStar_Bytes_bytes_FStar_Bytes_bytes,
            "unreachable (pattern matches are exhaustive in F*)");
      FStar_Bytes_bytes pn = scrut1.snd;
      FStar_Bytes_bytes iv = scrut1.fst.snd;
      FStar_Bytes_bytes key = scrut1.fst.fst;
      return
        (
          (FStar_Pervasives_Native_option__QUIC_raw_key){
            .tag = FStar_Pervasives_Native_Some,
            .v = { .alg = alg1, .aead_key = key, .aead_iv = iv, .pn_key = pn }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

bool QUIC_send_ticket(Old_Handshake_hs_ hs, FStar_Bytes_bytes b)
{
  return Old_Handshake_send_ticket(hs, b);
}

