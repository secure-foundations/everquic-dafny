/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "TLS.h"

K___Prims_int_Prims_int (*TLS_point)(Prims_int x0) = Range_point;

bool (*TLS_valid_clen)(TLSInfo_id x0, Prims_int x1) = Range_valid_clen;

K___Prims_int_Prims_int TLS_fragment_range;

void TLS_discard(bool uu____31)
{
  
}

void TLS_print(Prims_string s)
{
  TLS_discard(FStar_IO_debug_print_string(Prims_strcat("TLS| ", Prims_strcat(s, "\n"))));
}

void (*TLS_trace)(Prims_string x0) = TLS_print;

Parsers_ProtocolVersion_protocolVersion TLS_outerPV(Connection_connection c)
{
  Parsers_ProtocolVersion_protocolVersion scrut = Old_Handshake_version_of(c.hs);
  if (scrut.tag == Parsers_ProtocolVersion_TLS_1p3)
    return ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p0 });
  else
    return scrut;
}

Connection_connection
TLS_create(Transport_t tcp, TLSConstants_role role, TLSConstants_config cfg)
{
  Old_Handshake_hs_ hs = Old_Handshake_create(cfg, role);
  Record_input_state recv1 = Record_alloc_input_state();
  KRML_CHECK_SIZE(sizeof (K___Connection_halfState_Connection_halfState), (uint32_t)1U);
  K___Connection_halfState_Connection_halfState
  *state = KRML_HOST_MALLOC(sizeof (K___Connection_halfState_Connection_halfState));
  state[0U]
  =
    (
      (K___Connection_halfState_Connection_halfState){
        .fst = Connection_Ctrl,
        .snd = Connection_Ctrl
      }
    );
  return ((Connection_connection){ .hs = hs, .tcp = tcp, .recv = recv1, .state = state });
}

Connection_connection TLS_connect(Transport_t tcp, TLSConstants_config cfg)
{
  return TLS_create(tcp, TLSConstants_Client, cfg);
}

Connection_connection
TLS_resume(
  Transport_t tcp,
  TLSConstants_config cfg,
  FStar_Bytes_bytes tid,
  FStar_Bytes_bytes psk
)
{
  TLSConstants_config uu____0 = cfg;
  KRML_CHECK_SIZE(sizeof (Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes));
  buf[0U]
  =
    (
      (Prims_list__K___FStar_Bytes_bytes_FStar_Bytes_bytes){
        .tag = Prims_Cons,
        .hd = { .fst = tid, .snd = psk },
        .tl = cfg.use_tickets
      }
    );
  TLSConstants_config
  cfg1 =
    {
      .min_version = uu____0.min_version, .max_version = uu____0.max_version,
      .is_quic = uu____0.is_quic, .cipher_suites = uu____0.cipher_suites,
      .named_groups = uu____0.named_groups, .signature_algorithms = uu____0.signature_algorithms,
      .hello_retry = uu____0.hello_retry, .offer_shares = uu____0.offer_shares,
      .custom_extensions = uu____0.custom_extensions, .use_tickets = buf,
      .send_ticket = uu____0.send_ticket,
      .check_client_version_in_pms_for_old_tls = uu____0.check_client_version_in_pms_for_old_tls,
      .request_client_certificate = uu____0.request_client_certificate,
      .non_blocking_read = uu____0.non_blocking_read, .max_early_data = uu____0.max_early_data,
      .max_ticket_age = uu____0.max_ticket_age, .safe_renegotiation = uu____0.safe_renegotiation,
      .extended_master_secret = uu____0.extended_master_secret,
      .enable_tickets = uu____0.enable_tickets, .ticket_callback = uu____0.ticket_callback,
      .nego_callback = uu____0.nego_callback, .cert_callbacks = uu____0.cert_callbacks,
      .alpn = uu____0.alpn, .peer_name = uu____0.peer_name
    };
  return TLS_create(tcp, TLSConstants_Client, cfg1);
}

Connection_connection TLS_accept_connected(Transport_t tcp, TLSConstants_config cfg)
{
  return TLS_create(tcp, TLSConstants_Server, cfg);
}

bool TLS_rehandshake(Connection_connection c, TLSConstants_config ops)
{
  return Old_Handshake_rehandshake(c.hs, ops);
}

bool TLS_rekey(Connection_connection c, TLSConstants_config ops)
{
  return Old_Handshake_rekey(c.hs, ops);
}

bool TLS_request(Connection_connection c, TLSConstants_config ops)
{
  return Old_Handshake_request(c.hs, ops);
}

Negotiation_mode TLS_get_mode(Connection_connection c)
{
  return Old_Handshake_get_mode(c.hs);
}

bool TLS_set_ticket_key(EverCrypt_aead_alg a, FStar_Bytes_bytes kv)
{
  return Ticket_set_ticket_key(a, kv);
}

bool TLS_set_sealing_key(EverCrypt_aead_alg a, FStar_Bytes_bytes kv)
{
  return Ticket_set_sealing_key(a, kv);
}

bool TLS_no_seqn_overflow(Connection_connection c, TLSConstants_rw rw)
{
  Prims_list__Old_Epochs_epoch
  *es = FStar_Monotonic_Seq_i_read__Old_Epochs_epoch___(Old_Handshake_es_of(c.hs));
  Prims_int j1 = Old_Handshake_i(c.hs, rw);
  if (Prims_op_LessThan(j1, (krml_checked_int_t)0))
    return true;
  else
  {
    Old_Epochs_epoch e = FStar_Seq_Base_index__Old_Epochs_epoch(es, j1);
    return true;
  }
}

bool TLS_uu___is_Written(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_Written)
    return true;
  else
    return false;
}

bool TLS_uu___is_WriteClose(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WriteClose)
    return true;
  else
    return false;
}

bool TLS_uu___is_WriteError(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WriteError)
    return true;
  else
    return false;
}

FStar_Pervasives_Native_option__Parsers_Alert_alert
TLS___proj__WriteError__item__o(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WriteError)
    return projectee.val.case_WriteError.o;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_string TLS___proj__WriteError__item__txt(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WriteError)
    return projectee.val.case_WriteError.txt;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS_uu___is_WrittenHS(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WrittenHS)
    return true;
  else
    return false;
}

FStar_Pervasives_Native_option__bool
TLS___proj__WrittenHS__item__newWriter(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WrittenHS)
    return projectee.val.case_WrittenHS.newWriter;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS___proj__WrittenHS__item__complete(TLS_ioresult_w projectee)
{
  if (projectee.tag == TLS_WrittenHS)
    return projectee.val.case_WrittenHS.complete;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_string TLS_string_of_ioresult_w(TLS_ioresult_w uu___0_683)
{
  if (uu___0_683.tag == TLS_Written)
    return "Written";
  else if (uu___0_683.tag == TLS_WriteClose)
    return "WriteClose";
  else if
  (
    uu___0_683.tag
    == TLS_WriteError
    && uu___0_683.val.case_WriteError.o.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_string s = uu___0_683.val.case_WriteError.txt;
    Parsers_Alert_alert a = uu___0_683.val.case_WriteError.o.v;
    return
      Prims_strcat("WriteError: ",
        TLSError_string_of_error(((K___Parsers_Alert_alert_Prims_string){ .fst = a, .snd = s })));
  }
  else if
  (
    uu___0_683.tag
    == TLS_WriteError
    && uu___0_683.val.case_WriteError.o.tag == FStar_Pervasives_Native_None
  )
  {
    Prims_string s = uu___0_683.val.case_WriteError.txt;
    return Prims_strcat("WriteError: ", s);
  }
  else if (uu___0_683.tag == TLS_WrittenHS)
  {
    bool c = uu___0_683.val.case_WrittenHS.complete;
    FStar_Pervasives_Native_option__bool nw = uu___0_683.val.case_WrittenHS.newWriter;
    Prims_string ite0;
    if (nw.tag == FStar_Pervasives_Native_Some && nw.v == true)
      ite0 = "new-writable ";
    else if (nw.tag == FStar_Pervasives_Native_Some && nw.v == false)
      ite0 = "new-hanshake-only ";
    else if (nw.tag == FStar_Pervasives_Native_None)
      ite0 = "";
    else
      ite0 = KRML_EABORT(Prims_string, "unreachable (pattern matches are exhaustive in F*)");
    Prims_string ite;
    if (c)
      ite = "complete";
    else
      ite = "";
    return Prims_strcat("WrittenHS ", Prims_strcat(ite0, ite));
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

void TLS_disconnect(Connection_connection c)
{
  Old_Handshake_invalidateSession(c.hs);
  c.state[0U] =
    (
      (K___Connection_halfState_Connection_halfState){
        .fst = Connection_Closed,
        .snd = Connection_Closed
      }
    );
}

TLS_ioresult_w TLS_unrecoverable(Connection_connection c, Prims_string reason)
{
  TLS_disconnect(c);
  return
    (
      (TLS_ioresult_w){
        .tag = TLS_WriteError,
        .val = {
          .case_WriteError = { .o = { .tag = FStar_Pervasives_Native_None }, .txt = reason }
        }
      }
    );
}

TLSInfo_id TLS_currentId(Connection_connection c, TLSConstants_rw rw)
{
  Prims_int j1 = Old_Handshake_i(c.hs, rw);
  if (Prims_op_LessThan(j1, (krml_checked_int_t)0))
    return
      (
        (TLSInfo_id){
          .tag = TLSInfo_PlaintextID,
          .val = { .case_PlaintextID = Connection_c_nonce(c) }
        }
      );
  else
  {
    Old_Epochs_epoch
    e =
      Old_Epochs_get_current_epoch(Old_Handshake_random_of(c.hs),
        Old_Handshake_epochs_of(c.hs),
        rw);
    return Old_Epochs_epoch_id(Old_Handshake_random_of(c.hs), e);
  }
}

Content_fragment
TLS_appfragment(
  TLSInfo_id i1,
  FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes o
)
{
  if (o.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes f = o.v.snd;
    K___Prims_int_Prims_int rg1 = o.v.fst;
    return
      (
        (Content_fragment){
          .tag = Content_CT_Data,
          .val = { .case_CT_Data = { .rg = rg1, .f = f } }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

DataStream_delta
TLS_datafragment(
  TLSInfo_id i1,
  FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes o
)
{
  if (o.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes f = o.v.snd;
    FStar_Bytes_bytes f1 = f;
    return ((DataStream_delta){ .tag = DataStream_Data, .val = { .case_Data = f1 } });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__StAE_state
TLS_current_writer(Connection_connection c, TLSInfo_id i1)
{
  Prims_int ix = Old_Handshake_i(c.hs, TLSConstants_Writer);
  if (Prims_op_LessThan(ix, (krml_checked_int_t)0))
    return ((FStar_Pervasives_Native_option__StAE_state){ .tag = FStar_Pervasives_Native_None });
  else
  {
    Prims_list__Old_Epochs_epoch
    *epochs1 = FStar_Monotonic_Seq_i_read__Old_Epochs_epoch___(Old_Handshake_es_of(c.hs));
    Old_Epochs_epoch e = FStar_Seq_Base_index__Old_Epochs_epoch(epochs1, ix);
    FStar_Bytes_bytes x1 = Old_Handshake_random_of(c.hs);
    return
      (
        (FStar_Pervasives_Native_option__StAE_state){
          .tag = FStar_Pervasives_Native_Some,
          .v = e.w
        }
      );
  }
}

void TLS_recall_current_writer(Connection_connection c)
{
  TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Writer);
  FStar_Pervasives_Native_option__StAE_state wopt = TLS_current_writer(c, i1);
  if (!(wopt.tag == FStar_Pervasives_Native_None))
    if (!(wopt.tag == FStar_Pervasives_Native_Some))
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
}

static bool
TLS_check_incrementable(
  Connection_connection c,
  TLSInfo_id i1,
  FStar_Pervasives_Native_option__StAE_state wopt
)
{
  return true;
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
TLSError_fatal____(Parsers_AlertDescription_alertDescription a, Prims_string s)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___){
        .tag = FStar_Error_Error,
        ._0 = { .fst = TLSError_fatalAlert(a), .snd = s }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___ TLS_ad_overflow;

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
TLS_sendFragment(
  Connection_connection c,
  TLSInfo_id i1,
  FStar_Pervasives_Native_option__StAE_state wo,
  Content_fragment f
)
{
  K___Content_contentType_K___Prims_int_Prims_int scrut = Content_ct_rg(i1, f);
  Content_contentType ct1 = scrut.fst;
  Prims_string idt;
  if (TLSInfo_uu___is_ID12(i1))
    idt = "ID12";
  else if (TLSInfo_uu___is_ID13(i1))
    idt = "ID13";
  else
    idt = "PlaintextID";
  TLS_print(Prims_strcat("send ",
      Prims_strcat(Content_ctToString(ct1), Prims_strcat(" fragment with index ", idt))));
  if (!TLS_check_incrementable(c, i1, wo))
    return TLS_ad_overflow;
  else
  {
    FStar_Bytes_bytes payload;
    if (wo.tag == FStar_Pervasives_Native_None)
      payload = Content_repr(i1, f);
    else if (wo.tag == FStar_Pervasives_Native_Some)
    {
      StAE_state wr = wo.v;
      if (wr.tag == StAE_Stream)
      {
        StreamAE_state st = wr.val.case_Stream;
        K___FStar_Bytes_bytes_FStar_Bytes_bytes scrut = StreamAE_leak(i1, TLSConstants_Writer, st);
        FStar_Bytes_bytes key = scrut.fst;
        TLS_print(Prims_strcat("Encrypting with key ", FStar_Bytes_print_bytes(key)));
      }
      payload = StreamDeltas_encrypt(i1, wr, f);
    }
    else
      payload = KRML_EABORT(FStar_Bytes_bytes, "unreachable (pattern matches are exhaustive in F*)");
    Parsers_ProtocolVersion_protocolVersion pv = Old_Handshake_version_of(c.hs);
    TLS_print(Prims_strcat("Sending fragment of length ",
        Prims_string_of_int(FStar_UInt32_v(FStar_Bytes_len(payload)))));
    FStar_Error_optResult__Prims_string___
    r = Record_sendPacket(c.tcp, ct1, TLSInfo_uu___is_PlaintextID(i1), pv, payload);
    if (r.tag == FStar_Error_Error)
    {
      Prims_string x = r._0;
      return TLSError_fatal____(Parsers_AlertDescription_Internal_error, x);
    }
    else if (r.tag == FStar_Error_Correct)
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___){
            .tag = FStar_Error_Correct
          }
        );
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static Prims_string
FStar_Pervasives_Native_snd__Parsers_Alert_alert_Prims_string(
  K___Parsers_Alert_alert_Prims_string x
)
{
  return x.snd;
}

static Connection_halfState
FStar_Pervasives_Native_fst__Connection_halfState_Connection_halfState(
  K___Connection_halfState_Connection_halfState x
)
{
  return x.fst;
}

static TLS_ioresult_w
TLS_sendAlert(Connection_connection c, Parsers_Alert_alert ad, Prims_string reason)
{
  TLS_print(Prims_strcat("sendAlert ",
      TLSError_string_of_error(((K___Parsers_Alert_alert_Prims_string){ .fst = ad, .snd = reason }))));
  TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Writer);
  FStar_Pervasives_Native_option__StAE_state wopt = TLS_current_writer(c, i1);
  K___Connection_halfState_Connection_halfState st = c.state[0U];
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
  res =
    TLS_sendFragment(c,
      i1,
      wopt,
      (
        (Content_fragment){
          .tag = Content_CT_Alert,
          .val = { .case_CT_Alert = { .rg = TLS_point((krml_checked_int_t)2), ._1 = ad } }
        }
      ));
  if (res.tag == FStar_Error_Error)
  {
    K___Parsers_Alert_alert_Prims_string xy = res._0;
    return TLS_unrecoverable(c, FStar_Pervasives_Native_snd__Parsers_Alert_alert_Prims_string(xy));
  }
  else if (res.tag == FStar_Error_Correct)
    if
    (
      __eq__Parsers_AlertDescription_alertDescription(ad.description,
        Parsers_AlertDescription_Close_notify)
    )
    {
      c.state[0U] =
        (
          (K___Connection_halfState_Connection_halfState){
            .fst = FStar_Pervasives_Native_fst__Connection_halfState_Connection_halfState(st),
            .snd = Connection_Closed
          }
        );
      return ((TLS_ioresult_w){ .tag = TLS_WriteClose });
    }
    else
    {
      TLS_disconnect(c);
      return
        (
          (TLS_ioresult_w){
            .tag = TLS_WriteError,
            .val = {
              .case_WriteError = {
                .o = { .tag = FStar_Pervasives_Native_Some, .v = ad },
                .txt = reason
              }
            }
          }
        );
    }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct
K___FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes_bool_s
{
  FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes fst;
  bool snd;
}
K___FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes_bool;

static FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
TLS_sendHandshake(
  Connection_connection c,
  TLSInfo_id i1,
  FStar_Pervasives_Native_option__StAE_state wopt,
  FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes om,
  bool send_ccs
)
{
  TLS_print("sendHandshake");
  K___FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes_bool
  scrut = { .fst = om, .snd = send_ccs };
  if (scrut.fst.tag == FStar_Pervasives_Native_Some && scrut.snd == false)
  {
    FStar_Bytes_bytes f = scrut.fst.v.snd;
    K___Prims_int_Prims_int rg1 = scrut.fst.v.fst;
    return
      TLS_sendFragment(c,
        i1,
        wopt,
        (
          (Content_fragment){
            .tag = Content_CT_Handshake,
            .val = { .case_CT_Handshake = { .rg = rg1, .f = f } }
          }
        ));
  }
  else if (scrut.fst.tag == FStar_Pervasives_Native_Some && scrut.snd == true)
  {
    FStar_Bytes_bytes f = scrut.fst.v.snd;
    K___Prims_int_Prims_int rg1 = scrut.fst.v.fst;
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
    result =
      TLS_sendFragment(c,
        i1,
        wopt,
        (
          (Content_fragment){
            .tag = Content_CT_Handshake,
            .val = { .case_CT_Handshake = { .rg = rg1, .f = f } }
          }
        ));
    if (result.tag == FStar_Error_Error)
      return result;
    else
      return
        TLS_sendFragment(c,
          i1,
          wopt,
          (
            (Content_fragment){
              .tag = Content_CT_CCS,
              .val = { .case_CT_CCS = TLS_point((krml_checked_int_t)1) }
            }
          ));
  }
  else if (scrut.snd == true)
    return
      TLS_sendFragment(c,
        i1,
        wopt,
        (
          (Content_fragment){
            .tag = Content_CT_CCS,
            .val = { .case_CT_CCS = TLS_point((krml_checked_int_t)1) }
          }
        ));
  else
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___){
          .tag = FStar_Error_Correct
        }
      );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
TLS_next_fragment(TLSInfo_id i1, Connection_connection c)
{
  Old_Handshake_hs_ s = c.hs;
  Prims_list__Old_Epochs_epoch **ilog1 = Old_Handshake_es_of(s);
  Prims_int w0 = Old_Handshake_i(s, TLSConstants_Writer);
  if (Prims_op_GreaterThanOrEqual(w0, (krml_checked_int_t)0))
  {
    
  }
  Prims_string ite;
  if (TLSInfo_uu___is_ID12(i1))
    ite = "ID12";
  else if (TLSInfo_uu___is_ID13(i1))
    ite = "ID13";
  else
    ite = "PlaintextID";
  TLS_print(Prims_strcat("HS.next_fragment ", Prims_strcat(ite, "\?")));
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
  res = Old_Handshake_next_fragment(s, i1);
  return res;
}

static bool
FStar_Pervasives_Native_uu___is_Some__StAE_state(
  FStar_Pervasives_Native_option__StAE_state projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static bool
FStar_Pervasives_Native_uu___is_Some__Prims_dtuple2_Prims_int___Prims_int_FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes
  projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static bool
FStar_Pervasives_Native_uu___is_Some__HandshakeLog_next_keys_use(
  FStar_Pervasives_Native_option__HandshakeLog_next_keys_use projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static bool
FStar_Pervasives_Native_uu___is_Some__bool(FStar_Pervasives_Native_option__bool projectee)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static bool
FStar_Pervasives_Native_uu___is_None__Prims_dtuple2_Prims_int___Prims_int_FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes
  projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_None)
    return true;
  else
    return false;
}

typedef struct K___FStar_Pervasives_Native_option__bool_bool_bool_s
{
  FStar_Pervasives_Native_option__bool fst;
  bool snd;
  bool thd;
}
K___FStar_Pervasives_Native_option__bool_bool_bool;

TLS_ioresult_w
TLS_writeHandshake(Connection_connection c, FStar_Pervasives_Native_option__bool new_writer)
{
  TLSInfo_id i1 = TLS_currentId(c, TLSConstants_Writer);
  FStar_Pervasives_Native_option__StAE_state wopt = TLS_current_writer(c, i1);
  Prims_string ite0;
  if (FStar_Pervasives_Native_uu___is_Some__StAE_state(wopt))
    ite0 = " (encrypted)";
  else
    ite0 = " (plaintext)";
  TLS_print(Prims_strcat("writeHandshake", ite0));
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_HandshakeLog_outgoing
  scrut0 = TLS_next_fragment(i1, c);
  if (scrut0.tag == FStar_Error_Error)
  {
    Prims_string reason = scrut0.val.case_Error.snd;
    Parsers_Alert_alert ad = scrut0.val.case_Error.fst;
    return TLS_sendAlert(c, ad, reason);
  }
  else if (scrut0.tag == FStar_Error_Correct)
  {
    bool complete = scrut0.val.case_Correct.complete;
    FStar_Pervasives_Native_option__HandshakeLog_next_keys_use
    next_keys = scrut0.val.case_Correct.next_keys;
    FStar_Pervasives_Native_option__Prims_dtuple2__K___Prims_int_Prims_int_FStar_Bytes_bytes
    om = scrut0.val.case_Correct.send_first;
    K___FStar_Pervasives_Native_option__bool_bool_bool scrut;
    if (next_keys.tag == FStar_Pervasives_Native_Some)
    {
      HandshakeLog_next_keys_use u2 = next_keys.v;
      scrut =
        (
          (K___FStar_Pervasives_Native_option__bool_bool_bool){
            .fst = { .tag = FStar_Pervasives_Native_Some, .v = u2.out_appdata },
            .snd = u2.out_ccs_first,
            .thd = u2.out_skip_0RTT
          }
        );
    }
    else if (next_keys.tag == FStar_Pervasives_Native_None)
      scrut =
        (
          (K___FStar_Pervasives_Native_option__bool_bool_bool){
            .fst = new_writer,
            .snd = false,
            .thd = false
          }
        );
    else
      scrut =
        KRML_EABORT(K___FStar_Pervasives_Native_option__bool_bool_bool,
          "unreachable (pattern matches are exhaustive in F*)");
    FStar_Pervasives_Native_option__bool new_writer1 = scrut.fst;
    bool send_ccs = scrut.snd;
    bool skip_0rtt = scrut.thd;
    Prims_string ite0;
    if
    (
      FStar_Pervasives_Native_uu___is_Some__Prims_dtuple2_Prims_int___Prims_int_FStar_Bytes_bytes(om)
    )
      ite0 = "a fragment";
    else
      ite0 = "nothing";
    Prims_string ite1;
    if (send_ccs)
      ite1 = "; CCS";
    else
      ite1 = "";
    Prims_string ite2;
    if (next_keys.tag == FStar_Pervasives_Native_None)
      ite2 = "";
    else if (next_keys.tag == FStar_Pervasives_Native_Some)
    {
      HandshakeLog_next_keys_use u2 = next_keys.v;
      Prims_string ite0;
      if (u2.out_appdata)
        ite0 = "(for all data)";
      else
        ite0 = "(for handshake only";
      Prims_string ite;
      if (u2.out_skip_0RTT)
        ite = " skipping 0RTT";
      else
        ite = "";
      ite2 = Prims_strcat("; next_keys ", Prims_strcat(ite0, ite));
    }
    else
      ite2 = KRML_EABORT(Prims_string, "unreachable (pattern matches are exhaustive in F*)");
    Prims_string ite3;
    if (complete)
      ite3 = "; complete";
    else
      ite3 = "";
    TLS_print(Prims_strcat("HS.next_fragment returned ",
        Prims_strcat(ite0, Prims_strcat(ite1, Prims_strcat(ite2, ite3)))));
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
    scrut0 = TLS_sendHandshake(c, i1, wopt, om, send_ccs);
    if (scrut0.tag == FStar_Error_Error)
    {
      Prims_string reason = scrut0._0.snd;
      Parsers_Alert_alert ad = scrut0._0.fst;
      TLS_recall_current_writer(c);
      return TLS_sendAlert(c, ad, reason);
    }
    else
    {
      TLS_recall_current_writer(c);
      Prims_int j_ = Old_Handshake_i(c.hs, TLSConstants_Writer);
      if (FStar_Pervasives_Native_uu___is_Some__HandshakeLog_next_keys_use(next_keys))
        Old_Epochs_incr_writer(Old_Handshake_random_of(c.hs), Old_Handshake_epochs_of(c.hs));
      if (skip_0rtt)
        Old_Epochs_incr_writer(Old_Handshake_random_of(c.hs), Old_Handshake_epochs_of(c.hs));
      K___Connection_halfState_Connection_halfState scrut = c.state[0U];
      Connection_halfState str = scrut.fst;
      if (complete)
        c.state[0U] =
          (
            (K___Connection_halfState_Connection_halfState){
              .fst = Connection_Open,
              .snd = Connection_Open
            }
          );
      else if (next_keys.tag == FStar_Pervasives_Native_Some)
      {
        HandshakeLog_next_keys_use b = next_keys.v;
        Connection_halfState ite;
        if (b.out_appdata)
          ite = Connection_Open;
        else
          ite = Connection_Ctrl;
        c.state[0U] = ((K___Connection_halfState_Connection_halfState){ .fst = str, .snd = ite });
      }
      else if (!(next_keys.tag == FStar_Pervasives_Native_None))
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
      if
      (
        complete
        || FStar_Pervasives_Native_uu___is_Some__bool(new_writer1)
        ||
          FStar_Pervasives_Native_uu___is_None__Prims_dtuple2_Prims_int___Prims_int_FStar_Bytes_bytes(om)
          && !send_ccs
      )
        return
          (
            (TLS_ioresult_w){
              .tag = TLS_WrittenHS,
              .val = { .case_WrittenHS = { .newWriter = new_writer1, .complete = complete } }
            }
          );
      else if (FStar_Pervasives_Native_uu___is_Some__bool(new_writer1))
      {
        Prims_int j_1 = Old_Handshake_i(c.hs, TLSConstants_Writer);
        return TLS_writeHandshake(c, new_writer1);
      }
      else
        return TLS_writeHandshake(c, new_writer1);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLS_ioresult_w
TLS_write(
  Connection_connection c,
  TLSInfo_id i1,
  K___Prims_int_Prims_int rg1,
  FStar_Bytes_bytes data
)
{
  FStar_Pervasives_Native_option__StAE_state wopt = TLS_current_writer(c, i1);
  TLS_ioresult_w
  scrut =
    TLS_writeHandshake(c,
      ((FStar_Pervasives_Native_option__bool){ .tag = FStar_Pervasives_Native_None }));
  if
  (
    scrut.tag
    == TLS_WrittenHS
    && scrut.val.case_WrittenHS.newWriter.tag == FStar_Pervasives_Native_None
  )
  {
    Content_fragment
    frag = { .tag = Content_CT_Data, .val = { .case_CT_Data = { .rg = rg1, .f = data } } };
    FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string___
    scrut = TLS_sendFragment(c, i1, wopt, frag);
    if (scrut.tag == FStar_Error_Error)
    {
      Prims_string reason = scrut._0.snd;
      Parsers_Alert_alert ad = scrut._0.fst;
      return TLS_sendAlert(c, ad, reason);
    }
    else
      return ((TLS_ioresult_w){ .tag = TLS_Written });
  }
  else
    return scrut;
}

TLS_ioresult_w TLS_writeCloseNotify(Connection_connection c)
{
  TLS_print("writeCloseNotify");
  return
    TLS_sendAlert(c,
      (
        (Parsers_Alert_alert){
          .level = Parsers_AlertLevel_Warning,
          .description = Parsers_AlertDescription_Close_notify
        }
      ),
      "full shutdown");
}

TLS_ioresult_w TLS_writeClose(Connection_connection c)
{
  TLS_ioresult_w
  r =
    TLS_sendAlert(c,
      (
        (Parsers_Alert_alert){
          .level = Parsers_AlertLevel_Warning,
          .description = Parsers_AlertDescription_Close_notify
        }
      ),
      "half shutdown");
  c.state[0U] =
    (
      (K___Connection_halfState_Connection_halfState){
        .fst = Connection_Closed,
        .snd = Connection_Closed
      }
    );
  return r;
}

bool TLS_uu___is_ReadWouldBlock(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_ReadWouldBlock)
    return true;
  else
    return false;
}

bool TLS_uu___is_Read(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_Read)
    return true;
  else
    return false;
}

DataStream_delta TLS___proj__Read__item___0(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_Read)
    return projectee.val.case_Read;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS_uu___is_ReadError(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_ReadError)
    return true;
  else
    return false;
}

FStar_Pervasives_Native_option__Parsers_Alert_alert
TLS___proj__ReadError__item__o(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_ReadError)
    return projectee.val.case_ReadError.o;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_string TLS___proj__ReadError__item__txt(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_ReadError)
    return projectee.val.case_ReadError.txt;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS_uu___is_CertQuery(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_CertQuery)
    return true;
  else
    return false;
}

Prims_list__FStar_Bytes_bytes
*TLS___proj__CertQuery__item___0(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_CertQuery)
    return projectee.val.case_CertQuery._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS___proj__CertQuery__item___1(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_CertQuery)
    return projectee.val.case_CertQuery._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS_uu___is_Update(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_Update)
    return true;
  else
    return false;
}

bool TLS___proj__Update__item__writeable(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_Update)
    return projectee.val.case_Update;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS_uu___is_Complete(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_Complete)
    return true;
  else
    return false;
}

bool TLS_uu___is_ReadAgain(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_ReadAgain)
    return true;
  else
    return false;
}

bool TLS_uu___is_ReadAgainFinishing(TLSInfo_id i1, TLS_ioresult_i projectee)
{
  if (projectee.tag == TLS_ReadAgainFinishing)
    return true;
  else
    return false;
}

Prims_string TLS_string_of_ioresult_i(TLSInfo_id i1, TLS_ioresult_i uu___1_4018)
{
  if (uu___1_4018.tag == TLS_ReadWouldBlock)
    return "ReadWouldBlock";
  else if (uu___1_4018.tag == TLS_Read && uu___1_4018.val.case_Read.tag == DataStream_Data)
  {
    FStar_Bytes_bytes d = uu___1_4018.val.case_Read.val.case_Data;
    return
      Prims_strcat("Read ",
        Prims_strcat(Prims_string_of_int(FStar_UInt32_v(FStar_Bytes_len(DataStream_appBytes(i1,
                  Range_fragment_range,
                  d)))),
          " bytes of data"));
  }
  else if (uu___1_4018.tag == TLS_Read && uu___1_4018.val.case_Read.tag == DataStream_Close)
    return "Read Close";
  else if (uu___1_4018.tag == TLS_Read && uu___1_4018.val.case_Read.tag == DataStream_Alert)
  {
    Parsers_Alert_alert a = uu___1_4018.val.case_Read.val.case_Alert;
    return Prims_strcat("Read Alert ", TLSError_string_of_alert(a));
  }
  else if
  (
    uu___1_4018.tag
    == TLS_ReadError
    && uu___1_4018.val.case_ReadError.o.tag == FStar_Pervasives_Native_Some
  )
  {
    Prims_string txt = uu___1_4018.val.case_ReadError.txt;
    Parsers_Alert_alert o = uu___1_4018.val.case_ReadError.o.v;
    return
      Prims_strcat("ReadError ",
        TLSError_string_of_error(((K___Parsers_Alert_alert_Prims_string){ .fst = o, .snd = txt })));
  }
  else if
  (
    uu___1_4018.tag
    == TLS_ReadError
    && uu___1_4018.val.case_ReadError.o.tag == FStar_Pervasives_Native_None
  )
  {
    Prims_string txt = uu___1_4018.val.case_ReadError.txt;
    return Prims_strcat("ReadError ", txt);
  }
  else if (uu___1_4018.tag == TLS_CertQuery)
    return "CertQuery";
  else if (uu___1_4018.tag == TLS_Update)
  {
    bool b = uu___1_4018.val.case_Update;
    Prims_string ite;
    if (b)
      ite = "writable";
    else
      ite = "read-only";
    return Prims_strcat("Update ", ite);
  }
  else if (uu___1_4018.tag == TLS_Complete)
    return "Complete";
  else if (uu___1_4018.tag == TLS_ReadAgain)
    return "ReadAgain";
  else if (uu___1_4018.tag == TLS_ReadAgainFinishing)
    return "ReadAgainFinishing";
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLS_live_i(TLSInfo_id e, TLS_ioresult_i r)
{
  if (r.tag == TLS_Read)
  {
    DataStream_delta d = r.val.case_Read;
    return !DataStream_final(e, d);
  }
  else if (r.tag == TLS_ReadError)
    return false;
  else
    return true;
}

TLS_ioresult_i
TLS_alertFlush(
  Connection_connection c,
  TLSInfo_id ri,
  Parsers_Alert_alert a,
  Prims_string reason
)
{
  TLS_ioresult_w written = TLS_sendAlert(c, a, reason);
  if (written.tag == TLS_WriteClose)
    return
      ((TLS_ioresult_i){ .tag = TLS_Read, .val = { .case_Read = { .tag = DataStream_Close } } });
  else if (written.tag == TLS_WriteError)
  {
    Prims_string y = written.val.case_WriteError.txt;
    FStar_Pervasives_Native_option__Parsers_Alert_alert x = written.val.case_WriteError.o;
    return
      ((TLS_ioresult_i){ .tag = TLS_ReadError, .val = { .case_ReadError = { .o = x, .txt = y } } });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment
TLSError_fatal__FStar_Pervasives_Native_option_Content_fragment(
  Parsers_AlertDescription_alertDescription a,
  Prims_string s
)
{
  return
    (
      (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment){
        .tag = FStar_Error_Error,
        .val = { .case_Error = { .fst = TLSError_fatalAlert(a), .snd = s } }
      }
    );
}

FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment
TLS_readFragment(Connection_connection c, TLSInfo_id i1)
{
  Record_read_result scrut = Record_read(c.tcp, c.recv);
  if (scrut.tag == Record_ReadError)
  {
    K___Parsers_Alert_alert_Prims_string e = scrut.val.case_ReadError;
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment){
          .tag = FStar_Error_Error,
          .val = { .case_Error = e }
        }
      );
  }
  else if (scrut.tag == Record_ReadWouldBlock)
    return
      (
        (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment){
          .tag = FStar_Error_Correct,
          .val = { .case_Correct = { .tag = FStar_Pervasives_Native_None } }
        }
      );
  else if (scrut.tag == Record_Received)
  {
    FStar_Bytes_bytes payload = scrut.val.case_Received.b;
    Content_contentType ct1 = scrut.val.case_Received.ct;
    Prims_list__Old_Epochs_epoch *es = Old_Handshake_es_of(c.hs)[0U];
    Prims_int j1 = Old_Handshake_i(c.hs, TLSConstants_Reader);
    TLS_print(Prims_strcat("Read fragment at epoch index: ",
        Prims_strcat(Prims_string_of_int(j1),
          Prims_strcat(" of length ", Prims_string_of_int(FStar_UInt32_v(FStar_Bytes_len(payload)))))));
    if (Prims_op_LessThan(j1, (krml_checked_int_t)0))
    {
      K___Prims_int_Prims_int rg1 = Range_point(FStar_UInt32_v(FStar_Bytes_len(payload)));
      return
        (
          (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment){
            .tag = FStar_Error_Correct,
            .val = {
              .case_Correct = {
                .tag = FStar_Pervasives_Native_Some,
                .v = Content_mk_fragment(i1, ct1, rg1, payload)
              }
            }
          }
        );
    }
    else
    {
      Old_Epochs_epoch e = FStar_Seq_Base_index__Old_Epochs_epoch(es, j1);
      StAE_state rd = e.r;
      bool tccs = StAE_tolerate_ccs(i1, rd);
      if (__eq__FStar_Bytes_bytes(payload, FStar_Bytes_abyte((uint8_t)1U)) && tccs)
      {
        TLS_print("Ignoring a CCS");
        return TLS_readFragment(c, i1);
      }
      else if (!TLS_valid_clen(i1, FStar_UInt32_v(FStar_Bytes_len(payload))))
      {
        TLS_print(Prims_strcat("bad payload: ", FStar_Bytes_print_bytes(payload)));
        return
          TLSError_fatal__FStar_Pervasives_Native_option_Content_fragment(Parsers_AlertDescription_Illegal_parameter,
            "Invalid ciphertext length");
      }
      else
      {
        FStar_Bytes_bytes x1 = Old_Handshake_random_of(c.hs);
        FStar_Pervasives_Native_option__Content_fragment
        scrut =
          StAE_decrypt(TLSInfo_peerId(e.i),
            Old_Epochs_reader_epoch(Old_Handshake_random_of(c.hs), e),
            ((K___Content_contentType_FStar_Bytes_bytes){ .fst = ct1, .snd = payload }));
        if (scrut.tag == FStar_Pervasives_Native_None)
        {
          TLS_print("StAE decrypt failed.");
          bool is_0rtt_offered1 = Old_Handshake_is_0rtt_offered(c.hs);
          bool tolerate_df = StAE_tolerate_decrypt_failure(i1, rd);
          if (is_0rtt_offered1 && tolerate_df)
          {
            TLS_print("Ignoring the decryption failure (rejected 0-RTT data)");
            return TLS_readFragment(c, i1);
          }
          else
            return
              TLSError_fatal__FStar_Pervasives_Native_option_Content_fragment(Parsers_AlertDescription_Bad_record_mac,
                "Decryption failure");
        }
        else if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          Content_fragment f = scrut.v;
          TLS_print("StAE decrypt correct.");
          return
            (
              (FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment){
                .tag = FStar_Error_Correct,
                .val = { .case_Correct = { .tag = FStar_Pervasives_Native_Some, .v = f } }
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Connection_halfState
FStar_Pervasives_Native_snd__Connection_halfState_Connection_halfState(
  K___Connection_halfState_Connection_halfState x
)
{
  return x.snd;
}

static TLS_ioresult_i TLS_readOne(Connection_connection c, TLSInfo_id i1)
{
  FStar_Error_optResult__K___Parsers_Alert_alert_Prims_string_FStar_Pervasives_Native_option__Content_fragment
  scrut = TLS_readFragment(c, i1);
  if (scrut.tag == FStar_Error_Error)
  {
    Prims_string y = scrut.val.case_Error.snd;
    Parsers_Alert_alert x = scrut.val.case_Error.fst;
    switch (x.description)
    {
      case Parsers_AlertDescription_Internal_error:
        {
          if (__eq__Prims_string(y, "TCP close"))
          {
            TLS_disconnect(c);
            return
              (
                (TLS_ioresult_i){
                  .tag = TLS_ReadError,
                  .val = {
                    .case_ReadError = {
                      .o = { .tag = FStar_Pervasives_Native_None },
                      .txt = "TCP close"
                    }
                  }
                }
              );
          }
          else
            return TLS_alertFlush(c, i1, x, y);
          break;
        }
      default:
        {
          return TLS_alertFlush(c, i1, x, y);
        }
    }
  }
  else if
  (
    scrut.tag
    == FStar_Error_Correct
    && scrut.val.case_Correct.tag == FStar_Pervasives_Native_None
  )
    return ((TLS_ioresult_i){ .tag = TLS_ReadWouldBlock });
  else if
  (
    scrut.tag
    == FStar_Error_Correct
    && scrut.val.case_Correct.tag == FStar_Pervasives_Native_Some
  )
  {
    Content_fragment f = scrut.val.case_Correct.v;
    if (f.tag == Content_CT_Alert)
    {
      Parsers_Alert_alert ad = f.val.case_CT_Alert._1;
      TLS_print(Prims_strcat("read Alert fragment ", TLSError_string_of_alert(ad)));
      if
      (
        __eq__Parsers_AlertDescription_alertDescription(ad.description,
          Parsers_AlertDescription_Close_notify)
      )
        if
        (
          Connection_uu___is_Closed(FStar_Pervasives_Native_snd__Connection_halfState_Connection_halfState(c.state[0U]))
        )
        {
          c.state[0U] =
            (
              (K___Connection_halfState_Connection_halfState){
                .fst = Connection_Closed,
                .snd = Connection_Closed
              }
            );
          return
            (
              (TLS_ioresult_i){
                .tag = TLS_Read,
                .val = { .case_Read = { .tag = DataStream_Close } }
              }
            );
        }
        else
        {
          K___Connection_halfState_Connection_halfState
          uu____0 =
            {
              .fst = Connection_Closed,
              .snd = FStar_Pervasives_Native_snd__Connection_halfState_Connection_halfState(c.state[0U])
            };
          c.state[0U] = uu____0;
          return
            TLS_alertFlush(c,
              i1,
              (
                (Parsers_Alert_alert){
                  .level = Parsers_AlertLevel_Warning,
                  .description = Parsers_AlertDescription_Close_notify
                }
              ),
              "notify response");
        }
      else
      {
        if (__eq__Parsers_AlertLevel_alertLevel(ad.level, Parsers_AlertLevel_Fatal))
          TLS_disconnect(c);
        return
          (
            (TLS_ioresult_i){
              .tag = TLS_Read,
              .val = { .case_Read = { .tag = DataStream_Alert, .val = { .case_Alert = ad } } }
            }
          );
      }
    }
    else if (f.tag == Content_CT_Handshake)
    {
      FStar_Bytes_bytes f1 = f.val.case_CT_Handshake.f;
      K___Prims_int_Prims_int rg1 = f.val.case_CT_Handshake.rg;
      TLS_print("read Handshake fragment");
      Old_Handshake_incoming scrut = Old_Handshake_recv_fragment(c.hs, i1, rg1, f1);
      if (scrut.tag == Old_Handshake_InError)
      {
        Prims_string y = scrut.val.case_InError.snd;
        Parsers_Alert_alert x = scrut.val.case_InError.fst;
        return TLS_alertFlush(c, i1, x, y);
      }
      else if (scrut.tag == Old_Handshake_InQuery)
      {
        bool a = scrut.val.case_InQuery._1;
        Prims_list__FStar_Bytes_bytes *q = scrut.val.case_InQuery._0;
        return
          (
            (TLS_ioresult_i){
              .tag = TLS_CertQuery,
              .val = { .case_CertQuery = { ._0 = q, ._1 = a } }
            }
          );
      }
      else if (scrut.tag == Old_Handshake_InAck)
      {
        bool complete = scrut.val.case_InAck.complete;
        if (complete)
        {
          c.state[0U] =
            (
              (K___Connection_halfState_Connection_halfState){
                .fst = Connection_Open,
                .snd = Connection_Open
              }
            );
          return ((TLS_ioresult_i){ .tag = TLS_Complete });
        }
        else
          return ((TLS_ioresult_i){ .tag = TLS_ReadAgain });
      }
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (f.tag == Content_CT_CCS)
    {
      TLS_print("read CCS fragment");
      Old_Handshake_incoming scrut = Old_Handshake_recv_ccs(c.hs);
      if (scrut.tag == Old_Handshake_InError)
      {
        Prims_string y = scrut.val.case_InError.snd;
        Parsers_Alert_alert x = scrut.val.case_InError.fst;
        return TLS_alertFlush(c, i1, x, y);
      }
      else if
      (
        scrut.tag
        == Old_Handshake_InAck
        && scrut.val.case_InAck.next_keys == false && scrut.val.case_InAck.complete == false
      )
        return ((TLS_ioresult_i){ .tag = TLS_ReadAgain });
      else if
      (
        scrut.tag
        == Old_Handshake_InAck
        && scrut.val.case_InAck.next_keys == true && scrut.val.case_InAck.complete == false
      )
        return ((TLS_ioresult_i){ .tag = TLS_ReadAgainFinishing });
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (f.tag == Content_CT_Data)
    {
      FStar_Bytes_bytes f1 = f.val.case_CT_Data.f;
      TLS_print("read Data fragment");
      Connection_halfState
      uu____1 = FStar_Pervasives_Native_fst__Connection_halfState_Connection_halfState(c.state[0U]);
      FStar_Bytes_bytes f2 = f1;
      return
        (
          (TLS_ioresult_i){
            .tag = TLS_Read,
            .val = { .case_Read = { .tag = DataStream_Data, .val = { .case_Data = f2 } } }
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct K___FStar_Pervasives_Native_option__bool_bool_s
{
  FStar_Pervasives_Native_option__bool fst;
  bool snd;
}
K___FStar_Pervasives_Native_option__bool_bool;

bool
__eq__FStar_Pervasives_Native_option__bool(
  FStar_Pervasives_Native_option__bool y,
  FStar_Pervasives_Native_option__bool x
)
{
  if (x.tag == FStar_Pervasives_Native_None)
    if (y.tag == FStar_Pervasives_Native_None)
      return true;
    else
      return false;
  else if (x.tag == FStar_Pervasives_Native_Some)
  {
    bool x_v = x.v;
    if (y.tag == FStar_Pervasives_Native_Some)
    {
      bool y_v = y.v;
      return true && y_v == x_v;
    }
    else
      return false;
  }
  else
    return false;
}

bool __eq__Connection_halfState(Connection_halfState y, Connection_halfState x)
{
  switch (x)
  {
    case Connection_Ctrl:
      {
        switch (y)
        {
          case Connection_Ctrl:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Connection_Open:
      {
        switch (y)
        {
          case Connection_Open:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Connection_Closed:
      {
        switch (y)
        {
          case Connection_Closed:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

TLS_ioresult_i TLS_read(Connection_connection c, TLSInfo_id i1)
{
  K___Connection_halfState_Connection_halfState st0 = c.state[0U];
  TLS_ioresult_w
  r =
    TLS_writeHandshake(c,
      ((FStar_Pervasives_Native_option__bool){ .tag = FStar_Pervasives_Native_None }));
  if (r.tag == TLS_WriteError)
  {
    Prims_string y = r.val.case_WriteError.txt;
    FStar_Pervasives_Native_option__Parsers_Alert_alert x = r.val.case_WriteError.o;
    return
      ((TLS_ioresult_i){ .tag = TLS_ReadError, .val = { .case_ReadError = { .o = x, .txt = y } } });
  }
  else if (r.tag == TLS_WriteClose)
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "Sent Close");
    KRML_HOST_EXIT(255U);
  }
  else if (r.tag == TLS_WrittenHS)
  {
    bool complete = r.val.case_WrittenHS.complete;
    FStar_Pervasives_Native_option__bool newWriter = r.val.case_WrittenHS.newWriter;
    K___Connection_halfState_Connection_halfState st1 = c.state[0U];
    K___FStar_Pervasives_Native_option__bool_bool scrut = { .fst = newWriter, .snd = complete };
    Prims_string ite;
    if (scrut.fst.tag == FStar_Pervasives_Native_Some && scrut.snd == true)
      ite = "new writer: complete";
    else if (scrut.fst.tag == FStar_Pervasives_Native_Some && scrut.fst.v == true)
      ite = "new writer: writable";
    else if (scrut.fst.tag == FStar_Pervasives_Native_Some && scrut.fst.v == false)
      ite = "new writer: handshake-only";
    else if (scrut.fst.tag == FStar_Pervasives_Native_None && scrut.snd == true)
      ite = "same writer; complete";
    else if (scrut.fst.tag == FStar_Pervasives_Native_None && scrut.snd == false)
      ite = "nothing";
    else
      ite = KRML_EABORT(Prims_string, "unreachable (pattern matches are exhaustive in F*)");
    TLS_print(Prims_strcat("read: WrittenHS, ",
        Prims_strcat(Connection_string_of_state(st1), Prims_strcat(", ", ite))));
    if (complete)
      return ((TLS_ioresult_i){ .tag = TLS_Complete });
    else if
    (
      __eq__FStar_Pervasives_Native_option__bool(newWriter,
        ((FStar_Pervasives_Native_option__bool){ .tag = FStar_Pervasives_Native_Some, .v = true }))
    )
      return ((TLS_ioresult_i){ .tag = TLS_Update, .val = { .case_Update = true } });
    else if
    (
      __eq__FStar_Pervasives_Native_option__bool(newWriter,
        ((FStar_Pervasives_Native_option__bool){ .tag = FStar_Pervasives_Native_Some, .v = false }))
      &&
        __eq__Connection_halfState(FStar_Pervasives_Native_snd__Connection_halfState_Connection_halfState(st0),
          Connection_Ctrl)
    )
    {
      TLS_print("ignore handshake-specifc key change; calling read again");
      return TLS_read(c, i1);
    }
    else
    {
      TLS_ioresult_i result = TLS_readOne(c, i1);
      TLS_print(Prims_strcat("readOne ", TLS_string_of_ioresult_i(i1, result)));
      if (result.tag == TLS_ReadWouldBlock)
        return ((TLS_ioresult_i){ .tag = TLS_ReadWouldBlock });
      else if (result.tag == TLS_ReadAgain)
      {
        TLSInfo_id i_ = TLS_currentId(c, TLSConstants_Reader);
        return TLS_read(c, i_);
      }
      else if (result.tag == TLS_ReadAgainFinishing)
        return TLS_read(c, i1);
      else if (result.tag == TLS_ReadError)
      {
        Prims_string y = result.val.case_ReadError.txt;
        FStar_Pervasives_Native_option__Parsers_Alert_alert x = result.val.case_ReadError.o;
        return
          (
            (TLS_ioresult_i){
              .tag = TLS_ReadError,
              .val = { .case_ReadError = { .o = x, .txt = y } }
            }
          );
      }
      else if (result.tag == TLS_CertQuery)
      {
        bool adv = result.val.case_CertQuery._1;
        Prims_list__FStar_Bytes_bytes *q = result.val.case_CertQuery._0;
        return
          (
            (TLS_ioresult_i){
              .tag = TLS_CertQuery,
              .val = { .case_CertQuery = { ._0 = q, ._1 = adv } }
            }
          );
      }
      else if (result.tag == TLS_Read)
      {
        DataStream_delta delta1 = result.val.case_Read;
        return ((TLS_ioresult_i){ .tag = TLS_Read, .val = { .case_Read = delta1 } });
      }
      else if (result.tag == TLS_Complete)
        return ((TLS_ioresult_i){ .tag = TLS_Complete });
      else
      {
        KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

