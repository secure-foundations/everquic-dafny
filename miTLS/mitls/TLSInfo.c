/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: D:\everest\kremlin\_build\src\Kremlin.native -minimal -add-include "kremlib.h" -fnoanonymous-unions -warn-error -9-7-6@4-14-15 -fsopts --debug,yes -verbose -library EverCrypt,EverCrypt.*,Hacl.*,Interop_assumptions,Check_sha_stdcall,Sha_update_bytes_stdcall,Check_aesni_stdcall -drop MonotoneMap -drop MonotoneMapNonDep -drop FStar.Tactics.\* -drop FStar.Tactics -drop Crypto.AEAD.\* -drop Crypto.HKDF -drop Crypto.HMAC -add-include "hacks.h" -add-include "kremlin/internal/compat.h" -bundle LowParse.\*,LowParseWrappers[rename=LowParse] -bundle Format.\* -bundle EverCrypt=EverCrypt,EverCrypt.\* -bundle FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib] -bundle Parsers.\* -bundle Spec.\* -bundle Meta.\* -bundle Lib.*[rename=Hacl_Lib] -bundle Hacl.\* -bundle KDF.\*,KDF,Idx,IV,Pkg,Pkg.\*[rename=Pkg] -bundle TLSConstants=TLSConstants,QD.TLS_protocolVersion,List.Helpers -bundle Hashing=Hashing.Spec,Hashing,Hashing.CRF,HMAC,HKDF,HMAC.UFCMA -bundle Old.Handshake=Old.HMAC.UFCMA,Old.Epochs,Old.KeySchedule,Old.Handshake -bundle StatefulLHAE=AEAD_GCM,LHAEPlain,StatefulPlain,StatefulLHAE -bundle StreamAE=StreamPlain,StreamAE -bundle CommonDH=TLS.Curve25519,DHGroup,ECGroup,CommonDH -bundle Content=Content,DataStream -bundle Record=Record,StAE,Transport,StreamDeltas -bundle PMS=PMS,RSAKey,TLSPRF -bundle Crypto.Plain=Buffer.Utils,Crypto.Indexing,Crypto.Plain,Crypto.Symmetric.Bytes -bundle Flags=DebugFlags,Flags,Flag,TLSInfoFlags -bundle Vale.Stdcalls.*,Vale.Interop,Vale.Interop.*,Vale.Wrapper.X64.*[rename=Vale] -bundle Vale.Inline.X64.*[rename=Vale_Inline] -bundle Vale.*[rename=Unused2] -ldopts -L,D:/everest/MLCrypto/openssl,-lcrypto,-lssl extract/Kremlin/FStar_Pervasives_Native.krml extract/Kremlin/FStar_Pervasives.krml extract/Kremlin/FStar_Squash.krml extract/Kremlin/FStar_Classical.krml extract/Kremlin/FStar_Preorder.krml extract/Kremlin/FStar_Calc.krml extract/Kremlin/FStar_Mul.krml extract/Kremlin/FStar_Math_Lib.krml extract/Kremlin/FStar_Math_Lemmas.krml extract/Kremlin/FStar_StrongExcludedMiddle.krml extract/Kremlin/FStar_FunctionalExtensionality.krml extract/Kremlin/FStar_List_Tot_Base.krml extract/Kremlin/FStar_List_Tot_Properties.krml extract/Kremlin/FStar_List_Tot.krml extract/Kremlin/FStar_Seq_Base.krml extract/Kremlin/FStar_Seq_Properties.krml extract/Kremlin/FStar_Seq.krml extract/Kremlin/FStar_BitVector.krml extract/Kremlin/FStar_UInt.krml extract/Kremlin/FStar_UInt32.krml extract/Kremlin/FStar_UInt8.krml extract/Kremlin/FStar_Exn.krml extract/Kremlin/FStar_Set.krml extract/Kremlin/FStar_Monotonic_Witnessed.krml extract/Kremlin/FStar_Ghost.krml extract/Kremlin/FStar_ErasedLogic.krml extract/Kremlin/FStar_PropositionalExtensionality.krml extract/Kremlin/FStar_PredicateExtensionality.krml extract/Kremlin/FStar_TSet.krml extract/Kremlin/FStar_Monotonic_Heap.krml extract/Kremlin/FStar_Heap.krml extract/Kremlin/FStar_ST.krml extract/Kremlin/FStar_All.krml extract/Kremlin/Lib_LoopCombinators.krml extract/Kremlin/FStar_Int.krml extract/Kremlin/FStar_Int64.krml extract/Kremlin/FStar_Int63.krml extract/Kremlin/FStar_Int32.krml extract/Kremlin/FStar_Int16.krml extract/Kremlin/FStar_Int8.krml extract/Kremlin/FStar_UInt64.krml extract/Kremlin/FStar_UInt63.krml extract/Kremlin/FStar_UInt16.krml extract/Kremlin/FStar_Int_Cast.krml extract/Kremlin/FStar_UInt128.krml extract/Kremlin/FStar_Int_Cast_Full.krml extract/Kremlin/FStar_Int128.krml extract/Kremlin/Lib_IntTypes.krml extract/Kremlin/Lib_RawIntTypes.krml extract/Kremlin/Lib_Sequence.krml extract/Kremlin/Lib_ByteSequence.krml extract/Kremlin/Spec_Chacha20.krml extract/Kremlin/Meta_Attribute.krml extract/Kremlin/FStar_Map.krml extract/Kremlin/FStar_Monotonic_HyperHeap.krml extract/Kremlin/FStar_Monotonic_HyperStack.krml extract/Kremlin/FStar_HyperStack.krml extract/Kremlin/FStar_HyperStack_ST.krml extract/Kremlin/FStar_Universe.krml extract/Kremlin/FStar_GSet.krml extract/Kremlin/FStar_ModifiesGen.krml extract/Kremlin/FStar_Range.krml extract/Kremlin/FStar_Reflection_Types.krml extract/Kremlin/FStar_Tactics_Types.krml extract/Kremlin/FStar_Tactics_Result.krml extract/Kremlin/FStar_Tactics_Effect.krml extract/Kremlin/FStar_Reflection_Data.krml extract/Kremlin/FStar_Tactics_Builtins.krml extract/Kremlin/FStar_Reflection_Const.krml extract/Kremlin/FStar_Char.krml extract/Kremlin/FStar_List.krml extract/Kremlin/FStar_String.krml extract/Kremlin/FStar_Order.krml extract/Kremlin/FStar_Reflection_Basic.krml extract/Kremlin/FStar_Reflection_Derived.krml extract/Kremlin/FStar_Reflection_Derived_Lemmas.krml extract/Kremlin/FStar_Reflection.krml extract/Kremlin/FStar_Tactics_SyntaxHelpers.krml extract/Kremlin/FStar_Tactics_Util.krml extract/Kremlin/FStar_Reflection_Formula.krml extract/Kremlin/FStar_Tactics_Derived.krml extract/Kremlin/FStar_Tactics_Logic.krml extract/Kremlin/FStar_Tactics.krml extract/Kremlin/FStar_BigOps.krml extract/Kremlin/LowStar_Monotonic_Buffer.krml extract/Kremlin/LowStar_Buffer.krml extract/Kremlin/LowStar_BufferOps.krml extract/Kremlin/Spec_Loops.krml extract/Kremlin/C_Loops.krml extract/Kremlin/Lib_Loops.krml extract/Kremlin/FStar_Endianness.krml extract/Kremlin/LowStar_Endianness.krml extract/Kremlin/LowStar_ImmutableBuffer.krml extract/Kremlin/Lib_Buffer.krml extract/Kremlin/Lib_ByteBuffer.krml extract/Kremlin/FStar_HyperStack_All.krml extract/Kremlin/Lib_IntVector_Intrinsics.krml extract/Kremlin/Spec_GaloisField.krml extract/Kremlin/Spec_AES.krml extract/Kremlin/Lib_IntVector.krml extract/Kremlin/Hacl_Spec_Chacha20_Vec.krml extract/Kremlin/Hacl_Spec_Chacha20_Lemmas.krml extract/Kremlin/Lib_Sequence_Lemmas.krml extract/Kremlin/Hacl_Spec_Chacha20_Equiv.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32xN.krml extract/Kremlin/Hacl_Impl_Chacha20_Vec.krml extract/Kremlin/Vale_Lib_Seqs_s.krml extract/Kremlin/Vale_Def_Words_s.krml extract/Kremlin/Vale_Def_Words_Four_s.krml extract/Kremlin/Vale_Def_Words_Two_s.krml extract/Kremlin/Vale_Def_Words_Seq_s.krml extract/Kremlin/Vale_Def_Opaque_s.krml extract/Kremlin/Vale_Def_Types_s.krml extract/Kremlin/Vale_X64_Machine_s.krml extract/Kremlin/Vale_Lib_Map16.krml extract/Kremlin/Vale_Def_Prop_s.krml extract/Kremlin/Vale_X64_Flags.krml extract/Kremlin/Vale_X64_CPU_Features_s.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_internal.krml extract/Kremlin/Vale_Lib_Meta.krml extract/Kremlin/Vale_Def_Words_Two.krml extract/Kremlin/Vale_Lib_Seqs.krml extract/Kremlin/Vale_Def_TypesNative_s.krml extract/Kremlin/Vale_Arch_TypesNative.krml extract/Kremlin/Vale_Def_Words_Seq.krml extract/Kremlin/Vale_Arch_Types.krml extract/Kremlin/Vale_Curve25519_Fast_defs.krml extract/Kremlin/FStar_Algebra_CommMonoid.krml extract/Kremlin/FStar_Tactics_CanonCommSemiring.krml extract/Kremlin/Vale_Curve25519_FastUtil_helpers.krml extract/Kremlin/Vale_Curve25519_FastHybrid_helpers.krml extract/Kremlin/Vale_Curve25519_Fast_lemmas_external.krml extract/Kremlin/Vale_X64_Regs.krml extract/Kremlin/FStar_Float.krml extract/Kremlin/FStar_IO.krml extract/Kremlin/Vale_Def_PossiblyMonad.krml extract/Kremlin/LowStar_BufferView_Down.krml extract/Kremlin/LowStar_BufferView_Up.krml extract/Kremlin/Vale_Interop_Views.krml extract/Kremlin/FStar_Option.krml extract/Kremlin/Vale_Lib_Set.krml extract/Kremlin/Vale_X64_Instruction_s.krml extract/Kremlin/Vale_X64_Bytes_Code_s.krml extract/Kremlin/Vale_AES_AES_s.krml extract/Kremlin/Vale_Math_Poly2_Defs_s.krml extract/Kremlin/Vale_Math_Poly2_s.krml extract/Kremlin/Vale_Math_Poly2_Bits_s.krml extract/Kremlin/Spec_Hash_Definitions.krml extract/Kremlin/Spec_Hash_Lemmas0.krml extract/Kremlin/Spec_Hash_PadFinish.krml extract/Kremlin/Spec_SHA2_Constants.krml extract/Kremlin/Spec_SHA2.krml extract/Kremlin/Vale_X64_CryptoInstructions_s.krml extract/Kremlin/Vale_X64_Instructions_s.krml extract/Kremlin/Vale_Arch_HeapTypes_s.krml extract/Kremlin/Vale_Interop_Types.krml extract/Kremlin/Vale_Arch_MachineHeap_s.krml extract/Kremlin/Vale_Interop_Heap_s.krml extract/Kremlin/LowStar_Modifies.krml extract/Kremlin/LowStar_ModifiesPat.krml extract/Kremlin/LowStar_BufferView.krml extract/Kremlin/Vale_Lib_BufferViewHelpers.krml extract/Kremlin/Vale_Interop.krml extract/Kremlin/Vale_Arch_HeapImpl.krml extract/Kremlin/Vale_Arch_Heap.krml extract/Kremlin/Vale_X64_Machine_Semantics_s.krml extract/Kremlin/Vale_Interop_Base.krml extract/Kremlin/Vale_X64_Memory.krml extract/Kremlin/Vale_Arch_MachineHeap.krml extract/Kremlin/Vale_X64_Stack_i.krml extract/Kremlin/Vale_X64_Stack_Sems.krml extract/Kremlin/Vale_X64_BufferViewStore.krml extract/Kremlin/Vale_X64_Memory_Sems.krml extract/Kremlin/Vale_X64_State.krml extract/Kremlin/Vale_X64_StateLemmas.krml extract/Kremlin/Vale_X64_Lemmas.krml extract/Kremlin/Vale_X64_Print_s.krml extract/Kremlin/Vale_X64_Decls.krml extract/Kremlin/Vale_X64_QuickCode.krml extract/Kremlin/Vale_X64_QuickCodes.krml extract/Kremlin/Vale_X64_Taint_Semantics.krml extract/Kremlin/Vale_X64_InsLemmas.krml extract/Kremlin/Vale_X64_InsBasic.krml extract/Kremlin/Vale_X64_InsMem.krml extract/Kremlin/Vale_X64_InsVector.krml extract/Kremlin/Vale_X64_InsStack.krml extract/Kremlin/Vale_Curve25519_X64_FastHybrid.krml extract/Kremlin/Vale_Bignum_Defs.krml extract/Kremlin/Vale_Bignum_X64.krml extract/Kremlin/Vale_Curve25519_FastSqr_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastSqr.krml extract/Kremlin/Vale_Curve25519_FastMul_helpers.krml extract/Kremlin/Vale_Curve25519_X64_FastMul.krml extract/Kremlin/Vale_Curve25519_X64_FastWide.krml extract/Kremlin/Vale_Curve25519_X64_FastUtil.krml extract/Kremlin/Vale_X64_MemoryAdapters.krml extract/Kremlin/Vale_Interop_Assumptions.krml extract/Kremlin/Vale_Interop_X64.krml extract/Kremlin/Vale_AsLowStar_ValeSig.krml extract/Kremlin/Vale_AsLowStar_LowStarSig.krml extract/Kremlin/Vale_AsLowStar_MemoryHelpers.krml extract/Kremlin/Vale_AsLowStar_Wrapper.krml extract/Kremlin/Vale_Stdcalls_X64_Fadd.krml extract/Kremlin/Vale_Wrapper_X64_Fadd.krml extract/Kremlin/Spec_SHA1.krml extract/Kremlin/Spec_MD5.krml extract/Kremlin/Spec_Agile_Hash.krml extract/Kremlin/Spec_Hash_Incremental.krml extract/Kremlin/Spec_Hash_Lemmas.krml extract/Kremlin/FStar_Kremlin_Endianness.krml extract/Kremlin/Hacl_Hash_Lemmas.krml extract/Kremlin/Hacl_Hash_Definitions.krml extract/Kremlin/Hacl_Hash_PadFinish.krml extract/Kremlin/Hacl_Hash_MD.krml extract/Kremlin/Spec_SHA2_Lemmas.krml extract/Kremlin/Vale_X64_Stack.krml extract/Kremlin/Vale_SHA_SHA_helpers.krml extract/Kremlin/Vale_X64_InsSha.krml extract/Kremlin/Vale_SHA_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Sha.krml extract/Kremlin/FStar_BV.krml extract/Kremlin/FStar_Reflection_Arith.krml extract/Kremlin/FStar_Tactics_BV.krml extract/Kremlin/Vale_Lib_Bv_s.krml extract/Kremlin/Vale_Math_Bits.krml extract/Kremlin/Vale_Lib_Tactics.krml extract/Kremlin/Vale_Poly1305_Bitvectors.krml extract/Kremlin/Vale_Math_Lemmas_Int.krml extract/Kremlin/FStar_Tactics_Canon.krml extract/Kremlin/Vale_Poly1305_Spec_s.krml extract/Kremlin/Vale_Poly1305_Math.krml extract/Kremlin/Vale_Poly1305_Util.krml extract/Kremlin/Vale_Poly1305_X64.krml extract/Kremlin/Vale_Stdcalls_X64_Poly.krml extract/Kremlin/Vale_Wrapper_X64_Poly.krml extract/Kremlin/Vale_Arch_BufferFriend.krml extract/Kremlin/Vale_SHA_Simplify_Sha.krml extract/Kremlin/Vale_Wrapper_X64_Sha.krml extract/Kremlin/Hacl_Hash_Core_SHA2_Constants.krml extract/Kremlin/Hacl_Hash_Core_SHA2.krml extract/Kremlin/Hacl_Hash_SHA2.krml extract/Kremlin/Hacl_Hash_Core_SHA1.krml extract/Kremlin/Hacl_Hash_SHA1.krml extract/Kremlin/Hacl_Hash_Core_MD5.krml extract/Kremlin/Hacl_Hash_MD5.krml extract/Kremlin/C.krml extract/Kremlin/C_String.krml extract/Kremlin/C_Failure.krml extract/Kremlin/FStar_Int31.krml extract/Kremlin/FStar_UInt31.krml extract/Kremlin/FStar_Integers.krml extract/Kremlin/EverCrypt_StaticConfig.krml extract/Kremlin/EverCrypt_TargetConfig.krml extract/Kremlin/Vale_Lib_Basic.krml extract/Kremlin/Vale_Lib_X64_Cpuid.krml extract/Kremlin/Vale_Lib_X64_Cpuidstdcall.krml extract/Kremlin/Vale_Stdcalls_X64_Cpuid.krml extract/Kremlin/Vale_Wrapper_X64_Cpuid.krml extract/Kremlin/EverCrypt_AutoConfig2.krml extract/Kremlin/EverCrypt_Helpers.krml extract/Kremlin/EverCrypt_Hash.krml extract/Kremlin/Spec_Agile_HMAC.krml extract/Kremlin/Hacl_HMAC.krml extract/Kremlin/EverCrypt_HMAC.krml extract/Kremlin/Declassify.krml extract/Kremlin/FStar_Bytes.krml extract/Kremlin/Hashing_Spec.krml extract/Kremlin/LowParse_Bytes32.krml extract/Kremlin/LowParse_Bytes.krml extract/Kremlin/LowParse_Spec_Base.krml extract/Kremlin/LowParse_SLow_Base.krml extract/Kremlin/LowParse_Spec_Option.krml extract/Kremlin/LowParse_SLow_Option.krml extract/Kremlin/LowParse_Spec_Combinators.krml extract/Kremlin/LowParse_Spec_IfThenElse.krml extract/Kremlin/LowParse_SLow_Combinators.krml extract/Kremlin/LowParse_Spec_List.krml extract/Kremlin/LowParse_SLow_List.krml extract/Kremlin/Spec_Curve25519_Lemmas.krml extract/Kremlin/Spec_Curve25519.krml extract/Kremlin/Hacl_Spec_Curve25519_AddAndDouble.krml extract/Kremlin/Hacl_Impl_Curve25519_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64_Core.krml extract/Kremlin/Hacl_Spec_Curve25519_Field64.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Definition.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51_Lemmas.krml extract/Kremlin/Hacl_Spec_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields_Core.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64.krml extract/Kremlin/Hacl_Impl_Curve25519_Field51.krml extract/Kremlin/Hacl_Impl_Curve25519_Fields.krml extract/Kremlin/Hacl_Impl_Curve25519_AddAndDouble.krml extract/Kremlin/Spec_Poly1305.krml extract/Kremlin/Hacl_Spec_Poly1305_Vec.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Field32xN_Lemmas.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN.krml extract/Kremlin/Hacl_Spec_Poly1305_Lemmas.krml extract/Kremlin/Hacl_Spec_Poly1305_Equiv.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_256.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_128.krml extract/Kremlin/Hacl_Impl_Poly1305_Field32xN_32.krml extract/Kremlin/Hacl_Impl_Poly1305_Fields.krml extract/Kremlin/Hacl_Impl_Poly1305.krml extract/Kremlin/Spec_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305_PolyCore.krml extract/Kremlin/Hacl_Impl_Chacha20Poly1305.krml extract/Kremlin/FStar_List_Pure_Base.krml extract/Kremlin/FStar_List_Pure_Properties.krml extract/Kremlin/FStar_List_Pure.krml extract/Kremlin/Meta_Interface.krml extract/Kremlin/Hacl_Meta_Chacha20Poly1305.krml extract/Kremlin/Hacl_Impl_Chacha20_Core32.krml extract/Kremlin/Hacl_Impl_Chacha20.krml extract/Kremlin/Hacl_Chacha20.krml extract/Kremlin/Hacl_Meta_Poly1305.krml extract/Kremlin/Hacl_Poly1305_32.krml extract/Kremlin/Hacl_Chacha20Poly1305_32.krml extract/Kremlin/FStar_Dyn.krml extract/Kremlin/LowStar_Failure.krml extract/Kremlin/EverCrypt_Vale.krml extract/Kremlin/EverCrypt_Specs.krml extract/Kremlin/EverCrypt_OpenSSL.krml extract/Kremlin/EverCrypt_Hacl.krml extract/Kremlin/EverCrypt_BCrypt.krml extract/Kremlin/EverCrypt_Cipher.krml extract/Kremlin/Hacl_Spec_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Finv.krml extract/Kremlin/Hacl_Impl_Curve25519_Generic.krml extract/Kremlin/Hacl_Meta_Curve25519.krml extract/Kremlin/Hacl_Curve25519_51.krml extract/Kremlin/Vale_Stdcalls_X64_Fswap.krml extract/Kremlin/Vale_Wrapper_X64_Fswap.krml extract/Kremlin/Vale_X64_Print_Inline_s.krml extract/Kremlin/Vale_Inline_X64_Fswap_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsqr.krml extract/Kremlin/Vale_Wrapper_X64_Fsqr.krml extract/Kremlin/Vale_Inline_X64_Fsqr_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fmul.krml extract/Kremlin/Vale_Wrapper_X64_Fmul.krml extract/Kremlin/Vale_Inline_X64_Fmul_inline.krml extract/Kremlin/Vale_Stdcalls_X64_Fsub.krml extract/Kremlin/Vale_Wrapper_X64_Fsub.krml extract/Kremlin/Vale_Inline_X64_Fadd_inline.krml extract/Kremlin/Hacl_Impl_Curve25519_Field64_Vale.krml extract/Kremlin/Hacl_Curve25519_64.krml extract/Kremlin/EverCrypt_Curve25519.krml extract/Kremlin/Hacl_Poly1305_128.krml extract/Kremlin/Hacl_Poly1305_256.krml extract/Kremlin/Vale_Poly1305_Equiv.krml extract/Kremlin/Vale_Poly1305_CallingFromLowStar.krml extract/Kremlin/EverCrypt_Poly1305.krml extract/Kremlin/Lib_Memzero.krml extract/Kremlin/Spec_HMAC_DRBG.krml extract/Kremlin/Hacl_HMAC_DRBG.krml extract/Kremlin/Lib_RandomBuffer_System.krml extract/Kremlin/EverCrypt_DRBG.krml extract/Kremlin/Spec_Agile_HKDF.krml extract/Kremlin/Hacl_HKDF.krml extract/Kremlin/EverCrypt_HKDF.krml extract/Kremlin/EverCrypt.krml extract/Kremlin/FStar_Printf.krml extract/Kremlin/FStar_Error.krml extract/Kremlin/FStar_Tcp.krml extract/Kremlin/LowParse_Spec_FLData.krml extract/Kremlin/LowParse_Math.krml extract/Kremlin/LowParse_Slice.krml extract/Kremlin/LowParse_Low_Base.krml extract/Kremlin/LowParse_Low_Combinators.krml extract/Kremlin/LowParse_Low_FLData.krml extract/Kremlin/LowParse_Spec_Seq.krml extract/Kremlin/LowParse_Spec_Int.krml extract/Kremlin/LowParse_Spec_BoundedInt.krml extract/Kremlin/LowParse_Low_Endianness.krml extract/Kremlin/LowParse_BitFields.krml extract/Kremlin/LowParse_Endianness.krml extract/Kremlin/LowParse_Endianness_BitFields.krml extract/Kremlin/LowParse_Low_BoundedInt.krml extract/Kremlin/LowParse_Spec_SeqBytes_Base.krml extract/Kremlin/LowParse_Spec_DER.krml extract/Kremlin/LowParse_Spec_BCVLI.krml extract/Kremlin/LowParse_Spec_AllIntegers.krml extract/Kremlin/LowParse_Spec_VLData.krml extract/Kremlin/LowParse_Low_VLData.krml extract/Kremlin/LowParse_Spec_VLGen.krml extract/Kremlin/LowParse_Low_VLGen.krml extract/Kremlin/LowParse_Low_Int.krml extract/Kremlin/LowParse_Low_DER.krml extract/Kremlin/LowParse_Low_BCVLI.krml extract/Kremlin/LowParse_Low_List.krml extract/Kremlin/LowParse_Spec_Array.krml extract/Kremlin/LowParse_Spec_VCList.krml extract/Kremlin/LowParse_Low_VCList.krml extract/Kremlin/LowParse_Low_IfThenElse.krml extract/Kremlin/LowParse_TacLib.krml extract/Kremlin/LowParse_Spec_Enum.krml extract/Kremlin/LowParse_Spec_Sum.krml extract/Kremlin/LowParse_Low_Enum.krml extract/Kremlin/LowParse_Low_Sum.krml extract/Kremlin/LowParse_Low_Tac_Sum.krml extract/Kremlin/LowParse_Low_Option.krml extract/Kremlin/LowParse_Spec_Bytes.krml extract/Kremlin/LowParse_Low_Bytes.krml extract/Kremlin/LowParse_Low_Array.krml extract/Kremlin/LowParse_Low.krml extract/Kremlin/LowParse_SLow_FLData.krml extract/Kremlin/LowParse_SLow_VLGen.krml extract/Kremlin/LowParse_Spec_Endianness.krml extract/Kremlin/LowParse_Spec_Endianness_Instances.krml extract/Kremlin/LowParse_SLow_Endianness.krml extract/Kremlin/LowParse_SLow_BoundedInt.krml extract/Kremlin/LowParse_SLow_Int.krml extract/Kremlin/LowParse_SLow_DER.krml extract/Kremlin/LowParse_SLow_BCVLI.krml extract/Kremlin/LowParse_SLow_VCList.krml extract/Kremlin/LowParse_SLow_IfThenElse.krml extract/Kremlin/LowParse_SLow_Enum.krml extract/Kremlin/LowParse_SLow_Sum.krml extract/Kremlin/LowParse_SLow_Tac_Enum.krml extract/Kremlin/LowParse_SLow_Tac_Sum.krml extract/Kremlin/LowParse_SLow_VLData.krml extract/Kremlin/LowParse_SLow_Bytes.krml extract/Kremlin/LowParse_SLow_Array.krml extract/Kremlin/LowParse_Spec_Tac_Combinators.krml extract/Kremlin/LowParse_SLow.krml extract/Kremlin/Parsers_AlertDescription.krml extract/Kremlin/Parsers_AlertLevel.krml extract/Kremlin/Parsers_Alert.krml extract/Kremlin/TLSError.krml extract/Kremlin/Parsers_NamedGroup.krml extract/Kremlin/Format_Constants.krml extract/Kremlin/Format_UncompressedPointRepresentation.krml extract/Kremlin/Format_KeyShareEntry.krml extract/Kremlin/Flags.krml extract/Kremlin/Parsers_ECCurveType.krml extract/Kremlin/DebugFlags.krml extract/Kremlin/FStar_DependentMap.krml extract/Kremlin/FStar_Monotonic_DependentMap.krml extract/Kremlin/Mem.krml extract/Kremlin/Random.krml extract/Kremlin/TLS_Curve25519.krml extract/Kremlin/Parse.krml extract/Kremlin/ECGroup.krml extract/Kremlin/DHGroup.krml extract/Kremlin/Parsers_NamedGroupList.krml extract/Kremlin/CommonDH.krml extract/Kremlin/FFICallbacks.krml extract/Kremlin/Parsers_CompressionMethod.krml extract/Kremlin/Parsers_SignatureScheme.krml extract/Kremlin/Parsers_SignatureSchemeList.krml extract/Kremlin/LowParseWrappers.krml extract/Kremlin/Parsers_CipherSuite.krml extract/Kremlin/CipherSuite.krml extract/Kremlin/Parsers_ProtocolVersion.krml extract/Kremlin/TLSConstants.krml extract/Kremlin/HMAC.krml extract/Kremlin/RSAKey.krml extract/Kremlin/PMS.krml extract/Kremlin/List_Helpers.krml extract/Kremlin/PSK.krml extract/Kremlin/Extensions.krml extract/Kremlin/Cert.krml extract/Kremlin/TLSInfoFlags.krml extract/Kremlin/FStar_Date.krml extract/Kremlin/Nonce.krml extract/Kremlin/TLSInfo.krml extract/Kremlin/Crypto_Indexing.krml extract/Kremlin/Flag.krml extract/Kremlin/FStar_Old_Endianness.krml extract/Kremlin/FStar_Buffer.krml extract/Kremlin/C_Compat_Loops.krml extract/Kremlin/Buffer_Utils.krml extract/Kremlin/Crypto_Symmetric_Bytes.krml extract/Kremlin/Crypto_Plain.krml extract/Kremlin/AEADProvider.krml extract/Kremlin/Range.krml extract/Kremlin/DataStream.krml extract/Kremlin/Alert.krml extract/Kremlin/Content.krml extract/Kremlin/StreamPlain.krml extract/Kremlin/Hashing.krml extract/Kremlin/TLSPRF.krml extract/Kremlin/Hashing_CRF.krml extract/Kremlin/HandshakeMessages.krml extract/Kremlin/HandshakeLog.krml extract/Kremlin/Parsers_Boolean.krml extract/Kremlin/Parsers_TicketContents13_custom_data.krml extract/Kremlin/Parsers_TicketContents13_nonce.krml extract/Kremlin/Parsers_TicketContents13_rms.krml extract/Kremlin/Parsers_TicketContents13.krml extract/Kremlin/Parsers_TicketContents12_master_secret.krml extract/Kremlin/Parsers_TicketContents12.krml extract/Kremlin/Parsers_TicketVersion.krml extract/Kremlin/Parsers_TicketContents.krml extract/Kremlin/Parsers_TicketContents12_master_secret_Low.krml extract/Kremlin/Parsers_Ticket_Low.krml extract/Kremlin/Ticket.krml extract/Kremlin/Negotiation.krml extract/Kremlin/FStar_Monotonic_Seq.krml extract/Kremlin/StreamAE.krml extract/Kremlin/StatefulPlain.krml extract/Kremlin/LHAEPlain.krml extract/Kremlin/AEAD_GCM.krml extract/Kremlin/StatefulLHAE.krml extract/Kremlin/StAE.krml extract/Kremlin/Old_HMAC_UFCMA.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_context.krml extract/Kremlin/Parsers_HKDF_HkdfLabel_label.krml extract/Kremlin/Parsers_HKDF_HkdfLabel.krml extract/Kremlin/HKDF.krml extract/Kremlin/Old_KeySchedule.krml extract/Kremlin/Old_Epochs.krml extract/Kremlin/FStar_HyperStack_IO.krml extract/Kremlin/StreamDeltas.krml extract/Kremlin/Old_Handshake.krml extract/Kremlin/Transport.krml extract/Kremlin/BufferBytes.krml extract/Kremlin/Record.krml extract/Kremlin/Connection.krml extract/Kremlin/TLS.krml extract/Kremlin/FFI.krml extract/Kremlin/Pkg.krml extract/Kremlin/Idx.krml extract/Kremlin/Model.krml extract/Kremlin/FStar_Test.krml extract/Kremlin/Pkg_Tree.krml extract/Kremlin/KDF.krml extract/Kremlin/QUIC.krml extract/Kremlin/IV.krml extract/Kremlin/KDF_Rekey.krml -tmpdir extract/Kremlin-Library -skip-compilation
  F* version: 1f9505d5
  KreMLin version: 44acff92
 */

#include "TLSInfo.h"

Prims_list__Parsers_CipherSuite_cipherSuite *TLSInfo_default_cipherSuites;

Prims_list__Parsers_SignatureScheme_signatureScheme *TLSInfo_default_signature_schemes;

Prims_list__Parsers_NamedGroup_namedGroup *TLSInfo_default_groups;

void
TLSInfo_defaultTicketCBFun(
  FStar_Dyn_dyn uu____103,
  Prims_string sni,
  FStar_Bytes_bytes ticket,
  TLSConstants_ticketInfo info,
  FStar_Bytes_bytes psk
)
{
  if (info.tag == TLSConstants_TicketInfo_12)
  {
    bool ems = info.val.case_TicketInfo_12.thd;
    CipherSuite_cipherSuite_ cs = info.val.case_TicketInfo_12.snd;
    Parsers_ProtocolVersion_protocolVersion pv = info.val.case_TicketInfo_12.fst;
    PSK_s12_extend(ticket,
      (
        (K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite__bool_FStar_Bytes_bytes){
          .fst = pv,
          .snd = cs,
          .thd = ems,
          .f3 = psk
        }
      ));
  }
  else if (info.tag == TLSConstants_TicketInfo_13)
  {
    TLSConstants_pskInfo pskInfo = info.val.case_TicketInfo_13;
    PSK_coerce_psk(ticket, pskInfo, psk);
    PSK_extend(sni, ticket);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

void **FStar_Dyn_mkdyn____()
{
  return (void **)(void *)(uint8_t)0U;
}

TLSConstants_ticket_cb TLSInfo_defaultTicketCB;

TLSConstants_nego_action
TLSInfo_defaultServerNegoCBFun(
  FStar_Dyn_dyn uu____155,
  Parsers_ProtocolVersion_protocolVersion pv,
  FStar_Bytes_bytes cext,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes ocookie
)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__K___uint16_t_FStar_Bytes_bytes
  *buf = KRML_HOST_MALLOC(sizeof (Prims_list__K___uint16_t_FStar_Bytes_bytes));
  buf[0U] = ((Prims_list__K___uint16_t_FStar_Bytes_bytes){ .tag = Prims_Nil });
  return
    (
      (TLSConstants_nego_action){
        .tag = TLSConstants_Nego_accept,
        .val = { .case_Nego_accept = buf }
      }
    );
}

TLSConstants_nego_cb TLSInfo_defaultServerNegoCB;

FStar_Pervasives_Native_option__K___uint64_t_Parsers_SignatureScheme_signatureScheme
TLSInfo_none6__FStar_Dyn_dyn_FStar_Dyn_dyn_Parsers_ProtocolVersion_protocolVersion_FStar_Bytes_bytes_FStar_Bytes_bytes_Prims_list_Parsers_SignatureScheme_signatureScheme_uint64_t___Parsers_SignatureScheme_signatureScheme(
  FStar_Dyn_dyn uu____239,
  FStar_Dyn_dyn uu____240,
  Parsers_ProtocolVersion_protocolVersion uu____241,
  FStar_Bytes_bytes uu____242,
  FStar_Bytes_bytes uu____243,
  Prims_list__Parsers_SignatureScheme_signatureScheme *uu____244
)
{
  return
    (
      (FStar_Pervasives_Native_option__K___uint64_t_Parsers_SignatureScheme_signatureScheme){
        .tag = FStar_Pervasives_Native_None
      }
    );
}

Prims_list__FStar_Bytes_bytes
*TLSInfo_empty3__FStar_Dyn_dyn_FStar_Dyn_dyn_uint64_t_FStar_Bytes_bytes(
  FStar_Dyn_dyn uu____285,
  FStar_Dyn_dyn uu____286,
  uint64_t uu____287
)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__FStar_Bytes_bytes), (uint32_t)1U);
  Prims_list__FStar_Bytes_bytes *buf = KRML_HOST_MALLOC(sizeof (Prims_list__FStar_Bytes_bytes));
  buf[0U] = ((Prims_list__FStar_Bytes_bytes){ .tag = Prims_Nil });
  return buf;
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes
TLSInfo_none5__FStar_Dyn_dyn_FStar_Dyn_dyn_uint64_t_Parsers_SignatureScheme_signatureScheme_FStar_Bytes_bytes_FStar_Bytes_bytes(
  FStar_Dyn_dyn uu____350,
  FStar_Dyn_dyn uu____351,
  uint64_t uu____352,
  Parsers_SignatureScheme_signatureScheme uu____353,
  FStar_Bytes_bytes uu____354
)
{
  return
    ((FStar_Pervasives_Native_option__FStar_Bytes_bytes){ .tag = FStar_Pervasives_Native_None });
}

bool
TLSInfo_false6__FStar_Dyn_dyn_FStar_Dyn_dyn_Prims_list_FStar_Bytes_bytes_Parsers_SignatureScheme_signatureScheme_FStar_Bytes_bytes_FStar_Bytes_bytes(
  FStar_Dyn_dyn uu____423,
  FStar_Dyn_dyn uu____424,
  Prims_list__FStar_Bytes_bytes *uu____425,
  Parsers_SignatureScheme_signatureScheme uu____426,
  FStar_Bytes_bytes uu____427,
  FStar_Bytes_bytes uu____428
)
{
  return false;
}

TLSConstants_cert_cb TLSInfo_defaultCertCB;

TLSConstants_config TLSInfo_defaultConfig;

FStar_Bytes_bytes
TLSInfo___proj__MksessionInfo__item__init_crand(TLSInfo_sessionInfo projectee)
{
  return projectee.init_crand;
}

FStar_Bytes_bytes
TLSInfo___proj__MksessionInfo__item__init_srand(TLSInfo_sessionInfo projectee)
{
  return projectee.init_srand;
}

Parsers_ProtocolVersion_protocolVersion
TLSInfo___proj__MksessionInfo__item__protocol_version(TLSInfo_sessionInfo projectee)
{
  return projectee.protocol_version;
}

CipherSuite_cipherSuite_
TLSInfo___proj__MksessionInfo__item__cipher_suite(TLSInfo_sessionInfo projectee)
{
  return projectee.cipher_suite;
}

Parsers_CompressionMethod_compressionMethod
TLSInfo___proj__MksessionInfo__item__compression(TLSInfo_sessionInfo projectee)
{
  return projectee.compression;
}

bool TLSInfo___proj__MksessionInfo__item__extended_ms(TLSInfo_sessionInfo projectee)
{
  return projectee.extended_ms;
}

PMS_pms TLSInfo___proj__MksessionInfo__item__pmsId(TLSInfo_sessionInfo projectee)
{
  return projectee.pmsId;
}

FStar_Bytes_bytes
TLSInfo___proj__MksessionInfo__item__session_hash(TLSInfo_sessionInfo projectee)
{
  return projectee.session_hash;
}

bool TLSInfo___proj__MksessionInfo__item__client_auth(TLSInfo_sessionInfo projectee)
{
  return projectee.client_auth;
}

Prims_list__FStar_Bytes_bytes
*TLSInfo___proj__MksessionInfo__item__clientID(TLSInfo_sessionInfo projectee)
{
  return projectee.clientID;
}

Parsers_SignatureScheme_signatureScheme
TLSInfo___proj__MksessionInfo__item__clientSigAlg(TLSInfo_sessionInfo projectee)
{
  return projectee.clientSigAlg;
}

Prims_list__FStar_Bytes_bytes
*TLSInfo___proj__MksessionInfo__item__serverID(TLSInfo_sessionInfo projectee)
{
  return projectee.serverID;
}

Parsers_SignatureScheme_signatureScheme
TLSInfo___proj__MksessionInfo__item__serverSigAlg(TLSInfo_sessionInfo projectee)
{
  return projectee.serverSigAlg;
}

FStar_Bytes_bytes TLSInfo___proj__MksessionInfo__item__sessionID(TLSInfo_sessionInfo projectee)
{
  return projectee.sessionID;
}

FStar_Bytes_bytes TLSInfo___proj__MkabbrInfo__item__abbr_crand(TLSInfo_abbrInfo projectee)
{
  return projectee.abbr_crand;
}

FStar_Bytes_bytes TLSInfo___proj__MkabbrInfo__item__abbr_srand(TLSInfo_abbrInfo projectee)
{
  return projectee.abbr_srand;
}

FStar_Bytes_bytes
TLSInfo___proj__MkabbrInfo__item__abbr_session_hash(TLSInfo_abbrInfo projectee)
{
  return projectee.abbr_session_hash;
}

FStar_Pervasives_Native_option__K___FStar_Bytes_bytes_FStar_Bytes_bytes
TLSInfo___proj__MkabbrInfo__item__abbr_vd(TLSInfo_abbrInfo projectee)
{
  return projectee.abbr_vd;
}

FStar_Bytes_bytes TLSInfo_csrands(TLSInfo_sessionInfo si)
{
  return FStar_Bytes_append(si.init_crand, si.init_srand);
}

TLSConstants_prePrfAlg
TLSInfo_kefAlg(
  Parsers_ProtocolVersion_protocolVersion pv,
  CipherSuite_cipherSuite_ cs,
  bool ems
)
{
  FStar_Bytes_bytes label;
  if (ems)
    label = TLSConstants_extended_extract_label;
  else
    label = TLSConstants_extract_label;
  if (pv.tag == Parsers_ProtocolVersion_SSL_3p0)
    return ((TLSConstants_prePrfAlg){ .tag = TLSConstants_PRF_SSL3_nested });
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p0)
    return
      (
        (TLSConstants_prePrfAlg){
          .tag = TLSConstants_PRF_TLS_1p01,
          .val = { .case_PRF_TLS_1p01 = label }
        }
      );
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p1)
    return
      (
        (TLSConstants_prePrfAlg){
          .tag = TLSConstants_PRF_TLS_1p01,
          .val = { .case_PRF_TLS_1p01 = label }
        }
      );
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p2)
    return
      (
        (TLSConstants_prePrfAlg){
          .tag = TLSConstants_PRF_TLS_1p2,
          .val = {
            .case_PRF_TLS_1p2 = { ._0 = label, ._1 = TLSConstants_prfMacAlg_of_ciphersuite(cs) }
          }
        }
      );
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p3)
    return ((TLSConstants_prePrfAlg){ .tag = TLSConstants_PRF_TLS_1p3 });
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_prePrfAlg
TLSInfo_kdfAlg(Parsers_ProtocolVersion_protocolVersion pv, CipherSuite_cipherSuite_ cs)
{
  if (pv.tag == Parsers_ProtocolVersion_SSL_3p0)
    return ((TLSConstants_prePrfAlg){ .tag = TLSConstants_PRF_SSL3_nested });
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p0)
    return
      (
        (TLSConstants_prePrfAlg){
          .tag = TLSConstants_PRF_TLS_1p01,
          .val = { .case_PRF_TLS_1p01 = TLSConstants_kdf_label }
        }
      );
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p1)
    return
      (
        (TLSConstants_prePrfAlg){
          .tag = TLSConstants_PRF_TLS_1p01,
          .val = { .case_PRF_TLS_1p01 = TLSConstants_kdf_label }
        }
      );
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p2)
    return
      (
        (TLSConstants_prePrfAlg){
          .tag = TLSConstants_PRF_TLS_1p2,
          .val = {
            .case_PRF_TLS_1p2 = {
              ._0 = TLSConstants_kdf_label,
              ._1 = TLSConstants_prfMacAlg_of_ciphersuite(cs)
            }
          }
        }
      );
  else if (pv.tag == Parsers_ProtocolVersion_TLS_1p3)
    return ((TLSConstants_prePrfAlg){ .tag = TLSConstants_PRF_TLS_1p3 });
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite_
TLSInfo_vdAlg(TLSInfo_sessionInfo si)
{
  return
    (
      (K___Parsers_ProtocolVersion_protocolVersion_CipherSuite_cipherSuite_){
        .fst = si.protocol_version,
        .snd = si.cipher_suite
      }
    );
}

CipherSuite_aeAlg TLSInfo_siAuthEncAlg(TLSInfo_sessionInfo si)
{
  return TLSConstants_get_aeAlg(si.cipher_suite);
}

bool TLSInfo_uu___is_StandardMS(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_StandardMS)
    return true;
  else
    return false;
}

PMS_pms TLSInfo___proj__StandardMS__item___0(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_StandardMS)
    return projectee.val.case_StandardMS._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes TLSInfo___proj__StandardMS__item___1(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_StandardMS)
    return projectee.val.case_StandardMS._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_prePrfAlg TLSInfo___proj__StandardMS__item___2(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_StandardMS)
    return projectee.val.case_StandardMS._2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ExtendedMS(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_ExtendedMS)
    return true;
  else
    return false;
}

PMS_pms TLSInfo___proj__ExtendedMS__item___0(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_ExtendedMS)
    return projectee.val.case_ExtendedMS._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes TLSInfo___proj__ExtendedMS__item___1(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_ExtendedMS)
    return projectee.val.case_ExtendedMS._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_prePrfAlg TLSInfo___proj__ExtendedMS__item___2(TLSInfo_msId projectee)
{
  if (projectee.tag == TLSInfo_ExtendedMS)
    return projectee.val.case_ExtendedMS._2;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_honestMS(TLSInfo_msId uu___0_1486)
{
  if (uu___0_1486.tag == TLSInfo_StandardMS)
  {
    PMS_pms pmsId = uu___0_1486.val.case_StandardMS._0;
    return PMS_honestPMS(pmsId) && false;
  }
  else if (uu___0_1486.tag == TLSInfo_ExtendedMS)
  {
    PMS_pms pmsId = uu___0_1486.val.case_ExtendedMS._0;
    return PMS_honestPMS(pmsId) && false;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_msId TLSInfo_msid(TLSInfo_sessionInfo si)
{
  bool ems = si.extended_ms;
  TLSConstants_prePrfAlg kef = TLSInfo_kefAlg(si.protocol_version, si.cipher_suite, ems);
  if (ems)
    return
      (
        (TLSInfo_msId){
          .tag = TLSInfo_ExtendedMS,
          .val = { .case_ExtendedMS = { ._0 = si.pmsId, ._1 = si.session_hash, ._2 = kef } }
        }
      );
  else
    return
      (
        (TLSInfo_msId){
          .tag = TLSInfo_StandardMS,
          .val = { .case_StandardMS = { ._0 = si.pmsId, ._1 = TLSInfo_csrands(si), ._2 = kef } }
        }
      );
}

bool TLSInfo_strongPRF(TLSInfo_sessionInfo si)
{
  return false;
}

bool TLSInfo_strongHS(TLSInfo_sessionInfo si)
{
  return
    false
    &&
      FStar_Pervasives_Native_uu___is_Some__Spec_Hash_Definitions_hash_alg(TLSConstants_prfMacAlg_of_ciphersuite_aux(si.cipher_suite))
    && false
    && TLSInfo_strongPRF(si);
}

bool TLSInfo_safeCRE(TLSInfo_sessionInfo si)
{
  return TLSInfo_honestMS(TLSInfo_msid(si));
}

bool TLSInfo_safeVD(TLSInfo_sessionInfo si)
{
  return TLSInfo_honestMS(TLSInfo_msid(si)) && false;
}

FStar_Bytes_bytes TLSInfo___proj__MklogInfo_CH__item__li_ch_cr(TLSInfo_logInfo_CH projectee)
{
  return projectee.li_ch_cr;
}

Prims_list__FStar_Bytes_bytes
*TLSInfo___proj__MklogInfo_CH__item__li_ch_psk(TLSInfo_logInfo_CH projectee)
{
  return projectee.li_ch_psk;
}

FStar_Bytes_bytes TLSInfo___proj__MklogInfo_CH0__item__li_ch0_cr(TLSInfo_logInfo_CH0 projectee)
{
  return projectee.li_ch0_cr;
}

FStar_Bytes_bytes
TLSInfo___proj__MklogInfo_CH0__item__li_ch0_ed_psk(TLSInfo_logInfo_CH0 projectee)
{
  return projectee.li_ch0_ed_psk;
}

EverCrypt_aead_alg
TLSInfo___proj__MklogInfo_CH0__item__li_ch0_ed_ae(TLSInfo_logInfo_CH0 projectee)
{
  return projectee.li_ch0_ed_ae;
}

Spec_Hash_Definitions_hash_alg
TLSInfo___proj__MklogInfo_CH0__item__li_ch0_ed_hash(TLSInfo_logInfo_CH0 projectee)
{
  return projectee.li_ch0_ed_hash;
}

FStar_Bytes_bytes TLSInfo___proj__MklogInfo_SH__item__li_sh_cr(TLSInfo_logInfo_SH projectee)
{
  return projectee.li_sh_cr;
}

FStar_Bytes_bytes TLSInfo___proj__MklogInfo_SH__item__li_sh_sr(TLSInfo_logInfo_SH projectee)
{
  return projectee.li_sh_sr;
}

EverCrypt_aead_alg TLSInfo___proj__MklogInfo_SH__item__li_sh_ae(TLSInfo_logInfo_SH projectee)
{
  return projectee.li_sh_ae;
}

Spec_Hash_Definitions_hash_alg
TLSInfo___proj__MklogInfo_SH__item__li_sh_hash(TLSInfo_logInfo_SH projectee)
{
  return projectee.li_sh_hash;
}

FStar_Pervasives_Native_option__FStar_Bytes_bytes
TLSInfo___proj__MklogInfo_SH__item__li_sh_psk(TLSInfo_logInfo_SH projectee)
{
  return projectee.li_sh_psk;
}

TLSInfo_logInfo_SH TLSInfo___proj__MklogInfo_SF__item__li_sf_sh(TLSInfo_logInfo_SF projectee)
{
  return projectee.li_sf_sh;
}

FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSInfo___proj__MklogInfo_SF__item__li_sf_certificate(TLSInfo_logInfo_SF projectee)
{
  return projectee.li_sf_certificate;
}

TLSInfo_logInfo_SF TLSInfo___proj__MklogInfo_CF__item__li_cf_sf(TLSInfo_logInfo_CF projectee)
{
  return projectee.li_cf_sf;
}

FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes
TLSInfo___proj__MklogInfo_CF__item__li_cf_certificate(TLSInfo_logInfo_CF projectee)
{
  return projectee.li_cf_certificate;
}

bool TLSInfo_uu___is_LogInfo_CH(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_CH)
    return true;
  else
    return false;
}

TLSInfo_logInfo_CH TLSInfo___proj__LogInfo_CH__item___0(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_CH)
    return projectee.val.case_LogInfo_CH;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_LogInfo_CH0(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_CH0)
    return true;
  else
    return false;
}

TLSInfo_logInfo_CH0 TLSInfo___proj__LogInfo_CH0__item___0(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_CH0)
    return projectee.val.case_LogInfo_CH0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_LogInfo_SH(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_SH)
    return true;
  else
    return false;
}

TLSInfo_logInfo_SH TLSInfo___proj__LogInfo_SH__item___0(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_SH)
    return projectee.val.case_LogInfo_SH;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_LogInfo_SF(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_SF)
    return true;
  else
    return false;
}

TLSInfo_logInfo_SF TLSInfo___proj__LogInfo_SF__item___0(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_SF)
    return projectee.val.case_LogInfo_SF;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_LogInfo_CF(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_CF)
    return true;
  else
    return false;
}

TLSInfo_logInfo_CF TLSInfo___proj__LogInfo_CF__item___0(TLSInfo_logInfo projectee)
{
  if (projectee.tag == TLSInfo_LogInfo_CF)
    return projectee.val.case_LogInfo_CF;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

EverCrypt_aead_alg TLSInfo_logInfo_ae(TLSInfo_logInfo uu___1_2437)
{
  if (uu___1_2437.tag == TLSInfo_LogInfo_CH0)
  {
    TLSInfo_logInfo_CH0 x = uu___1_2437.val.case_LogInfo_CH0;
    return x.li_ch0_ed_ae;
  }
  else if (uu___1_2437.tag == TLSInfo_LogInfo_SH)
  {
    TLSInfo_logInfo_SH x = uu___1_2437.val.case_LogInfo_SH;
    return x.li_sh_ae;
  }
  else if (uu___1_2437.tag == TLSInfo_LogInfo_SF)
  {
    TLSInfo_logInfo_SF x = uu___1_2437.val.case_LogInfo_SF;
    return x.li_sf_sh.li_sh_ae;
  }
  else if (uu___1_2437.tag == TLSInfo_LogInfo_CF)
  {
    TLSInfo_logInfo_CF x = uu___1_2437.val.case_LogInfo_CF;
    return x.li_cf_sf.li_sf_sh.li_sh_ae;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Spec_Hash_Definitions_hash_alg TLSInfo_logInfo_hash(TLSInfo_logInfo uu___2_2452)
{
  if (uu___2_2452.tag == TLSInfo_LogInfo_CH0)
  {
    TLSInfo_logInfo_CH0 x = uu___2_2452.val.case_LogInfo_CH0;
    return x.li_ch0_ed_hash;
  }
  else if (uu___2_2452.tag == TLSInfo_LogInfo_SH)
  {
    TLSInfo_logInfo_SH x = uu___2_2452.val.case_LogInfo_SH;
    return x.li_sh_hash;
  }
  else if (uu___2_2452.tag == TLSInfo_LogInfo_SF)
  {
    TLSInfo_logInfo_SF x = uu___2_2452.val.case_LogInfo_SF;
    return x.li_sf_sh.li_sh_hash;
  }
  else if (uu___2_2452.tag == TLSInfo_LogInfo_CF)
  {
    TLSInfo_logInfo_CF x = uu___2_2452.val.case_LogInfo_CF;
    return x.li_cf_sf.li_sf_sh.li_sh_hash;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes TLSInfo_logInfo_nonce(TLSInfo_logInfo uu___3_2468)
{
  if (uu___3_2468.tag == TLSInfo_LogInfo_CH)
  {
    TLSInfo_logInfo_CH x = uu___3_2468.val.case_LogInfo_CH;
    return x.li_ch_cr;
  }
  else if (uu___3_2468.tag == TLSInfo_LogInfo_CH0)
  {
    TLSInfo_logInfo_CH0 x = uu___3_2468.val.case_LogInfo_CH0;
    return x.li_ch0_cr;
  }
  else if (uu___3_2468.tag == TLSInfo_LogInfo_SH)
  {
    TLSInfo_logInfo_SH x = uu___3_2468.val.case_LogInfo_SH;
    return x.li_sh_cr;
  }
  else if (uu___3_2468.tag == TLSInfo_LogInfo_SF)
  {
    TLSInfo_logInfo_SF x = uu___3_2468.val.case_LogInfo_SF;
    return x.li_sf_sh.li_sh_cr;
  }
  else if (uu___3_2468.tag == TLSInfo_LogInfo_CF)
  {
    TLSInfo_logInfo_CF x = uu___3_2468.val.case_LogInfo_CF;
    return x.li_cf_sf.li_sf_sh.li_sh_cr;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
__eq__Prims_list__FStar_Bytes_bytes(
  Prims_list__FStar_Bytes_bytes *y,
  Prims_list__FStar_Bytes_bytes *x
)
{
  if (x->tag == Prims_Nil)
    if (y->tag == Prims_Nil)
      return true;
    else
      return false;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__FStar_Bytes_bytes *x_tl = x->tl;
    FStar_Bytes_bytes x_hd = x->hd;
    if (y->tag == Prims_Cons)
    {
      Prims_list__FStar_Bytes_bytes *y_tl = y->tl;
      FStar_Bytes_bytes y_hd = y->hd;
      return
        true
        && __eq__FStar_Bytes_bytes(y_hd, x_hd)
        && __eq__Prims_list__FStar_Bytes_bytes(y_tl, x_tl);
    }
    else
      return false;
  }
  else
    return false;
}

bool __eq__TLSInfo_logInfo_CH(TLSInfo_logInfo_CH y, TLSInfo_logInfo_CH x)
{
  return
    true
    && __eq__FStar_Bytes_bytes(x.li_ch_cr, y.li_ch_cr)
    && __eq__Prims_list__FStar_Bytes_bytes(x.li_ch_psk, y.li_ch_psk);
}

bool __eq__TLSInfo_logInfo_CH0(TLSInfo_logInfo_CH0 y, TLSInfo_logInfo_CH0 x)
{
  return
    true
    && __eq__FStar_Bytes_bytes(x.li_ch0_cr, y.li_ch0_cr)
    && __eq__FStar_Bytes_bytes(x.li_ch0_ed_psk, y.li_ch0_ed_psk)
    && __eq__EverCrypt_aead_alg(x.li_ch0_ed_ae, y.li_ch0_ed_ae)
    && __eq__Spec_Hash_Definitions_hash_alg(x.li_ch0_ed_hash, y.li_ch0_ed_hash);
}

bool
__eq__FStar_Pervasives_Native_option__FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__FStar_Bytes_bytes y,
  FStar_Pervasives_Native_option__FStar_Bytes_bytes x
)
{
  if (x.tag == FStar_Pervasives_Native_None)
    if (y.tag == FStar_Pervasives_Native_None)
      return true;
    else
      return false;
  else if (x.tag == FStar_Pervasives_Native_Some)
  {
    FStar_Bytes_bytes x_v = x.v;
    if (y.tag == FStar_Pervasives_Native_Some)
    {
      FStar_Bytes_bytes y_v = y.v;
      return true && __eq__FStar_Bytes_bytes(y_v, x_v);
    }
    else
      return false;
  }
  else
    return false;
}

bool __eq__TLSInfo_logInfo_SH(TLSInfo_logInfo_SH y, TLSInfo_logInfo_SH x)
{
  return
    true
    && __eq__FStar_Bytes_bytes(x.li_sh_cr, y.li_sh_cr)
    && __eq__FStar_Bytes_bytes(x.li_sh_sr, y.li_sh_sr)
    && __eq__EverCrypt_aead_alg(x.li_sh_ae, y.li_sh_ae)
    && __eq__Spec_Hash_Definitions_hash_alg(x.li_sh_hash, y.li_sh_hash)
    && __eq__FStar_Pervasives_Native_option__FStar_Bytes_bytes(x.li_sh_psk, y.li_sh_psk);
}

bool
__eq__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes(
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes y,
  FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes x
)
{
  if (x.tag == FStar_Pervasives_Native_None)
    if (y.tag == FStar_Pervasives_Native_None)
      return true;
    else
      return false;
  else if (x.tag == FStar_Pervasives_Native_Some)
  {
    Prims_list__FStar_Bytes_bytes *x_v = x.v;
    if (y.tag == FStar_Pervasives_Native_Some)
    {
      Prims_list__FStar_Bytes_bytes *y_v = y.v;
      return true && __eq__Prims_list__FStar_Bytes_bytes(y_v, x_v);
    }
    else
      return false;
  }
  else
    return false;
}

bool __eq__TLSInfo_logInfo_SF(TLSInfo_logInfo_SF y, TLSInfo_logInfo_SF x)
{
  return
    true
    && __eq__TLSInfo_logInfo_SH(x.li_sf_sh, y.li_sf_sh)
    &&
      __eq__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes(x.li_sf_certificate,
        y.li_sf_certificate);
}

bool __eq__TLSInfo_logInfo_CF(TLSInfo_logInfo_CF y, TLSInfo_logInfo_CF x)
{
  return
    true
    && __eq__TLSInfo_logInfo_SF(x.li_cf_sf, y.li_cf_sf)
    &&
      __eq__FStar_Pervasives_Native_option__Prims_list__FStar_Bytes_bytes(x.li_cf_certificate,
        y.li_cf_certificate);
}

bool __eq__TLSInfo_logInfo(TLSInfo_logInfo y, TLSInfo_logInfo x)
{
  if (x.tag == TLSInfo_LogInfo_CH)
  {
    TLSInfo_logInfo_CH x__0 = x.val.case_LogInfo_CH;
    if (y.tag == TLSInfo_LogInfo_CH)
    {
      TLSInfo_logInfo_CH y__0 = y.val.case_LogInfo_CH;
      return true && __eq__TLSInfo_logInfo_CH(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == TLSInfo_LogInfo_CH0)
  {
    TLSInfo_logInfo_CH0 x__0 = x.val.case_LogInfo_CH0;
    if (y.tag == TLSInfo_LogInfo_CH0)
    {
      TLSInfo_logInfo_CH0 y__0 = y.val.case_LogInfo_CH0;
      return true && __eq__TLSInfo_logInfo_CH0(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == TLSInfo_LogInfo_SH)
  {
    TLSInfo_logInfo_SH x__0 = x.val.case_LogInfo_SH;
    if (y.tag == TLSInfo_LogInfo_SH)
    {
      TLSInfo_logInfo_SH y__0 = y.val.case_LogInfo_SH;
      return true && __eq__TLSInfo_logInfo_SH(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == TLSInfo_LogInfo_SF)
  {
    TLSInfo_logInfo_SF x__0 = x.val.case_LogInfo_SF;
    if (y.tag == TLSInfo_LogInfo_SF)
    {
      TLSInfo_logInfo_SF y__0 = y.val.case_LogInfo_SF;
      return true && __eq__TLSInfo_logInfo_SF(y__0, x__0);
    }
    else
      return false;
  }
  else if (x.tag == TLSInfo_LogInfo_CF)
  {
    TLSInfo_logInfo_CF x__0 = x.val.case_LogInfo_CF;
    if (y.tag == TLSInfo_LogInfo_CF)
    {
      TLSInfo_logInfo_CF y__0 = y.val.case_LogInfo_CF;
      return true && __eq__TLSInfo_logInfo_CF(y__0, x__0);
    }
    else
      return false;
  }
  else
    return false;
}

bool TLSInfo_eq_logInfo(TLSInfo_logInfo la, TLSInfo_logInfo lb)
{
  return __eq__TLSInfo_logInfo(la, lb);
}

bool TLSInfo_uu___is_ExtBinder(TLSInfo_binderLabel projectee)
{
  switch (projectee)
  {
    case TLSInfo_ExtBinder:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool TLSInfo_uu___is_ResBinder(TLSInfo_binderLabel projectee)
{
  switch (projectee)
  {
    case TLSInfo_ResBinder:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool TLSInfo_uu___is_ApplicationPSK(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ApplicationPSK)
    return true;
  else
    return false;
}

Spec_Hash_Definitions_hash_alg
TLSInfo___proj__ApplicationPSK__item__ha(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ApplicationPSK)
    return projectee->val.case_ApplicationPSK.ha;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

EverCrypt_aead_alg TLSInfo___proj__ApplicationPSK__item__ae(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ApplicationPSK)
    return projectee->val.case_ApplicationPSK.ae;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes TLSInfo___proj__ApplicationPSK__item__i(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ApplicationPSK)
    return projectee->val.case_ApplicationPSK.i;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ResumptionPSK(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ResumptionPSK)
    return true;
  else
    return false;
}

TLSInfo_logInfo TLSInfo___proj__ResumptionPSK__item__li(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ResumptionPSK)
    return projectee->val.case_ResumptionPSK.li;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_pre_rmsId *TLSInfo___proj__ResumptionPSK__item__i(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_ResumptionPSK)
    return projectee->val.case_ResumptionPSK.i;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_NoPSK(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_NoPSK)
    return true;
  else
    return false;
}

Spec_Hash_Definitions_hash_alg TLSInfo___proj__NoPSK__item___0(TLSInfo_pre_esId *projectee)
{
  if (projectee->tag == TLSInfo_NoPSK)
    return projectee->val.case_NoPSK;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_Binder(TLSInfo_pre_binderId *projectee)
{
  return true;
}

TLSInfo_pre_esId *TLSInfo___proj__Binder__item___0(TLSInfo_pre_binderId *projectee)
{
  return projectee->_0;
}

TLSInfo_binderLabel TLSInfo___proj__Binder__item___1(TLSInfo_pre_binderId *projectee)
{
  return projectee->_1;
}

bool TLSInfo_uu___is_HSID_PSK(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_PSK)
    return true;
  else
    return false;
}

TLSInfo_pre_saltId *TLSInfo___proj__HSID_PSK__item___0(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_PSK)
    return projectee->val.case_HSID_PSK;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_HSID_DHE(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_DHE)
    return true;
  else
    return false;
}

TLSInfo_pre_saltId *TLSInfo___proj__HSID_DHE__item___0(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_DHE)
    return projectee->val.case_HSID_DHE._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CommonDH_group_ TLSInfo___proj__HSID_DHE__item__g(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_DHE)
    return projectee->val.case_HSID_DHE.g;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CommonDH_pre_share_ TLSInfo___proj__HSID_DHE__item__si(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_DHE)
    return projectee->val.case_HSID_DHE.si;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CommonDH_pre_share_ TLSInfo___proj__HSID_DHE__item__sr(TLSInfo_pre_hsId *projectee)
{
  if (projectee->tag == TLSInfo_HSID_DHE)
    return projectee->val.case_HSID_DHE.sr;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ASID(TLSInfo_pre_asId *projectee)
{
  return true;
}

TLSInfo_pre_saltId *TLSInfo___proj__ASID__item___0(TLSInfo_pre_asId *projectee)
{
  return projectee->_0;
}

bool TLSInfo_uu___is_Salt(TLSInfo_pre_saltId *projectee)
{
  return true;
}

TLSInfo_pre_secretId *TLSInfo___proj__Salt__item___0(TLSInfo_pre_saltId *projectee)
{
  return projectee->_0;
}

bool TLSInfo_uu___is_EarlySecretID(TLSInfo_pre_secretId *projectee)
{
  if (projectee->tag == TLSInfo_EarlySecretID)
    return true;
  else
    return false;
}

TLSInfo_pre_esId *TLSInfo___proj__EarlySecretID__item___0(TLSInfo_pre_secretId *projectee)
{
  if (projectee->tag == TLSInfo_EarlySecretID)
    return projectee->val.case_EarlySecretID;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_HandshakeSecretID(TLSInfo_pre_secretId *projectee)
{
  if (projectee->tag == TLSInfo_HandshakeSecretID)
    return true;
  else
    return false;
}

TLSInfo_pre_hsId *TLSInfo___proj__HandshakeSecretID__item___0(TLSInfo_pre_secretId *projectee)
{
  if (projectee->tag == TLSInfo_HandshakeSecretID)
    return projectee->val.case_HandshakeSecretID;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ApplicationSecretID(TLSInfo_pre_secretId *projectee)
{
  if (projectee->tag == TLSInfo_ApplicationSecretID)
    return true;
  else
    return false;
}

TLSInfo_pre_asId
*TLSInfo___proj__ApplicationSecretID__item___0(TLSInfo_pre_secretId *projectee)
{
  if (projectee->tag == TLSInfo_ApplicationSecretID)
    return projectee->val.case_ApplicationSecretID;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_RMSID(TLSInfo_logInfo li, TLSInfo_pre_rmsId *projectee)
{
  return true;
}

TLSInfo_pre_asId
*TLSInfo___proj__RMSID__item___0(TLSInfo_logInfo li, TLSInfo_pre_rmsId *projectee)
{
  return projectee->_0;
}

FStar_Bytes_bytes
TLSInfo___proj__RMSID__item___1(TLSInfo_logInfo li, TLSInfo_pre_rmsId *projectee)
{
  return projectee->_1;
}

bool TLSInfo_uu___is_EarlyExportID(TLSInfo_logInfo li, TLSInfo_pre_exportId *projectee)
{
  if (projectee->tag == TLSInfo_EarlyExportID)
    return true;
  else
    return false;
}

TLSInfo_pre_esId
*TLSInfo___proj__EarlyExportID__item___0(TLSInfo_logInfo li, TLSInfo_pre_exportId *projectee)
{
  if (projectee->tag == TLSInfo_EarlyExportID)
    return projectee->val.case_EarlyExportID._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes
TLSInfo___proj__EarlyExportID__item___1(TLSInfo_logInfo li, TLSInfo_pre_exportId *projectee)
{
  if (projectee->tag == TLSInfo_EarlyExportID)
    return projectee->val.case_EarlyExportID._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ExportID(TLSInfo_logInfo li, TLSInfo_pre_exportId *projectee)
{
  if (projectee->tag == TLSInfo_ExportID)
    return true;
  else
    return false;
}

TLSInfo_pre_asId
*TLSInfo___proj__ExportID__item___0(TLSInfo_logInfo li, TLSInfo_pre_exportId *projectee)
{
  if (projectee->tag == TLSInfo_ExportID)
    return projectee->val.case_ExportID._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes
TLSInfo___proj__ExportID__item___1(TLSInfo_logInfo li, TLSInfo_pre_exportId *projectee)
{
  if (projectee->tag == TLSInfo_ExportID)
    return projectee->val.case_ExportID._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ClientEarlyTrafficSecret(TLSInfo_expandTag *projectee)
{
  if (projectee[0U] == TLSInfo_ClientEarlyTrafficSecret)
    return true;
  else
    return false;
}

bool TLSInfo_uu___is_ClientHandshakeTrafficSecret(TLSInfo_expandTag *projectee)
{
  if (projectee[0U] == TLSInfo_ClientHandshakeTrafficSecret)
    return true;
  else
    return false;
}

bool TLSInfo_uu___is_ServerHandshakeTrafficSecret(TLSInfo_expandTag *projectee)
{
  if (projectee[0U] == TLSInfo_ServerHandshakeTrafficSecret)
    return true;
  else
    return false;
}

bool TLSInfo_uu___is_ClientApplicationTrafficSecret(TLSInfo_expandTag *projectee)
{
  if (projectee[0U] == TLSInfo_ClientApplicationTrafficSecret)
    return true;
  else
    return false;
}

bool TLSInfo_uu___is_ServerApplicationTrafficSecret(TLSInfo_expandTag *projectee)
{
  if (projectee[0U] == TLSInfo_ServerApplicationTrafficSecret)
    return true;
  else
    return false;
}

bool TLSInfo_uu___is_ApplicationTrafficSecret(TLSInfo_expandTag *projectee)
{
  if (projectee[0U] == TLSInfo_ApplicationTrafficSecret)
    return true;
  else
    return false;
}

bool TLSInfo_uu___is_ExpandedSecret(TLSInfo_logInfo li, TLSInfo_pre_expandId *projectee)
{
  return true;
}

TLSInfo_pre_secretId
*TLSInfo___proj__ExpandedSecret__item___0(TLSInfo_logInfo li, TLSInfo_pre_expandId *projectee)
{
  return projectee->_0;
}

TLSInfo_expandTag
*TLSInfo___proj__ExpandedSecret__item___1(TLSInfo_logInfo li, TLSInfo_pre_expandId *projectee)
{
  return projectee->_1;
}

FStar_Bytes_bytes
TLSInfo___proj__ExpandedSecret__item___2(TLSInfo_logInfo li, TLSInfo_pre_expandId *projectee)
{
  return projectee->_2;
}

bool TLSInfo_uu___is_KeyID(TLSInfo_pre_keyId *projectee)
{
  return true;
}

TLSInfo_logInfo TLSInfo___proj__KeyID__item__li(TLSInfo_pre_keyId *projectee)
{
  return projectee->li;
}

TLSInfo_pre_expandId *TLSInfo___proj__KeyID__item__i(TLSInfo_pre_keyId *projectee)
{
  return projectee->i;
}

bool TLSInfo_uu___is_FinishedID(TLSInfo_pre_finishedId *projectee)
{
  return true;
}

TLSInfo_logInfo TLSInfo___proj__FinishedID__item__li(TLSInfo_pre_finishedId *projectee)
{
  return projectee->li;
}

TLSInfo_pre_expandId *TLSInfo___proj__FinishedID__item___1(TLSInfo_pre_finishedId *projectee)
{
  return projectee->_1;
}

Spec_Hash_Definitions_hash_alg TLSInfo_esId_hash(TLSInfo_pre_esId *uu___4_4154)
{
  if (uu___4_4154->tag == TLSInfo_ApplicationPSK)
    return uu___4_4154->val.case_ApplicationPSK.ha;
  else if (uu___4_4154->tag == TLSInfo_ResumptionPSK)
  {
    TLSInfo_pre_rmsId *i1 = uu___4_4154->val.case_ResumptionPSK.i;
    TLSInfo_logInfo li = uu___4_4154->val.case_ResumptionPSK.li;
    return TLSInfo_rmsId_hash(li, i1);
  }
  else if (uu___4_4154->tag == TLSInfo_NoPSK)
    return uu___4_4154->val.case_NoPSK;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Spec_Hash_Definitions_hash_alg TLSInfo_binderId_hash(TLSInfo_pre_binderId *uu___5_4163)
{
  TLSInfo_pre_esId *i1 = uu___5_4163->_0;
  return TLSInfo_esId_hash(i1);
}

Spec_Hash_Definitions_hash_alg TLSInfo_hsId_hash(TLSInfo_pre_hsId *uu___6_4166)
{
  if (uu___6_4166->tag == TLSInfo_HSID_PSK)
  {
    TLSInfo_pre_saltId *i1 = uu___6_4166->val.case_HSID_PSK;
    return TLSInfo_saltId_hash(i1);
  }
  else if (uu___6_4166->tag == TLSInfo_HSID_DHE)
  {
    TLSInfo_pre_saltId *i1 = uu___6_4166->val.case_HSID_DHE._0;
    return TLSInfo_saltId_hash(i1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Spec_Hash_Definitions_hash_alg TLSInfo_asId_hash(TLSInfo_pre_asId *uu___7_4181)
{
  TLSInfo_pre_saltId *i1 = uu___7_4181->_0;
  return TLSInfo_saltId_hash(i1);
}

Spec_Hash_Definitions_hash_alg TLSInfo_saltId_hash(TLSInfo_pre_saltId *uu___8_4183)
{
  TLSInfo_pre_secretId *i1 = uu___8_4183->_0;
  return TLSInfo_secretId_hash(i1);
}

Spec_Hash_Definitions_hash_alg TLSInfo_secretId_hash(TLSInfo_pre_secretId *uu___9_4185)
{
  if (uu___9_4185->tag == TLSInfo_EarlySecretID)
  {
    TLSInfo_pre_esId *i1 = uu___9_4185->val.case_EarlySecretID;
    return TLSInfo_esId_hash(i1);
  }
  else if (uu___9_4185->tag == TLSInfo_HandshakeSecretID)
  {
    TLSInfo_pre_hsId *i1 = uu___9_4185->val.case_HandshakeSecretID;
    return TLSInfo_hsId_hash(i1);
  }
  else if (uu___9_4185->tag == TLSInfo_ApplicationSecretID)
  {
    TLSInfo_pre_asId *i1 = uu___9_4185->val.case_ApplicationSecretID;
    return TLSInfo_asId_hash(i1);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Spec_Hash_Definitions_hash_alg TLSInfo_rmsId_hash(TLSInfo_logInfo li, TLSInfo_pre_rmsId *i1)
{
  TLSInfo_pre_asId *asId = i1->_0;
  return TLSInfo_asId_hash(asId);
}

Spec_Hash_Definitions_hash_alg
TLSInfo_exportId_hash(TLSInfo_logInfo li, TLSInfo_pre_exportId *i1)
{
  if (i1->tag == TLSInfo_EarlyExportID)
  {
    TLSInfo_pre_esId *esId = i1->val.case_EarlyExportID._0;
    return TLSInfo_esId_hash(esId);
  }
  else if (i1->tag == TLSInfo_ExportID)
  {
    TLSInfo_pre_asId *asId = i1->val.case_ExportID._0;
    return TLSInfo_asId_hash(asId);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Spec_Hash_Definitions_hash_alg
TLSInfo_expandId_hash(TLSInfo_logInfo li, TLSInfo_pre_expandId *i1)
{
  TLSInfo_pre_secretId *i2 = i1->_0;
  return TLSInfo_secretId_hash(i2);
}

Spec_Hash_Definitions_hash_alg TLSInfo_keyId_hash(TLSInfo_pre_keyId *uu___10_4218)
{
  TLSInfo_pre_expandId *i1 = uu___10_4218->i;
  TLSInfo_logInfo li = uu___10_4218->li;
  return TLSInfo_expandId_hash(li, i1);
}

Spec_Hash_Definitions_hash_alg TLSInfo_finishedId_hash(TLSInfo_pre_finishedId *uu___11_4223)
{
  TLSInfo_pre_expandId *i1 = uu___11_4223->_1;
  TLSInfo_logInfo li = uu___11_4223->li;
  return TLSInfo_expandId_hash(li, i1);
}

EverCrypt_aead_alg TLSInfo_esId_ae(TLSInfo_pre_esId *i1)
{
  if (i1->tag == TLSInfo_ApplicationPSK)
    return i1->val.case_ApplicationPSK.ae;
  else if (i1->tag == TLSInfo_ResumptionPSK)
  {
    TLSInfo_logInfo li = i1->val.case_ResumptionPSK.li;
    return TLSInfo_logInfo_ae(li);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_ES(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_ES)
    return true;
  else
    return false;
}

TLSInfo_pre_esId *TLSInfo___proj__I_ES__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_ES)
    return projectee.val.case_I_ES;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_BINDER(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_BINDER)
    return true;
  else
    return false;
}

TLSInfo_pre_binderId *TLSInfo___proj__I_BINDER__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_BINDER)
    return projectee.val.case_I_BINDER;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_HS(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_HS)
    return true;
  else
    return false;
}

TLSInfo_pre_hsId *TLSInfo___proj__I_HS__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_HS)
    return projectee.val.case_I_HS;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_AS(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_AS)
    return true;
  else
    return false;
}

TLSInfo_pre_asId *TLSInfo___proj__I_AS__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_AS)
    return projectee.val.case_I_AS;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_SALT(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_SALT)
    return true;
  else
    return false;
}

TLSInfo_pre_saltId *TLSInfo___proj__I_SALT__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_SALT)
    return projectee.val.case_I_SALT;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_SECRET(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_SECRET)
    return true;
  else
    return false;
}

TLSInfo_pre_secretId *TLSInfo___proj__I_SECRET__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_SECRET)
    return projectee.val.case_I_SECRET;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_RMS(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_RMS)
    return true;
  else
    return false;
}

TLSInfo_logInfo TLSInfo___proj__I_RMS__item__li(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_RMS)
    return projectee.val.case_I_RMS.li;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_pre_rmsId *TLSInfo___proj__I_RMS__item___1(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_RMS)
    return projectee.val.case_I_RMS._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_EXPORT(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_EXPORT)
    return true;
  else
    return false;
}

TLSInfo_logInfo TLSInfo___proj__I_EXPORT__item__li(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_EXPORT)
    return projectee.val.case_I_EXPORT.li;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_pre_exportId *TLSInfo___proj__I_EXPORT__item___1(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_EXPORT)
    return projectee.val.case_I_EXPORT._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_EXPAND(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_EXPAND)
    return true;
  else
    return false;
}

TLSInfo_logInfo TLSInfo___proj__I_EXPAND__item__li(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_EXPAND)
    return projectee.val.case_I_EXPAND.li;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_pre_expandId *TLSInfo___proj__I_EXPAND__item___1(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_EXPAND)
    return projectee.val.case_I_EXPAND._1;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_KEY(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_KEY)
    return true;
  else
    return false;
}

TLSInfo_pre_keyId *TLSInfo___proj__I_KEY__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_KEY)
    return projectee.val.case_I_KEY;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_I_FINISHED(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_FINISHED)
    return true;
  else
    return false;
}

TLSInfo_pre_finishedId *TLSInfo___proj__I_FINISHED__item___0(TLSInfo_pre_index projectee)
{
  if (projectee.tag == TLSInfo_I_FINISHED)
    return projectee.val.case_I_FINISHED;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

void *TLSInfo_safety_table = (void *)(uint8_t)0U;

bool TLSInfo_uu___is_PlaintextID(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_PlaintextID)
    return true;
  else
    return false;
}

FStar_Bytes_bytes TLSInfo___proj__PlaintextID__item__our_rand(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_PlaintextID)
    return projectee.val.case_PlaintextID;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ID13(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID13)
    return true;
  else
    return false;
}

TLSInfo_pre_keyId *TLSInfo___proj__ID13__item__keyId(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID13)
    return projectee.val.case_ID13;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool TLSInfo_uu___is_ID12(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return true;
  else
    return false;
}

Parsers_ProtocolVersion_protocolVersion TLSInfo___proj__ID12__item__pv(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.pv;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_msId TLSInfo___proj__ID12__item__msId(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.msId;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_prePrfAlg TLSInfo___proj__ID12__item__kdfAlg(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.kdfAlg;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CipherSuite_aeAlg TLSInfo___proj__ID12__item__aeAlg(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.aeAlg;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes TLSInfo___proj__ID12__item__cr(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.cr;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Bytes_bytes TLSInfo___proj__ID12__item__sr(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.sr;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_role TLSInfo___proj__ID12__item__writer(TLSInfo_id projectee)
{
  if (projectee.tag == TLSInfo_ID12)
    return projectee.val.case_ID12.writer;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_expandTag *TLSInfo_peerLabel(TLSInfo_expandTag *uu___12_5194)
{
  if (uu___12_5194[0U] == TLSInfo_ClientEarlyTrafficSecret)
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf[0U] = TLSInfo_ClientEarlyTrafficSecret;
    return buf;
  }
  else if (uu___12_5194[0U] == TLSInfo_ApplicationTrafficSecret)
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf[0U] = TLSInfo_ApplicationTrafficSecret;
    return buf;
  }
  else if (uu___12_5194[0U] == TLSInfo_ClientHandshakeTrafficSecret)
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf[0U] = TLSInfo_ServerHandshakeTrafficSecret;
    return buf;
  }
  else if (uu___12_5194[0U] == TLSInfo_ServerHandshakeTrafficSecret)
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf[0U] = TLSInfo_ClientHandshakeTrafficSecret;
    return buf;
  }
  else if (uu___12_5194[0U] == TLSInfo_ClientApplicationTrafficSecret)
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf[0U] = TLSInfo_ServerApplicationTrafficSecret;
    return buf;
  }
  else if (uu___12_5194[0U] == TLSInfo_ServerApplicationTrafficSecret)
  {
    KRML_CHECK_SIZE(sizeof (TLSInfo_expandTag), (uint32_t)1U);
    TLSInfo_expandTag *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_expandTag));
    buf[0U] = TLSInfo_ClientApplicationTrafficSecret;
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_id TLSInfo_peerId(TLSInfo_id uu___13_5214)
{
  if (uu___13_5214.tag == TLSInfo_PlaintextID)
  {
    FStar_Bytes_bytes r = uu___13_5214.val.case_PlaintextID;
    return ((TLSInfo_id){ .tag = TLSInfo_PlaintextID, .val = { .case_PlaintextID = r } });
  }
  else if (uu___13_5214.tag == TLSInfo_ID12)
  {
    TLSConstants_role rw = uu___13_5214.val.case_ID12.writer;
    FStar_Bytes_bytes sr = uu___13_5214.val.case_ID12.sr;
    FStar_Bytes_bytes cr = uu___13_5214.val.case_ID12.cr;
    CipherSuite_aeAlg ae = uu___13_5214.val.case_ID12.aeAlg;
    TLSConstants_prePrfAlg kdf = uu___13_5214.val.case_ID12.kdfAlg;
    TLSInfo_msId msid1 = uu___13_5214.val.case_ID12.msId;
    Parsers_ProtocolVersion_protocolVersion pv = uu___13_5214.val.case_ID12.pv;
    return
      (
        (TLSInfo_id){
          .tag = TLSInfo_ID12,
          .val = {
            .case_ID12 = {
              .pv = pv, .msId = msid1, .kdfAlg = kdf, .aeAlg = ae, .cr = cr, .sr = sr,
              .writer = TLSConstants_dualRole(rw)
            }
          }
        }
      );
  }
  else if (uu___13_5214.tag == TLSInfo_ID13)
  {
    FStar_Bytes_bytes log = uu___13_5214.val.case_ID13->i->_2;
    TLSInfo_expandTag *t = uu___13_5214.val.case_ID13->i->_1;
    TLSInfo_pre_secretId *s = uu___13_5214.val.case_ID13->i->_0;
    TLSInfo_logInfo li = uu___13_5214.val.case_ID13->li;
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_expandId), (uint32_t)1U);
    TLSInfo_pre_expandId *buf = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_expandId));
    buf[0U] = ((TLSInfo_pre_expandId){ ._0 = s, ._1 = TLSInfo_peerLabel(t), ._2 = log });
    KRML_CHECK_SIZE(sizeof (TLSInfo_pre_keyId), (uint32_t)1U);
    TLSInfo_pre_keyId *kid = KRML_HOST_MALLOC(sizeof (TLSInfo_pre_keyId));
    kid[0U] = ((TLSInfo_pre_keyId){ .li = li, .i = buf });
    return ((TLSInfo_id){ .tag = TLSInfo_ID13, .val = { .case_ID13 = kid } });
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSInfo_id TLSInfo_siId(TLSInfo_sessionInfo si, TLSConstants_role r)
{
  K___FStar_Bytes_bytes_FStar_Bytes_bytes
  scrut = FStar_Bytes_split(TLSInfo_csrands(si), (uint32_t)32U);
  FStar_Bytes_bytes cr = scrut.fst;
  FStar_Bytes_bytes sr = scrut.snd;
  return
    (
      (TLSInfo_id){
        .tag = TLSInfo_ID12,
        .val = {
          .case_ID12 = {
            .pv = si.protocol_version, .msId = TLSInfo_msid(si),
            .kdfAlg = TLSInfo_kdfAlg(si.protocol_version, si.cipher_suite),
            .aeAlg = TLSInfo_siAuthEncAlg(si), .cr = cr, .sr = sr, .writer = r
          }
        }
      }
    );
}

Parsers_ProtocolVersion_protocolVersion TLSInfo_pv_of_id(TLSInfo_id i1)
{
  if (i1.tag == TLSInfo_ID13)
    return ((Parsers_ProtocolVersion_protocolVersion){ .tag = Parsers_ProtocolVersion_TLS_1p3 });
  else if (i1.tag == TLSInfo_ID12)
    return i1.val.case_ID12.pv;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool __eq__TLSConstants_role(TLSConstants_role y, TLSConstants_role x)
{
  switch (x)
  {
    case TLSConstants_Client:
      {
        switch (y)
        {
          case TLSConstants_Client:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case TLSConstants_Server:
      {
        switch (y)
        {
          case TLSConstants_Server:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

FStar_Bytes_bytes TLSInfo_nonce_of_id(TLSInfo_id i1)
{
  if (i1.tag == TLSInfo_PlaintextID)
    return i1.val.case_PlaintextID;
  else if (i1.tag == TLSInfo_ID13)
  {
    TLSInfo_logInfo li = i1.val.case_ID13->li;
    return TLSInfo_logInfo_nonce(li);
  }
  else if (i1.tag == TLSInfo_ID12)
  {
    TLSConstants_role rw = i1.val.case_ID12.writer;
    FStar_Bytes_bytes sr = i1.val.case_ID12.sr;
    FStar_Bytes_bytes cr = i1.val.case_ID12.cr;
    if (__eq__TLSConstants_role(rw, TLSConstants_Client))
      return cr;
    else
      return sr;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

TLSConstants_prePrfAlg TLSInfo_kdfAlg_of_id(TLSInfo_id uu___14_5329)
{
  if (uu___14_5329.tag == TLSInfo_ID12)
    return uu___14_5329.val.case_ID12.kdfAlg;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Spec_Hash_Definitions_hash_alg TLSInfo_macAlg_of_id(TLSInfo_id uu___15_5350)
{
  if (uu___15_5350.tag == TLSInfo_ID12)
  {
    CipherSuite_aeAlg ae = uu___15_5350.val.case_ID12.aeAlg;
    Parsers_ProtocolVersion_protocolVersion pv = uu___15_5350.val.case_ID12.pv;
    return TLSConstants_macAlg_of_aeAlg(pv, ae);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

K___CipherSuite_encAlg_CipherSuite_ivMode TLSInfo_encAlg_of_id(TLSInfo_id uu___16_5375)
{
  if (uu___16_5375.tag == TLSInfo_ID12)
  {
    CipherSuite_aeAlg ae = uu___16_5375.val.case_ID12.aeAlg;
    Parsers_ProtocolVersion_protocolVersion pv = uu___16_5375.val.case_ID12.pv;
    return TLSConstants_encAlg_of_aeAlg(pv, ae);
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

CipherSuite_aeAlg TLSInfo_aeAlg_of_id(TLSInfo_id uu___17_5398)
{
  if (uu___17_5398.tag == TLSInfo_ID13)
  {
    TLSInfo_logInfo li = uu___17_5398.val.case_ID13->li;
    return
      (
        (CipherSuite_aeAlg){
          .tag = CipherSuite_AEAD,
          .val = { .case_AEAD = { ._0 = TLSInfo_logInfo_ae(li), ._1 = TLSInfo_logInfo_hash(li) } }
        }
      );
  }
  else if (uu___17_5398.tag == TLSInfo_ID12)
    return uu___17_5398.val.case_ID12.aeAlg;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

Prims_string TLSInfo_sinfo_to_string(TLSInfo_sessionInfo si)
{
  return "TODO";
}

bool TLSInfo_safeId(TLSInfo_id i1)
{
  return false;
}

bool TLSInfo_authId(TLSInfo_id i1)
{
  return false;
}

